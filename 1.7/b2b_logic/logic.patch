--- trunk/src/opensips_1_7/modules/b2b_logic/logic.c	2013-01-28 11:09:15.400687720 +0000
+++ b2b_logic/logic.c	2013-01-28 11:07:39.084687875 +0000
@@ -90,12 +90,10 @@
 	str body;
 
 	body.s=get_body(msg);
-
 	if(!msg->body_lumps)
 		return 0;
 	len = lumps_len(msg, msg->body_lumps, 0)
 		+ get_content_length(msg);
-
 	LM_DBG("*** len = %d\n", len);
 
 	buf=(char*)pkg_malloc(len+1);
@@ -112,7 +110,7 @@
 
 	new_body->s = buf;
 	new_body->len = len;
-
+	
 	memcpy(buf+offset, msg->buf+s_offset, len - offset);
 
 	LM_DBG("new_body= [%.*s], len=%d\n", new_body->len, new_body->s, len);
@@ -2619,6 +2617,33 @@
 	LM_DBG("Gen from_tag= %s\n", fromtag_buf);
 }
 
+/*******************************************************************************
+*        NAME: Xsnprintf()
+* DESCRIPTION: Allows use of recursion in a snprintf implementation
+******************************************************************************/
+int Xsnprintf(char *dst, size_t size, const char *format, ...)
+{
+  char *tmp;
+  int retval;
+  va_list  pArguments;
+
+  if(dst == NULL || size <= 0)
+     return -1;
+
+  tmp = (char *) malloc(size);
+
+  if(tmp == NULL)
+     return -1;
+
+  va_start(pArguments, format);
+  retval = vsnprintf(tmp, size, format, pArguments);
+  va_end(pArguments);
+
+  memcpy(dst, tmp, size);
+  free(tmp);
+
+  return retval;
+}
 
 str* create_top_hiding_entities(struct sip_msg* msg, b2bl_cback_f cbf,
 		void* cb_param, unsigned int cb_mask, str* custom_hdrs)
@@ -2689,6 +2714,8 @@
 	tuple->lifetime = 60 + get_ticks();
 
 	/* create new server */
+
+
 	server_id = b2b_api.server_new(msg, &tuple->local_contact,
 			b2b_server_notify, b2bl_key);
 	if(server_id == NULL)
@@ -2738,6 +2765,7 @@
 
 	client_id = b2b_api.client_new(&ci, b2b_client_notify,
 			b2b_add_dlginfo, b2bl_key);
+
 	if(client_id == NULL)
 	{
 		LM_ERR("failed to create new b2b client instance\n");
@@ -2813,6 +2841,74 @@
 		b2bl_db_insert(tuple);
 	}
 
+	// (JORGE) Get ids and add them in the connections structures
+
+	struct to_body *pfrom;          //Structure contFrom header
+
+	if( parse_from_header( msg ) != 0 )
+	{                    // Parse header FROM
+		LM_ERR("ERROR. Error parsing from header\n");
+		goto error;
+	}
+
+	pfrom = get_from(msg);          //Get structure containing From header
+
+	if(pfrom==NULL)
+	{
+		LM_ERR("Error. pfrom has null value\n");
+		goto error;
+	}
+
+	int len_from_tag = pfrom->tag_value.len+1;
+	int len_callid = msg->callid->body.len+1;
+	int len_b2b_call_ID = client_id->len+1;
+	int len_server_call_ID = server_id->len+1;
+	int len_key = b2bl_key->len+1;
+	int len_from_tag_gen = from_tag_gen.len+1;
+
+	char orig_call_ID[128];
+	bzero(orig_call_ID,128);
+
+	if(client_id->s==NULL || server_id->s==NULL || b2bl_key->s==NULL || from_tag_gen.s==NULL || len_from_tag==0 || len_callid==0)
+	{
+		LM_ERR("ERROR. Null values generated by opensips\n");
+		if(len_callid>0)
+		{
+			Xsnprintf(orig_call_ID,msg->callid->body.len+1,msg->callid->body.s);
+			b2b_xcoder.free_xcoder_resources(orig_call_ID);
+		}
+		goto error;
+	}
+
+	if(len_from_tag>128 || len_callid>128 || len_b2b_call_ID>128 || len_server_call_ID>128 || len_key>128 || len_from_tag_gen>128)
+	{
+		LM_ERR("Value higher than acceptable size.len_from_tag %d | len_callid %d | len_b2b_call_ID %d | len_server_call_ID %d | len_key %d | len_from_tag_gen %d\n",
+				len_from_tag,len_callid,len_b2b_call_ID,len_server_call_ID,len_key,len_from_tag_gen);
+		goto error;
+	}
+
+	char from_tag[128]; bzero(from_tag,128);
+	Xsnprintf(from_tag,pfrom->tag_value.len+1,pfrom->tag_value.s);
+
+	char b2b_call_ID[128];
+	char b2b_server_call_ID[128];
+	char b2b_key[128];
+	char b2b_from_tag_gen[128];
+	bzero(b2b_call_ID,128);
+	bzero(b2b_server_call_ID,128);
+	bzero(b2b_key,128);
+	bzero(b2b_from_tag_gen,128);
+
+	Xsnprintf(orig_call_ID,msg->callid->body.len+1,msg->callid->body.s);
+	Xsnprintf(b2b_call_ID,client_id->len+1,client_id->s);
+	Xsnprintf(b2b_server_call_ID,server_id->len+1,server_id->s);
+	Xsnprintf(b2b_key,b2bl_key->len+1,b2bl_key->s);
+	Xsnprintf(b2b_from_tag_gen,from_tag_gen.len+1,from_tag_gen.s);
+
+	b2b_xcoder.add_b2b_callID(orig_call_ID,b2b_call_ID,b2b_server_call_ID,b2b_key,from_tag,b2b_from_tag_gen);
+
+	// End of (JORGE) modifications
+
 	lock_release(&b2bl_htable[hash_index].lock);
 
 	pkg_free(to_uri.s);
