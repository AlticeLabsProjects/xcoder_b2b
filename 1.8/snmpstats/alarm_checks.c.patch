--- trunk/src/opensips_1_8/modules/snmpstats/alarm_checks.c	2013-04-23 17:33:50.020937751 +0100
+++ alarm_checks.c	2013-04-23 17:47:57.309132070 +0100
@@ -38,6 +38,8 @@
 #include "utilities.h"
 #include "openserObjects.h"
 #include "openserMIBNotifications.h"
+#include "snmp_xcoder_b2b_traps.h" //JORGE
+#include "snmp_xcoder_b2b_threshold.h" //JORGE
 
 /* Returns the number of bytes currently waiting in the msg queue if they exceed
  * the threshold, and zero otherwise.  If threshold_to_compare_to is < 0, then
@@ -94,6 +96,16 @@
 	static int dialog_minor_threshold;
 	static int dialog_major_threshold;
 
+	//Jorge
+	static int memory_major_threshold;
+	static int unsup_methods_threshold;
+	static int parse_request_threshold;
+	static int parse_response_err_threshold;
+	static int get_ports_threshold;
+	static int call_create_threshold;
+   static int active_transcoder_calls_threshold;
+	//Jorge end
+
 	static char firstRun = 1;
 	
 	int bytesInMsgQueue;
@@ -110,6 +122,16 @@
 		dialog_minor_threshold = get_dialog_minor_threshold();
 		dialog_major_threshold = get_dialog_major_threshold();
 
+		//Jorge
+		memory_major_threshold =               get_memory_major_threshold();
+		unsup_methods_threshold =              get_unsup_methods_threshold();
+		parse_request_threshold =              get_parse_request_threshold();
+		parse_response_err_threshold =         get_parse_response_err_threshold();
+		get_ports_threshold =                  get_get_ports_threshold();
+		call_create_threshold =                get_call_create_threshold();
+		active_transcoder_calls_threshold =    get_active_transcoder_calls_threshold();
+		//Jorge end
+
 		firstRun = 0;
 	}
 	
@@ -157,6 +179,132 @@
 		send_openserDialogLimitMajorEvent_trap(numActiveDialogs,
 						dialog_major_threshold);
 	}
+
+	//Jorge
+
+	LM_INFO("Check for alarm conditions\n");
+
+	int free_memory;
+	int unsupported_methods;
+	int parse_req;
+	int parse_reply;
+	int xcoder_ports;
+	int xcoder_create_call;
+	int transcoder_calls;
+
+	/* Check for maximum transcoder calls alarm conditions */
+
+	transcoder_calls = check_transcoder_calls_alarm(active_transcoder_calls_threshold);
+
+   if (transcoder_calls != 0)
+   {
+      LM_NOTICE("Maximum active transcoder calls achieved | active_calls=%d. Sending trap.\n",transcoder_calls);
+      GenerateTrap(TRAP_MAX_ACTIVE_CALLS,1);
+   }
+   else if(*max_calls_trap_state==SERVICE_NOK)
+   {
+      LM_NOTICE("Putting system back to normal for maximum active transcoder calls alarm. Send trap to normalize alarm.\n");
+      GenerateTrap(TRAP_MAX_ACTIVE_CALLS,5);
+   }
+
+	/* Check for memory alarm conditions */
+
+	free_memory = check_memory_alarm(memory_major_threshold);
+
+   if (free_memory != 0)
+   {
+      LM_NOTICE("Low free memory threshold value achieved | Free_memory=%d. Sending trap.\n",free_memory);
+      GenerateTrap(TRAP_LOW_FREE_MEMORY,2);
+   }
+   else if(*low_memory_trap_state==SERVICE_NOK)
+   {
+      LM_NOTICE("Putting system back to normal for low free memory alarm. Send trap to normalize alarm.\n");
+      GenerateTrap(TRAP_LOW_FREE_MEMORY,5);
+   }
+
+	/* Check for unsupported methods alarm conditions: */
+
+   unsupported_methods = check_unsupported_methods_alarm(unsup_methods_threshold);
+
+	if( unsupported_methods!=0)
+	{
+	   LM_NOTICE("Unsupported methods threshold value achieved | Unsup_methods = %d. Sending trap.\n",unsupported_methods);
+	   GenerateTrap(TRAP_UNSUPPORTED_METHODS,4);
+	}
+	else if(*unsup_method_trap_state==SERVICE_NOK)
+	{
+	   LM_NOTICE("Putting system back to normal for unsupported methods alarm. Send trap to normalize alarm.\n");
+	   GenerateTrap(TRAP_UNSUPPORTED_METHODS,5);
+	}
+	update_value(get_statistic("unsupported_methods"),TRAP_UNSUPPORTED_METHODS);
+
+	/* Check for parse request error alarm conditions: */
+
+	parse_req = check_parse_req_alarm(parse_request_threshold);
+
+	if(parse_req!=0)
+	{
+	   LM_NOTICE("Parse requests errors threshold value achieved | parse_req_errors = %d. Sending trap.\n",parse_req);
+	   GenerateTrap(TRAP_PARSE_REQUEST,2);
+	}
+	else if(*parse_req_trap_state==SERVICE_NOK)
+	{
+	   LM_NOTICE("Putting system back to normal for parse requests error alarm. Send trap to normalize alarm.\n");
+	   GenerateTrap(TRAP_PARSE_REQUEST,5);
+	}
+	update_value(b2b_xcoder.get_parse_req_err(),TRAP_PARSE_REQUEST);
+
+	/* Check for parse replies error alarm conditions: */
+
+	parse_reply = check_parse_reply_alarm(parse_response_err_threshold);
+
+	if(parse_reply!=0)
+	{
+	   LM_NOTICE("Parse reply errors threshold value achieved | parse_reply_erros = %d. Sending trap.\n",parse_reply);
+	   GenerateTrap(TRAP_PARSE_RESPONSE,2);
+	}
+	else if(*parse_resp_trap_state==SERVICE_NOK)
+	{
+	   LM_NOTICE("Putting system back to normal for parse replies error alarm. Send trap to normalize alarm.\n");
+	   GenerateTrap(TRAP_PARSE_RESPONSE,5);
+	}
+	update_value(b2b_xcoder.get_parse_resp_err(),TRAP_PARSE_RESPONSE);
+
+	/* Check for xcoder get_ports error alarm conditions: */
+
+	xcoder_ports = check_xcoder_port_alarm(get_ports_threshold);
+
+   if(xcoder_ports!=0)
+   {
+      LM_NOTICE("Xcoder get_ports errors threshold value achieved | xcoder get_ports_erros = %d. Sending trap.\n",xcoder_ports);
+      GenerateTrap(TRAP_XCODER_PORTS,2);
+   }
+   else if(*xcoder_ports_trap_state==SERVICE_NOK)
+   {
+      LM_NOTICE("Putting system back to normal xcoder get_ports error alarm. Send trap to normalize alarm.\n");
+      GenerateTrap(TRAP_XCODER_PORTS,5);
+   }
+   update_value(b2b_xcoder.get_xcoder_ports_err(),TRAP_XCODER_PORTS);
+
+   /* Check for xcoder create_call error alarm conditions: */
+
+   xcoder_create_call = check_create_call_alarm(call_create_threshold);
+
+   if(xcoder_create_call!=0)
+   {
+      LM_NOTICE("Xcoder create_call errors threshold value achieved | xcoder create_call_erros = %d. Sending trap.\n",xcoder_create_call);
+      GenerateTrap(TRAP_XCODER_CREATE_CALL,1);
+   }
+   else if(*create_call_trap_state==SERVICE_NOK)
+   {
+      LM_NOTICE("Putting system back to normal xcoder create_call error alarm. Send trap to normalize alarm.\n");
+      GenerateTrap(TRAP_XCODER_CREATE_CALL,5);
+   }
+   update_value(b2b_xcoder.get_create_call_err(),TRAP_XCODER_CREATE_CALL);
+
+   LM_INFO("End check for alarm conditions\n");
+
+	//End Jorge
 }
 
 
