diff -Naur opensips-1.8.3-tls/modules/snmpstats/alarm_checks.c snmpstats/alarm_checks.c
--- opensips-1.8.3-tls/modules/snmpstats/alarm_checks.c	2012-03-26 10:05:33.000000000 +0100
+++ snmpstats/alarm_checks.c	2013-09-24 11:20:48.235637172 +0100
@@ -38,6 +38,8 @@
 #include "utilities.h"
 #include "openserObjects.h"
 #include "openserMIBNotifications.h"
+#include "snmp_xcoder_b2b_traps.h" //JORGE
+#include "snmp_xcoder_b2b_threshold.h" //JORGE
 
 /* Returns the number of bytes currently waiting in the msg queue if they exceed
  * the threshold, and zero otherwise.  If threshold_to_compare_to is < 0, then
@@ -94,6 +96,16 @@
 	static int dialog_minor_threshold;
 	static int dialog_major_threshold;
 
+	//Jorge
+	static int memory_major_threshold;
+	static int unsup_methods_threshold;
+	static int parse_request_threshold;
+	static int parse_response_err_threshold;
+	static int get_ports_threshold;
+	static int call_create_threshold;
+   static int active_transcoder_calls_threshold;
+	//Jorge end
+
 	static char firstRun = 1;
 	
 	int bytesInMsgQueue;
@@ -110,6 +122,16 @@
 		dialog_minor_threshold = get_dialog_minor_threshold();
 		dialog_major_threshold = get_dialog_major_threshold();
 
+		//Jorge
+		memory_major_threshold =               get_memory_major_threshold();
+		unsup_methods_threshold =              get_unsup_methods_threshold();
+		parse_request_threshold =              get_parse_request_threshold();
+		parse_response_err_threshold =         get_parse_response_err_threshold();
+		get_ports_threshold =                  get_get_ports_threshold();
+		call_create_threshold =                get_call_create_threshold();
+		active_transcoder_calls_threshold =    get_active_transcoder_calls_threshold();
+		//Jorge end
+
 		firstRun = 0;
 	}
 	
@@ -157,6 +179,131 @@
 		send_openserDialogLimitMajorEvent_trap(numActiveDialogs,
 						dialog_major_threshold);
 	}
+
+	//Jorge
+
+	LM_INFO("Check for alarm conditions\n");
+
+	int free_memory;
+	int unsupported_methods;
+	int parse_req;
+	int parse_reply;
+	int xcoder_ports;
+	int xcoder_create_call;
+	int transcoder_calls;
+
+	/* Check for maximum transcoder calls alarm conditions */
+
+	transcoder_calls = check_transcoder_calls_alarm(active_transcoder_calls_threshold);
+
+   if (transcoder_calls != 0)
+   {
+      LM_NOTICE("Maximum active transcoder calls achieved | active_calls=%d. Sending trap.\n",transcoder_calls);
+      GenerateTrap(TRAP_MAX_ACTIVE_CALLS,1);
+   }
+   else if(*max_calls_trap_state==SERVICE_NOK)
+   {
+      LM_NOTICE("Putting system back to normal for maximum active transcoder calls alarm. Send trap to normalize alarm.\n");
+      GenerateTrap(TRAP_MAX_ACTIVE_CALLS,5);
+   }
+
+	/* Check for memory alarm conditions */
+
+	free_memory = check_memory_alarm(memory_major_threshold);
+
+   if (free_memory != 0)
+   {
+      LM_NOTICE("Low free memory threshold value achieved | Free_memory=%d. Sending trap.\n",free_memory);
+      GenerateTrap(TRAP_LOW_FREE_MEMORY,2);
+   }
+   else if(*low_memory_trap_state==SERVICE_NOK)
+   {
+      LM_NOTICE("Putting system back to normal for low free memory alarm. Send trap to normalize alarm.\n");
+      GenerateTrap(TRAP_LOW_FREE_MEMORY,5);
+   }
+
+	/* Check for unsupported methods alarm conditions: */
+
+   unsupported_methods = check_unsupported_methods_alarm(unsup_methods_threshold);
+
+	if( unsupported_methods!=0)
+	{
+	   LM_NOTICE("Unsupported methods threshold value achieved | Unsup_methods = %d. Sending trap.\n",unsupported_methods);
+	   GenerateTrap(TRAP_UNSUPPORTED_METHODS,4);
+	}
+	else if(*unsup_method_trap_state==SERVICE_NOK)
+	{
+	   LM_NOTICE("Putting system back to normal for unsupported methods alarm. Send trap to normalize alarm.\n");
+	   GenerateTrap(TRAP_UNSUPPORTED_METHODS,5);
+	}
+	update_value(get_statistic("unsupported_methods"),TRAP_UNSUPPORTED_METHODS);
+
+	/* Check for parse request error alarm conditions: */
+
+	parse_req = check_parse_req_alarm(parse_request_threshold);
+
+	if(parse_req!=0)
+	{
+	   LM_NOTICE("Parse requests errors threshold value achieved | parse_req_errors = %d. Sending trap.\n",parse_req);
+	   GenerateTrap(TRAP_PARSE_REQUEST,2);
+	}
+	else if(*parse_req_trap_state==SERVICE_NOK)
+	{
+	   LM_NOTICE("Putting system back to normal for parse requests error alarm. Send trap to normalize alarm.\n");
+	   GenerateTrap(TRAP_PARSE_REQUEST,5);
+	}
+	update_value(b2b_xcoder.get_parse_req_err(),TRAP_PARSE_REQUEST);
+
+	/* Check for parse replies error alarm conditions: */
+
+	parse_reply = check_parse_reply_alarm(parse_response_err_threshold);
+	if(parse_reply!=0)
+	{
+	   LM_NOTICE("Parse reply errors threshold value achieved | parse_reply_erros = %d. Sending trap.\n",parse_reply);
+	   GenerateTrap(TRAP_PARSE_RESPONSE,2);
+	}
+	else if(*parse_resp_trap_state==SERVICE_NOK)
+	{
+	   LM_NOTICE("Putting system back to normal for parse replies error alarm. Send trap to normalize alarm.\n");
+	   GenerateTrap(TRAP_PARSE_RESPONSE,5);
+	}
+	update_value(b2b_xcoder.get_parse_resp_err(),TRAP_PARSE_RESPONSE);
+
+	/* Check for xcoder get_ports error alarm conditions: */
+
+	xcoder_ports = check_xcoder_port_alarm(get_ports_threshold);
+
+   if(xcoder_ports!=0)
+   {
+      LM_NOTICE("Xcoder get_ports errors threshold value achieved | xcoder get_ports_erros = %d. Sending trap.\n",xcoder_ports);
+      GenerateTrap(TRAP_XCODER_PORTS,2);
+   }
+   else if(*xcoder_ports_trap_state==SERVICE_NOK)
+   {
+      LM_NOTICE("Putting system back to normal xcoder get_ports error alarm. Send trap to normalize alarm.\n");
+      GenerateTrap(TRAP_XCODER_PORTS,5);
+   }
+   update_value(b2b_xcoder.get_xcoder_ports_err(),TRAP_XCODER_PORTS);
+
+   /* Check for xcoder create_call error alarm conditions: */
+
+   xcoder_create_call = check_create_call_alarm(call_create_threshold);
+
+   if(xcoder_create_call!=0)
+   {
+      LM_NOTICE("Xcoder create_call errors threshold value achieved | xcoder create_call_erros = %d. Sending trap.\n",xcoder_create_call);
+      GenerateTrap(TRAP_XCODER_CREATE_CALL,1);
+   }
+   else if(*create_call_trap_state==SERVICE_NOK)
+   {
+      LM_NOTICE("Putting system back to normal xcoder create_call error alarm. Send trap to normalize alarm.\n");
+      GenerateTrap(TRAP_XCODER_CREATE_CALL,5);
+   }
+   update_value(b2b_xcoder.get_create_call_err(),TRAP_XCODER_CREATE_CALL);
+
+   LM_INFO("End check for alarm conditions\n");
+
+	//End Jorge
 }
 
 
diff -Naur opensips-1.8.3-tls/modules/snmpstats/alarm_checks.h snmpstats/alarm_checks.h
--- opensips-1.8.3-tls/modules/snmpstats/alarm_checks.h	2012-03-26 10:05:33.000000000 +0100
+++ snmpstats/alarm_checks.h	2013-09-24 11:20:48.239637017 +0100
@@ -32,7 +32,7 @@
 #ifndef _SNMPSTATS_ALARM_AGENT_
 #define _SNMPSTATS_ALARM_AGENT_
 
-#define ALARM_AGENT_FREQUENCY_IN_SECONDS 5
+#define ALARM_AGENT_FREQUENCY_IN_SECONDS 5 //Jorge. Obsolete, now this parameter is passed in the configuration file
 #define ALARM_AGENT_NAME                 "snmpstats_alarm_agent"
 
 /* Returns the number of bytes currently waiting in the msg queue if they exceed
diff -Naur opensips-1.8.3-tls/modules/snmpstats/openserMIBNotifications.c snmpstats/openserMIBNotifications.c
--- opensips-1.8.3-tls/modules/snmpstats/openserMIBNotifications.c	2012-03-26 10:05:33.000000000 +0100
+++ snmpstats/openserMIBNotifications.c	2013-09-24 11:20:48.243637207 +0100
@@ -240,3 +240,5 @@
 
 	return SNMP_ERR_NOERROR;
 }
+
+
diff -Naur opensips-1.8.3-tls/modules/snmpstats/openserMIBNotifications.h snmpstats/openserMIBNotifications.h
--- opensips-1.8.3-tls/modules/snmpstats/openserMIBNotifications.h	2012-03-26 10:05:33.000000000 +0100
+++ snmpstats/openserMIBNotifications.h	2013-09-24 11:20:48.247637214 +0100
@@ -80,4 +80,5 @@
  */
 int send_openserDialogLimitMajorEvent_trap(int numDialogs, int threshold);
 
+
 #endif /* OPENSERMIBNOTIFICATIONS_H */
diff -Naur opensips-1.8.3-tls/modules/snmpstats/snmpstats.c snmpstats/snmpstats.c
--- opensips-1.8.3-tls/modules/snmpstats/snmpstats.c	2012-12-19 14:40:13.000000000 +0000
+++ snmpstats/snmpstats.c	2013-09-24 11:20:48.251637294 +0100
@@ -79,6 +79,8 @@
 #include "utilities.h"
 #include "sub_agent.h"
 
+#include "snmp_xcoder_b2b_traps.h" //JORGE
+
 /* Required in every OpenSIPS Module. */
 
 
@@ -216,7 +218,6 @@
 static int mod_init(void) 
 {
 	LM_INFO("Starting up the SNMPStats Module\n");
-
 	if (register_message_code_statistics() < 0) 
 	{
 		return -1;
@@ -251,7 +252,62 @@
 
 	
 	/* Register the alarm checking function to run periodically */
-	register_timer(run_alarm_check, 0, ALARM_AGENT_FREQUENCY_IN_SECONDS);
+	//Begin Jorge
+//	register_timer(run_alarm_check, 0, ALARM_AGENT_FREQUENCY_IN_SECONDS);
+	int alarm_freq;
+	alarm_freq = get_alarm_freq();
+	register_timer(run_alarm_check, 0, alarm_freq);
+
+	trap_number = shm_malloc(sizeof(int));
+   *trap_number = 1;
+   last_unsupported_methods = shm_malloc(sizeof(int));
+   *last_unsupported_methods = 0;
+   last_parse_req = shm_malloc(sizeof(int));
+   *last_parse_req=0;
+   last_parse_resp = shm_malloc(sizeof(int));
+   *last_parse_resp=0;
+   last_xcoder_ports = shm_malloc(sizeof(int));
+   *last_xcoder_ports=0;
+   last_create_call = shm_malloc(sizeof(int));
+   *last_create_call=0;
+
+   unsup_method_trap_state = shm_malloc(sizeof(int));
+   *unsup_method_trap_state = SERVICE_OK;
+   low_memory_trap_state = shm_malloc(sizeof(int));
+   *low_memory_trap_state = SERVICE_OK;
+   max_calls_trap_state=shm_malloc(sizeof(int));
+   *max_calls_trap_state= SERVICE_OK;
+   parse_req_trap_state=shm_malloc(sizeof(int));
+   *parse_req_trap_state= SERVICE_OK;
+   parse_resp_trap_state=shm_malloc(sizeof(int));
+   *parse_resp_trap_state= SERVICE_OK;
+   xcoder_ports_trap_state=shm_malloc(sizeof(int));
+   *xcoder_ports_trap_state= SERVICE_OK;
+   create_call_trap_state=shm_malloc(sizeof(int));
+   *create_call_trap_state= SERVICE_OK;
+
+   update_trap_values_lock = lock_alloc();
+   if (lock_init(update_trap_values_lock) == 0)
+   {
+      LM_ERR("could not initialize the update trap values lock\n");
+      lock_dealloc(update_trap_values_lock);
+      return -1;
+   }
+
+   trap_lock = lock_alloc();
+   if (lock_init(trap_lock) == 0)
+   {
+      LM_ERR("could not initialize a trap_lock\n");
+      lock_dealloc(trap_lock);
+      return -1;
+   }
+
+   /* load xcoder_b2b_entities api */
+   if(load_xcoder_api(&b2b_xcoder)< 0) {
+      LM_ERR("can't load b2b_xcoder functions\n");
+      return -1;
+   }
+   // End Jorge
 
 	return 0;
 }
@@ -283,6 +339,88 @@
 	
     freeInterprocessBuffer();
 
+    //Jorge begin
+    if(trap_number!=NULL)
+    {
+       memset(trap_number, 0, sizeof(trap_number));
+       shm_free(trap_number);
+    }
+
+    if(last_unsupported_methods!=NULL)
+    {
+       memset(last_unsupported_methods, 0, sizeof(last_unsupported_methods));
+       shm_free(last_unsupported_methods);
+    }
+
+    if(last_parse_req!=NULL)
+    {
+       memset(last_parse_req, 0, sizeof(last_parse_req));
+       shm_free(last_parse_req);
+    }
+
+    if(last_parse_resp!=NULL)
+    {
+       memset(last_parse_resp, 0, sizeof(last_parse_resp));
+       shm_free(last_parse_resp);
+    }
+
+    if(last_xcoder_ports!=NULL)
+    {
+       memset(last_xcoder_ports, 0, sizeof(last_xcoder_ports));
+       shm_free(last_xcoder_ports);
+    }
+
+    if(last_create_call!=NULL)
+    {
+       memset(last_create_call, 0, sizeof(last_create_call));
+       shm_free(last_create_call);
+    }
+
+    if(unsup_method_trap_state!=NULL)
+    {
+       memset(unsup_method_trap_state, 0, sizeof(unsup_method_trap_state));
+       shm_free(unsup_method_trap_state);
+    }
+
+    if(low_memory_trap_state!=NULL)
+    {
+       memset(low_memory_trap_state, 0, sizeof(low_memory_trap_state));
+       shm_free(low_memory_trap_state);
+    }
+
+
+    if(max_calls_trap_state!=NULL)
+    {
+       memset(max_calls_trap_state, 0, sizeof(max_calls_trap_state));
+       shm_free(max_calls_trap_state);
+    }
+
+    if(parse_req_trap_state!=NULL)
+    {
+       memset(parse_req_trap_state, 0, sizeof(parse_req_trap_state));
+       shm_free(parse_req_trap_state);
+    }
+
+    if(parse_resp_trap_state!=NULL)
+    {
+       memset(parse_resp_trap_state, 0, sizeof(parse_resp_trap_state));
+       shm_free(parse_resp_trap_state);
+    }
+
+    if(xcoder_ports_trap_state!=NULL)
+    {
+       memset(xcoder_ports_trap_state, 0, sizeof(xcoder_ports_trap_state));
+       shm_free(xcoder_ports_trap_state);
+    }
+
+    if(create_call_trap_state!=NULL)
+    {
+       memset(create_call_trap_state, 0, sizeof(create_call_trap_state));
+       shm_free(create_call_trap_state);
+    }
+
+    //Jorge End
+
     LM_INFO("                 Shutting down the AgentX Sub-Agent!\n");
 }
 
diff -Naur opensips-1.8.3-tls/modules/snmpstats/snmpstats_globals.h snmpstats/snmpstats_globals.h
--- opensips-1.8.3-tls/modules/snmpstats/snmpstats_globals.h	2012-03-26 10:05:33.000000000 +0100
+++ snmpstats/snmpstats_globals.h	2013-09-24 11:20:48.255637183 +0100
@@ -147,5 +147,4 @@
 /* Handles setting of the snmp community string. */
 int set_snmp_community( modparam_t type, void *val);
 
-
 #endif
diff -Naur opensips-1.8.3-tls/modules/snmpstats/snmpstats.h snmpstats/snmpstats.h
--- opensips-1.8.3-tls/modules/snmpstats/snmpstats.h	2012-03-26 10:05:33.000000000 +0100
+++ snmpstats/snmpstats.h	2013-09-24 11:20:48.255637183 +0100
@@ -68,6 +68,7 @@
 #include "../../mem/shm_mem.h"
 #include "snmpstats_globals.h"
 #include "sub_agent.h"
+#include "snmp_xcoder_b2b_threshold.h" //Jorge
 
 #define SNMPSTATS_MODULE_NAME "snmpstats"
 #define SYSUPTIME_OID         ".1.3.6.1.2.1.1.3.0"
@@ -114,7 +115,24 @@
 	{ "snmpgetPath",            STR_PARAM|USE_FUNC_PARAM,
 			(void *)set_snmpget_path          },
 	{ "snmpCommunity",          STR_PARAM|USE_FUNC_PARAM,
-			(void *)set_snmp_community        }, 
+			(void *)set_snmp_community        },
+			//Jorge
+   { "memory_major_threshold", INT_PARAM|USE_FUNC_PARAM,
+         (void *)set_memory_major_threshold        },
+   { "unsup_methods_threshold", INT_PARAM|USE_FUNC_PARAM,
+         (void *)set_unsup_methods_threshold        },
+   { "active_transcoder_calls_threshold", INT_PARAM|USE_FUNC_PARAM,
+            (void *)set_active_transcoder_calls_threshold     },
+   { "parse_request_threshold", INT_PARAM|USE_FUNC_PARAM,
+            (void *)set_parse_request_threshold     },
+   { "parse_response_threshold", INT_PARAM|USE_FUNC_PARAM,
+            (void *)set_parse_response_threshold     },
+   { "get_ports_threshold", INT_PARAM|USE_FUNC_PARAM,
+            (void *)set_get_ports_threshold     },
+   { "create_call_threshold", INT_PARAM|USE_FUNC_PARAM,
+            (void *)set_create_call_threshold     },
+   { "alarm_frequency", INT_PARAM|USE_FUNC_PARAM,
+            (void *)set_alarm_freq        },
 	{ 0,0,0 }
 };
 
diff -Naur opensips-1.8.3-tls/modules/snmpstats/snmp_xcoder_b2b_threshold.c snmpstats/snmp_xcoder_b2b_threshold.c
--- opensips-1.8.3-tls/modules/snmpstats/snmp_xcoder_b2b_threshold.c	1970-01-01 01:00:00.000000000 +0100
+++ snmpstats/snmp_xcoder_b2b_threshold.c	2013-09-24 11:20:48.259637070 +0100
@@ -0,0 +1,174 @@
+/*
+ * xcoder_b2b_threshold.c
+ *
+ *  Created on: 17 de Abr de 2013
+ *      Author: x01458
+ */
+
+#include "snmp_xcoder_b2b_threshold.h"
+
+static int memory_major_threshold=-1;                 //Contains the threshold value for free memory
+static int unsup_methods_threshold=-1;                //Contains the threshold value for errors when unsupported methods are received
+static int active_transcoder_calls_threshold=-1;      //Contains the threshold value for active calls in transcoder
+static int parse_request_threshold=-1;                //Contains the threshold value for errors parsing sip requests
+static int parse_response_threshold=-1;               //Contains the threshold value for errors parsing sip replies
+static int get_ports_threshold=-1;                    //Contains the threshold value for errors when alocating ports in xcoder
+static int create_call_threshold=-1;                  //Contains the threshold value for errors in xcoder call_create command
+static int alarm_frequency=300;                       //Contains the alarm frequency (seconds)
+
+/* If a proper integer is passed that is >= -1, then newValue will be set to
+ * val, and 0 returned.  Otherwise -1 is returned.
+ * Function copied from openserObjects.c */
+static int set_if_valid_threshold(modparam_t type, void *val, char *varStr,int *newVal)
+{
+   if (val==0) {
+      LM_ERR("%s called with a null value!\n", varStr);
+      return -1;
+   }
+
+   if (type != INT_PARAM) {
+      LM_ERR("%s called with type %d instead of %d!\n",
+            varStr, type, INT_PARAM);
+      return -1;
+   }
+
+   int new_threshold = (int)(long)(int *)val;
+
+   if (new_threshold < -1) {
+      LM_ERR("%s called with an invalid threshold=%d!\n",
+            varStr, new_threshold);
+      return -1;
+   }
+
+   *newVal = new_threshold;
+
+   return 0;
+}
+
+/*
+ * Handles setting of the memory major threshold
+ */
+int set_memory_major_threshold(modparam_t type, void *val)
+{
+   return set_if_valid_threshold(type, val, "set_memory_major_threshold",&memory_major_threshold);
+}
+
+/*
+ * Returns the value of memory threshold
+ */
+int get_memory_major_threshold(void)
+{
+   return memory_major_threshold;
+}
+
+/*
+ * Sets the alarm frequency
+ */
+int set_alarm_freq(modparam_t type, void *val)
+{
+   return set_if_valid_threshold(type, val, "set_alarm_freq",&alarm_frequency);
+}
+
+/*
+ * Returns the value of alarm frequency
+ */
+int get_alarm_freq(void)
+{
+   return alarm_frequency;
+}
+
+/*
+ * Handles setting of the unsupported memory threshold
+ */
+int set_unsup_methods_threshold(modparam_t type, void *val)
+{
+   return set_if_valid_threshold(type, val, "set_unsup_methods_threshold",&unsup_methods_threshold);
+}
+
+/*
+ * Returns the value of memory threshold
+ */
+int get_unsup_methods_threshold(void)
+{
+   return unsup_methods_threshold;
+}
+
+/*
+ * Handles setting of the active transcoder calls threshold
+ */
+int set_active_transcoder_calls_threshold(modparam_t type, void *val)
+{
+   return set_if_valid_threshold(type, val, "set_active_transcoder_calls_threshold",&active_transcoder_calls_threshold);
+}
+
+/*
+ * Returns the value of active transcoder calls threshold
+ */
+int get_active_transcoder_calls_threshold(void)
+{
+   return active_transcoder_calls_threshold;
+}
+
+/*
+ * Handles setting of the parse request errors threshold
+ */
+int set_parse_request_threshold(modparam_t type, void *val)
+{
+   return set_if_valid_threshold(type, val, "set_parse_request_threshold",&parse_request_threshold);
+}
+
+/*
+ * Returns the value of parse request errors threshold
+ */
+int get_parse_request_threshold(void)
+{
+   return parse_request_threshold;
+}
+
+/*
+ * Handles setting of the parse response errors threshold
+ */
+int set_parse_response_threshold(modparam_t type, void *val)
+{
+   return set_if_valid_threshold(type, val, "set_parse_response_threshold",&parse_response_threshold);
+}
+
+/*
+ * Returns the value of parse response errors threshold
+ */
+int get_parse_response_err_threshold(void)
+{
+   return parse_response_threshold;
+}
+
+/*
+ * Handles setting of the get ports errors threshold
+ */
+int set_get_ports_threshold(modparam_t type, void *val)
+{
+   return set_if_valid_threshold(type, val, "set_get_ports_threshold",&get_ports_threshold);
+}
+
+/*
+ * Returns the value of get ports errors threshold
+ */
+int get_get_ports_threshold(void)
+{
+   return get_ports_threshold;
+}
+
+/*
+ * Handles setting of the call create errors threshold
+ */
+int set_create_call_threshold(modparam_t type, void *val)
+{
+   return set_if_valid_threshold(type, val, "set_create_call_threshold",&create_call_threshold);
+}
+
+/*
+ * Returns the value of call create errors threshold
+ */
+int get_call_create_threshold(void)
+{
+   return create_call_threshold;
+}
diff -Naur opensips-1.8.3-tls/modules/snmpstats/snmp_xcoder_b2b_threshold.h snmpstats/snmp_xcoder_b2b_threshold.h
--- opensips-1.8.3-tls/modules/snmpstats/snmp_xcoder_b2b_threshold.h	1970-01-01 01:00:00.000000000 +0100
+++ snmpstats/snmp_xcoder_b2b_threshold.h	2013-09-24 11:20:48.263637135 +0100
@@ -0,0 +1,108 @@
+/*
+ * xcoder_b2b_threshold.h
+ *
+ *  Created on: 17 de Abr de 2013
+ *      Author: x01458
+ */
+
+#ifndef XCODER_B2B_THRESHOLD_H_
+#define XCODER_B2B_THRESHOLD_H_
+
+#include "../../dprint.h"
+#include "utilities.h"
+#include "alarm_checks.h"
+
+/******************************************************************************
+ *        NAME: set_memory_major_threshold
+ * DESCRIPTION: Handles setting of the memory major threshold
+ *
+ *              modparam_t type : parameter type
+ *              val : value of parameter
+ *****************************************************************************/
+int set_memory_major_threshold(modparam_t type, void *val);
+
+/******************************************************************************
+ *        NAME: get_memory_major_threshold
+ * DESCRIPTION: Returns the value of memory threshold
+ *****************************************************************************/
+int get_memory_major_threshold();
+
+/*
+ * Handles setting of the unsupported memory threshold
+ */
+int set_unsup_methods_threshold(modparam_t type, void *val);
+
+/*
+ * Returns the value of memory threshold
+ */
+int get_unsup_methods_threshold(void);
+
+/*
+ * Handles setting of the active transcoder calls threshold
+ */
+int set_active_transcoder_calls_threshold(modparam_t type, void *val);
+
+/*
+ * Returns the value of active transcoder calls threshold
+ */
+int get_active_transcoder_calls_threshold(void);
+
+
+/*
+ * Handles setting of the parse request errors threshold
+ */
+int set_parse_request_threshold(modparam_t type, void *val);
+
+/*
+ * Returns the value of parse request errors threshold
+ */
+int get_parse_request_threshold(void);
+
+
+/*
+ * Handles setting of the parse response errors threshold
+ */
+int set_parse_response_threshold(modparam_t type, void *val);
+
+/*
+ * Returns the value of parse response errors threshold
+ */
+int get_parse_response_err_threshold(void);
+
+
+/*
+ * Handles setting of the get ports errors threshold
+ */
+int set_get_ports_threshold(modparam_t type, void *val);
+
+/*
+ * Returns the value of get ports errors threshold
+ */
+int get_get_ports_threshold(void);
+
+/*
+ * Handles setting of the call create errors threshold
+ */
+int set_create_call_threshold(modparam_t type, void *val);
+
+/*
+ * Returns the value of call create errors threshold
+ */
+int get_call_create_threshold(void);
+
+/******************************************************************************
+ *        NAME: set_alarm_freq
+ * DESCRIPTION: Handles setting of the alarm frequency
+ *
+ *              modparam_t type : parameter type
+ *              val : value of parameter
+ *****************************************************************************/
+int set_alarm_freq(modparam_t type, void *val);
+
+/******************************************************************************
+ *        NAME: get_alarm_freq
+ * DESCRIPTION: Returns the value of alarm frequency
+ *****************************************************************************/
+int get_alarm_freq();
+
+#endif /* XCODER_B2B_THRESHOLD_H_ */
diff -Naur opensips-1.8.3-tls/modules/snmpstats/snmp_xcoder_b2b_traps.c snmpstats/snmp_xcoder_b2b_traps.c
--- opensips-1.8.3-tls/modules/snmpstats/snmp_xcoder_b2b_traps.c	1970-01-01 01:00:00.000000000 +0100
+++ snmpstats/snmp_xcoder_b2b_traps.c	2013-09-24 11:20:48.267636982 +0100
@@ -0,0 +1,770 @@
+/*
+ * xcoder_b2b_traps.c
+ *
+ *  Created on: 16 de Abr de 2013
+ *      Author: x01458
+ */
+
+#include "snmp_xcoder_b2b_traps.h"
+
+/********************************************************************************
+ *
+ * FUNCTION PROTOTYPES
+ *
+ ********************************************************************************/
+
+/*
+ * Sends off an openserShutdownEvent trap to the master agent
+ */
+int
+GenerateTrap(enum xcoder_b2b_alarm_traps id,int severity)
+{
+   oid objid_snmptrap[] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 }; // snmpTrapOID.0
+   oid ptinTrapOID[] = { 1, 3, 6, 1, 4, 1, 4746, 1010, 2, 12 };  // ptinAlarm
+   oid eventSequenceNumber[] = { 1, 3, 6, 1, 4, 1, 4746, 1010, 1, 1, 1 };
+   oid eventTime[] = { 1, 3, 6, 1, 4, 1, 4746, 1010, 1, 1, 2 };
+   oid eventType[] = { 1, 3, 6, 1, 4, 1, 4746, 1010, 1, 1, 3 };
+   oid probableCause[] = { 1, 3, 6, 1, 4, 1, 4746, 1010, 1, 1, 4 };
+   oid perceivedSeverity[] = { 1, 3, 6, 1, 4, 1, 4746, 1010, 1, 1, 5 };
+   oid managedObjectClass[] = { 1, 3, 6, 1, 4, 1, 4746, 1010, 1, 1, 6 };
+   oid managedObjectInstance[] = { 1, 3, 6, 1, 4, 1, 4746, 1010, 1, 1, 7 };
+   oid additionalText[] = { 1, 3, 6, 1, 4, 1, 4746, 1010, 1, 1, 8 };
+   oid notificationIdentifier[] = { 1, 3, 6, 1, 4, 1, 4746, 1010, 1, 1, 9 };
+   oid specificProblem[] = { 1, 3, 6, 1, 4, 1, 4746, 1010, 1, 1, 10 };
+   oid acknowledge[] = { 1, 3, 6, 1, 4, 1, 4746, 1010, 1, 1, 11 };
+   oid alarmID[] = { 1, 3, 6, 1, 4, 1, 4746, 1010, 1, 1, 12 };
+
+   netsnmp_variable_list  *var_list = NULL;
+   time_t ltime;
+   struct tm *newtime;
+   char nowtime[80];
+   bzero(nowtime,80);
+   int seqnum=0;
+   get_and_increment(trap_number, &seqnum);
+
+   //Values specific to each trap
+   int eventtype=2;
+   int probablecause=0; //list of probable causes http://tools.ietf.org/html/draft-ietf-disman-snmp-alarm-mib-01
+   char objectClassStr[64];
+   char objectInstanceStr[64];
+   char traptext[255];
+   int trap_id=0;
+   char specifictext[500];
+   int alarm_id=0;
+   int ack=0;
+   bzero(objectClassStr,64);
+   bzero(objectInstanceStr,64);
+   bzero(traptext,255);
+   bzero(specifictext,500);
+
+   //- Behavior specific to each trap ---
+   switch(id)
+   {
+      case TRAP_SERVICE_DOWN:          add_xcoder_b2b_ShutdownTrap_info(&eventtype,&probablecause,severity,objectClassStr,objectInstanceStr,traptext,&trap_id,specifictext,&alarm_id,&ack); break;
+      case TRAP_LOW_FREE_MEMORY :      add_xcoder_b2b_LowMemory_info(&eventtype,&probablecause,severity,objectClassStr,objectInstanceStr,traptext,&trap_id,specifictext,&alarm_id,&ack); break;
+      case TRAP_UNSUPPORTED_METHODS :  add_xcoder_b2b_UnsupportedMethods_info(&eventtype,&probablecause,severity,objectClassStr,objectInstanceStr,traptext,&trap_id,specifictext,&alarm_id,&ack); break;
+      case TRAP_MAX_ACTIVE_CALLS :     add_xcoder_b2b_maxCalls_info(&eventtype,&probablecause,severity,objectClassStr,objectInstanceStr,traptext,&trap_id,specifictext,&alarm_id,&ack); break;
+      case TRAP_PARSE_REQUEST :     add_xcoder_b2b_parseRequest_info(&eventtype,&probablecause,severity,objectClassStr,objectInstanceStr,traptext,&trap_id,specifictext,&alarm_id,&ack); break;
+      case TRAP_PARSE_RESPONSE :       add_xcoder_b2b_parseReply_info(&eventtype,&probablecause,severity,objectClassStr,objectInstanceStr,traptext,&trap_id,specifictext,&alarm_id,&ack); break;
+      case TRAP_XCODER_PORTS :         add_xcoder_b2b_getPorts_info(&eventtype,&probablecause,severity,objectClassStr,objectInstanceStr,traptext,&trap_id,specifictext,&alarm_id,&ack); break;
+      case TRAP_XCODER_CREATE_CALL :   add_xcoder_b2b_createCall_info(&eventtype,&probablecause,severity,objectClassStr,objectInstanceStr,traptext,&trap_id,specifictext,&alarm_id,&ack); break;
+      default : LM_NOTICE("Unrecognizable trap id\n");break;
+   }
+
+   //- event Time ----
+   time(&ltime);                  /* Get time as long integer. */
+   newtime = localtime(&ltime);   /* Convert to local time. */
+   sprintf(nowtime,"%2d/%02d/%04d %02d:%02d:%02d",
+      newtime->tm_mday, newtime->tm_mon+1, newtime->tm_year+1900,
+      newtime->tm_hour, newtime->tm_min, newtime->tm_sec);
+
+   // Trap OID
+   snmp_varlist_add_variable(&var_list, objid_snmptrap, OID_LENGTH(objid_snmptrap),
+      ASN_OBJECT_ID, (u_char *) ptinTrapOID, sizeof(ptinTrapOID));
+
+   //.1 - Trap Seq Number - dummy for now - is equal do seqnum - the trap number
+   // This field contains a sequence number of the SNMP Traps
+   snmp_varlist_add_variable(&var_list, eventSequenceNumber, OID_LENGTH(eventSequenceNumber),
+      ASN_INTEGER, (u_char *) &seqnum, sizeof(seqnum));
+
+   //.2 - Trap time
+   // The time the alarm was emitted. The format should be DD/MM/YYYY hh:mm:ss
+   snmp_varlist_add_variable(&var_list, eventTime, OID_LENGTH(eventTime),
+      ASN_OCTET_STR, (u_char *) nowtime, strlen(nowtime));
+
+   //.3 - Trap type - 2=comm, 3=environment, 4=equipment, 5=QoS, 6=processingerr
+   snmp_varlist_add_variable(&var_list, eventType, OID_LENGTH(eventType),
+      ASN_INTEGER, (u_char *) &eventtype, sizeof(eventtype));
+
+   //.4 - Trap probable cause
+   snmp_varlist_add_variable(&var_list, probableCause, OID_LENGTH(probableCause),
+      ASN_INTEGER, (u_char *) &probablecause, sizeof(probablecause));
+
+   //.5 - Trap severity - 0=indeterminate, 1=critical, 2=major, 3=minor, 4=warning, 5=cleared
+   snmp_varlist_add_variable(&var_list, perceivedSeverity, OID_LENGTH(perceivedSeverity),
+      ASN_INTEGER, (u_char *) &severity, sizeof(severity));
+
+   //.6 - Trap manager object class
+   // The class (type) of the entity affected by the problem.
+   snmp_varlist_add_variable(&var_list, managedObjectClass, OID_LENGTH(managedObjectClass),
+      ASN_OCTET_STR, (u_char *) objectClassStr, strlen(objectClassStr));
+
+   //.7 - Trap manager object instance
+   // The entitity affected by the problem.
+   snmp_varlist_add_variable(&var_list, managedObjectInstance, OID_LENGTH(managedObjectInstance),
+      ASN_OCTET_STR, (u_char *) objectInstanceStr, strlen(objectInstanceStr));
+
+   //.8 - Trap additional text
+   // Any other information regarding the trap been sent
+   snmp_varlist_add_variable(&var_list, additionalText, OID_LENGTH(additionalText),
+      ASN_OCTET_STR, (u_char *) traptext, strlen(traptext));
+
+   //.9 - Trap notification ID
+   // This provides an integer value identifier for a trap
+   snmp_varlist_add_variable(&var_list, notificationIdentifier, OID_LENGTH(notificationIdentifier),
+      ASN_INTEGER, (u_char *) &trap_id, sizeof(trap_id));
+
+   //.10 - Trap specific problem
+   // Detailed description of the problem
+   snmp_varlist_add_variable(&var_list, specificProblem, OID_LENGTH(specificProblem),
+      ASN_OCTET_STR, (u_char *) specifictext, strlen(specifictext));
+
+   //.11 - Trap acknowledge
+   snmp_varlist_add_variable(&var_list, acknowledge, OID_LENGTH(acknowledge),
+      ASN_INTEGER, (u_char *) &ack, sizeof(ack));
+
+   //.12 - Trap alarm ID
+   snmp_varlist_add_variable(&var_list, alarmID, OID_LENGTH(alarmID),
+      ASN_INTEGER, (u_char *) &alarm_id, sizeof(alarm_id));
+
+   send_v2trap(var_list);
+   snmp_free_varbind(var_list);
+
+   return SNMP_ERR_NOERROR;
+}
+
+/*
+ * Set specific information regarding ShutdownTrap
+ */
+int
+add_xcoder_b2b_ShutdownTrap_info(int * eventtype,int * probablecause,const int severity,char * objectClassStr,char * objectInstanceStr,char * traptext,int * trap_id,char * specifictext,int * alarm_id,int * ack)
+{
+   LM_NOTICE("Configuring to send ShutdownTrap. Severity %d | trap_id %d \n",severity,TRAP_SERVICE_DOWN);
+   *eventtype=4;
+   *probablecause=47; //x733SoftwareProgramAbnormallyTerminated
+   Xsnprintf(objectClassStr,64,"xcoder_b2b");
+   Xsnprintf(objectInstanceStr,64,"Transcoder");
+   Xsnprintf(traptext,255,"Transcoder offline");
+   *trap_id=TRAP_SERVICE_DOWN;
+   *alarm_id=TRAP_SERVICE_DOWN; //TMP por agora é o id da trap
+   *ack=0; //TMP Por agora é 0
+   switch(severity)
+   {
+      case 1 :
+         Xsnprintf(specifictext,500,"A shutdown signal was captured. Terminating transcoder service now.");
+         break;
+      case 5 :
+         Xsnprintf(specifictext,500,"System is online.");
+         break;
+      default :
+         LM_ERR("Unknouwn severity level for ShutdownTrap. Severity %d\n",severity);
+         Xsnprintf(specifictext,500,"The system might be offline.");
+         break;
+   }
+   return 1;
+}
+
+/*
+ * Set specific information regarding Unsupported Methods trap
+ */
+int
+add_xcoder_b2b_UnsupportedMethods_info(int * eventtype,int * probablecause,const int severity,char * objectClassStr,char * objectInstanceStr,char * traptext,int * trap_id,char * specifictext,int * alarm_id,int * ack)
+{
+   LM_NOTICE("Configuring to send unsupported methods trap. Severity %d | trap_id %d \n",severity,TRAP_UNSUPPORTED_METHODS);
+   *eventtype=6;
+   *probablecause=9; //x733CorruptData
+   Xsnprintf(objectClassStr,64,"xcoder_b2b");
+   Xsnprintf(objectInstanceStr,64,"Transcoder");
+   Xsnprintf(traptext,255,"Unsupported requests");
+   *trap_id=TRAP_UNSUPPORTED_METHODS;
+   *alarm_id=TRAP_UNSUPPORTED_METHODS; //TMP por agora é o id da trap
+   *ack=0; //TMP Por agora é 0
+
+   switch(severity)
+   {
+      case 4 :
+         Xsnprintf(specifictext,500,"Transcoder received unsupported requests and will not process these messages.");
+         *unsup_method_trap_state=SERVICE_NOK;
+         break;
+      case 5 :
+         Xsnprintf(specifictext,500,"No relevant unsupported methods received.");
+         *unsup_method_trap_state=SERVICE_OK;
+         break;
+      default :
+         LM_ERR("Unknown severity level for unsupported methods trap. Severity %d\n",severity);
+         Xsnprintf(specifictext,500,"Transcoder may have received unsupported methods");
+         break;
+   }
+   return 1;
+}
+
+/*
+ * Set specific information regarding low memory trap
+ */
+int
+add_xcoder_b2b_LowMemory_info(int * eventtype,int * probablecause,const int severity,char * objectClassStr,char * objectInstanceStr,char * traptext,int * trap_id,char * specifictext,int * alarm_id,int * ack)
+{
+   LM_NOTICE("Configuring to send low memory trap. Severity %d | trap_id %d \n",severity,TRAP_LOW_FREE_MEMORY);
+   *eventtype=6;
+   *probablecause=32; //x733OutofMemory
+   Xsnprintf(traptext,255,"Low memory");
+   Xsnprintf(objectClassStr,64,"xcoder_b2b");
+   Xsnprintf(objectInstanceStr,64,"Transcoder");
+   *trap_id=TRAP_LOW_FREE_MEMORY;
+   *alarm_id=TRAP_LOW_FREE_MEMORY; //TMP por agora é o id da trap
+   *ack=0; //TMP Por agora é 0
+
+   switch(severity)
+   {
+      case 2 :
+         Xsnprintf(specifictext,500,"Free memory threshold reached, transcoder is running out of memory.");
+         *low_memory_trap_state=SERVICE_NOK;
+         break;
+      case 5 :
+         Xsnprintf(specifictext,500,"Transcoder free memory is OK.");
+         *low_memory_trap_state=SERVICE_OK;
+         break;
+      default :
+         LM_ERR("Unknouwn severity level for LowMemory trap.Severity %d\n",severity);
+         Xsnprintf(specifictext,500,"Transcoder may be running out of free memory.");
+         break;
+   }
+   return 1;
+}
+
+/*
+ * Set specific information regarding maximun transcoder calls
+ */
+int
+add_xcoder_b2b_maxCalls_info(int * eventtype,int * probablecause,const int severity,char * objectClassStr,char * objectInstanceStr,char * traptext,int * trap_id,char * specifictext,int * alarm_id,int * ack)
+{
+   LM_NOTICE("Configuring to send max transcoding calls trap. Severity %d | trap_id %d \n",severity,TRAP_MAX_ACTIVE_CALLS);
+   *probablecause=43; //x733ResourceAtOrNearingCapacity
+   Xsnprintf(traptext,255,"Max transcoder calls");
+   Xsnprintf(objectClassStr,64,"xcoder_b2b");
+   Xsnprintf(objectInstanceStr,64,"Transcoder");
+   *trap_id=TRAP_MAX_ACTIVE_CALLS;
+   *alarm_id=TRAP_MAX_ACTIVE_CALLS; //TMP por agora é o id da trap
+   *ack=0; //TMP Por agora é 0
+
+   switch(severity)
+   {
+      case 1 :
+         Xsnprintf(specifictext,500,"Maximum number of transcoder calls reached.");
+         *max_calls_trap_state=SERVICE_NOK;
+         break;
+      case 5 :
+         Xsnprintf(specifictext,500,"System load is OK.");
+         *max_calls_trap_state=SERVICE_OK;
+         break;
+      default :
+         LM_ERR("Unknouwn severity level for max transcoding calls trap.Severity %d\n",severity);
+         Xsnprintf(specifictext,500,"Maximum number of transcoder calls might be reached.");
+         break;
+   }
+   return 1;
+}
+
+/*
+ * Set specific information regarding parse request errors trap
+ */
+int
+add_xcoder_b2b_parseRequest_info(int * eventtype,int * probablecause,const int severity,char * objectClassStr,char * objectInstanceStr,char * traptext,int * trap_id,char * specifictext,int * alarm_id,int * ack)
+{
+   LM_NOTICE("Configuring to send parse request error trap. Severity %d | trap_id %d \n",severity,TRAP_PARSE_REQUEST);
+   *eventtype=6;
+   *probablecause=46; //x733SoftwareError
+   Xsnprintf(traptext,255,"Parse request error");
+   Xsnprintf(objectClassStr,64,"xcoder_b2b");
+   Xsnprintf(objectInstanceStr,64,"Transcoder");
+   *trap_id=TRAP_PARSE_REQUEST;
+   *alarm_id=TRAP_PARSE_REQUEST; //TMP por agora é o id da trap
+   *ack=0; //TMP Por agora é 0
+
+   switch(severity)
+   {
+      case 2 :
+         Xsnprintf(specifictext,500,"Detected errors to parse sip requests.");
+         *parse_req_trap_state=SERVICE_NOK;
+         break;
+      case 5 :
+         Xsnprintf(specifictext,500,"No problems to parse sip requests.");
+         *parse_req_trap_state=SERVICE_OK;
+         break;
+      default :
+         LM_ERR("Unknouwn severity level for parse request error trap.Severity %d\n",severity);
+         Xsnprintf(specifictext,500,"Transcoder might be with problems to parse requests");
+         break;
+   }
+   return 1;
+}
+
+/*
+ * Set specific information regarding parse reply errors trap
+ */
+int
+add_xcoder_b2b_parseReply_info(int * eventtype,int * probablecause,const int severity,char * objectClassStr,char * objectInstanceStr,char * traptext,int * trap_id,char * specifictext,int * alarm_id,int * ack)
+{
+   LM_NOTICE("Configuring to send parse reply error trap. Severity %d | trap_id %d \n",severity,TRAP_PARSE_RESPONSE);
+   *eventtype=6;
+   *probablecause=46; //x733SoftwareError
+   Xsnprintf(traptext,255,"Parse reply error");
+   Xsnprintf(objectClassStr,64,"xcoder_b2b");
+   Xsnprintf(objectInstanceStr,64,"Transcoder");
+   *trap_id=TRAP_PARSE_RESPONSE;
+   *alarm_id=TRAP_PARSE_RESPONSE; //TMP por agora é o id da trap
+   *ack=0; //TMP Por agora é 0
+
+   switch(severity)
+   {
+      case 2 :
+         Xsnprintf(specifictext,500,"Detected errors to parse sip replies.");
+         *parse_resp_trap_state=SERVICE_NOK;
+         break;
+      case 5 :
+         Xsnprintf(specifictext,500,"No problems to parse sip replies.");
+         *parse_resp_trap_state=SERVICE_OK;
+         break;
+      default :
+         LM_ERR("Unknouwn severity level for parse reply error trap.Severity %d\n",severity);
+         Xsnprintf(specifictext,500,"Transcoder might be with problems to parse replies");
+         break;
+   }
+   return 1;
+}
+
+/*
+ * Set specific information regarding get ports errors trap
+ */
+int
+add_xcoder_b2b_getPorts_info(int * eventtype,int * probablecause,const int severity,char * objectClassStr,char * objectInstanceStr,char * traptext,int * trap_id,char * specifictext,int * alarm_id,int * ack)
+{
+   LM_NOTICE("Configuring to send get ports error trap. Severity %d | trap_id %d \n",severity,TRAP_XCODER_PORTS);
+   *eventtype=2;
+   *probablecause=100; //x733UnderlyingResourcesUnavailable
+   Xsnprintf(traptext,255,"Get ports error");
+   Xsnprintf(objectClassStr,64,"xcoder_b2b");
+   Xsnprintf(objectInstanceStr,64,"Transcoder");
+   *trap_id=TRAP_XCODER_PORTS;
+   *alarm_id=TRAP_XCODER_PORTS; //TMP por agora é o id da trap
+   *ack=0; //TMP Por agora é 0
+
+   switch(severity)
+   {
+      case 2 :
+         Xsnprintf(specifictext,500,"Detected errors retrieving ports from xcoder.");
+         *xcoder_ports_trap_state=SERVICE_NOK;
+         break;
+      case 5 :
+         Xsnprintf(specifictext,500,"No problems retrieving ports from xcoder.");
+         *xcoder_ports_trap_state=SERVICE_OK;
+         break;
+      default :
+         LM_ERR("Unknouwn severity level for get ports error trap.Severity %d\n",severity);
+         Xsnprintf(specifictext,500,"Transcoder might be with problems to retrieve ports from xcoder");
+         break;
+   }
+   return 1;
+}
+
+/*
+ * Set specific information regarding create calls errors trap
+ */
+int
+add_xcoder_b2b_createCall_info(int * eventtype,int * probablecause,const int severity,char * objectClassStr,char * objectInstanceStr,char * traptext,int * trap_id,char * specifictext,int * alarm_id,int * ack)
+{
+   LM_NOTICE("Configuring to send get ports error trap. Severity %d | trap_id %d \n",severity,TRAP_XCODER_CREATE_CALL);
+   *eventtype=2;
+   *probablecause=100; //x733UnderlyingResourcesUnavailable
+   Xsnprintf(traptext,255,"Create call error");
+   Xsnprintf(objectClassStr,64,"xcoder_b2b");
+   Xsnprintf(objectInstanceStr,64,"Transcoder");
+   *trap_id=TRAP_XCODER_CREATE_CALL;
+   *alarm_id=TRAP_XCODER_CREATE_CALL; //TMP por agora é o id da trap
+   *ack=0; //TMP Por agora é 0
+
+   switch(severity)
+   {
+      case 1 :
+         Xsnprintf(specifictext,500,"Detected errors creating calls in surfmotion.");
+         *create_call_trap_state=SERVICE_NOK;
+         break;
+      case 5 :
+         Xsnprintf(specifictext,500,"No problem in creating calls in surfmotion.");
+         *create_call_trap_state=SERVICE_OK;
+         break;
+      default :
+         LM_ERR("Unknouwn severity level for create call error trap.Severity %d\n",severity);
+         Xsnprintf(specifictext,500,"Transcoder might be with problems creating calls in surfmotion.");
+         break;
+   }
+   return 1;
+}
+
+int
+Xsnprintf(char *dst, size_t size, const char *format, ...)
+{
+  char *tmp;
+  int retval;
+  va_list  pArguments;
+
+  if(dst == NULL || size <= 0)
+     return -1;
+
+  tmp = (char *) malloc(size);
+
+  if(tmp == NULL)
+     return -1;
+
+  va_start(pArguments, format);
+  retval = vsnprintf(tmp, size, format, pArguments);
+  va_end(pArguments);
+
+  memcpy(dst, tmp, size);
+  free(tmp);
+
+  return retval;
+}
+
+
+/******************************************************************************
+ *        NAME: get_and_increment
+ * DESCRIPTION: Return a value stored in a count variable and increments it.
+ *             This is a synchronized operation.
+ *
+ *    count :     count variable to be incremented
+ *              value :    value to store the current count number
+ *
+ *****************************************************************************/
+
+int
+get_and_increment(int * count, int * value)
+{
+   lock_get(trap_lock);
+
+   *value = *count;
+   *count = *count + 1;
+   lock_release(trap_lock);
+   if (*count >= (INT_MAX - 2))
+   {
+      *count = 0;
+   }
+   return 1;
+}
+
+
+/******************************************************************************
+ *        NAME: get_last_unsupported_method
+ * DESCRIPTION: Return the last_unsupported_method variable
+ *              This is s synchronized operation
+ *****************************************************************************/
+
+int
+get_last_unsupported_methods(void)
+{
+   lock_get(update_trap_values_lock);
+   int i;
+   i=*last_unsupported_methods;
+   lock_release(update_trap_values_lock);
+   return i;
+}
+
+/******************************************************************************
+ *        NAME: get_last_parse_req
+ * DESCRIPTION: Return the last_parse_req variable
+ *              This is s synchronized operation
+ *****************************************************************************/
+
+int
+get_last_parse_req(void)
+{
+   lock_get(update_trap_values_lock);
+   int i;
+   i=*last_parse_req;
+   lock_release(update_trap_values_lock);
+   return i;
+}
+
+/******************************************************************************
+ *        NAME: get_last_parse_resp
+ * DESCRIPTION: Return the last_parse_resp variable
+ *              This is s synchronized operation
+ *****************************************************************************/
+
+int
+get_last_parse_resp(void)
+{
+   lock_get(update_trap_values_lock);
+   int i;
+   i=*last_parse_resp;
+   lock_release(update_trap_values_lock);
+   return i;
+}
+
+/******************************************************************************
+ *        NAME: get_last_xcoder_ports
+ * DESCRIPTION: Return the last_xcoder_ports variable
+ *              This is s synchronized operation
+ *****************************************************************************/
+
+int
+get_last_xcoder_ports(void)
+{
+   lock_get(update_trap_values_lock);
+   int i;
+   i=*last_xcoder_ports;
+   lock_release(update_trap_values_lock);
+   return i;
+}
+
+/******************************************************************************
+ *        NAME: get_last_create_call
+ * DESCRIPTION: Return the last_create_call variable
+ *              This is s synchronized operation
+ *****************************************************************************/
+
+int
+get_last_create_call(void)
+{
+   lock_get(update_trap_values_lock);
+   int i;
+   i=*last_create_call;
+   lock_release(update_trap_values_lock);
+   return i;
+}
+
+/******************************************************************************
+ *        NAME: update_value
+ * DESCRIPTION: Updates a value regarding a specific trap count variable
+ *              This is a synchronized operation
+ *
+ *  value :    value to assign to the specific trap variable
+ *  trap :     Trap type
+ *****************************************************************************/
+
+int
+update_value(int value,xcoder_b2b_traps trap)
+{
+   lock_get(update_trap_values_lock);
+   switch(trap)
+   {
+      case TRAP_UNSUPPORTED_METHODS : *last_unsupported_methods = value; break;
+      case TRAP_PARSE_REQUEST : *last_parse_req = value; break;
+      case TRAP_PARSE_RESPONSE : *last_parse_resp = value ; break;
+      case TRAP_XCODER_PORTS : *last_xcoder_ports = value ; break;
+      case TRAP_XCODER_CREATE_CALL : *last_create_call = value; break;
+      default : LM_NOTICE("Unrecognizable trap type\n"); break;
+
+   }
+
+   lock_release(update_trap_values_lock);
+   return 1;
+}
+
+/*
+ * Returns the number of free memory if they exceed the threshold, and zero
+ * otherwise.
+ */
+int check_memory_alarm(int threshold_to_compare_to)
+{
+   int free_memmory;
+
+   if (threshold_to_compare_to < 0)
+   {
+      return 0;
+   }
+
+   free_memmory = get_statistic("free_size");
+
+   if (free_memmory < threshold_to_compare_to)
+   {
+      return free_memmory;
+   }
+
+   return 0;
+}
+
+/*
+ * Returns the number of active transcoder calls if they exceed the threshold value, and zero
+ * otherwise.
+ */
+int check_transcoder_calls_alarm(int threshold_to_compare_to)
+{
+   int active_calls;
+
+   if (threshold_to_compare_to < 0)
+   {
+      return 0;
+   }
+
+   active_calls = b2b_xcoder.get_transcoder_calls();
+   LM_INFO("Active_calls = %d\n",active_calls);
+
+   if (active_calls > threshold_to_compare_to)
+   {
+      return active_calls;
+   }
+
+   return 0;
+}
+
+/*
+ * Returns the number of unsupported methods received since last checkup if they exceed the threshold, and zero
+ * otherwise.
+ */
+int check_unsupported_methods_alarm(int threshold_to_compare_to)
+{
+   int last_unsupported_methods;
+   int opensips_unsupported_methods;
+
+   if (threshold_to_compare_to < 0)
+   {
+      return 0;
+   }
+
+   opensips_unsupported_methods=get_statistic("unsupported_methods");
+   last_unsupported_methods=get_last_unsupported_methods();
+
+   if( (opensips_unsupported_methods - last_unsupported_methods) > threshold_to_compare_to)
+   {
+      return (opensips_unsupported_methods - last_unsupported_methods);
+   }
+
+   return 0;
+}
+
+/*
+ * Returns the number of errors that occurred in xcoder_b2b when parsing SIP requests since last checkup. If they exceed the threshold return the number of erros, and zero
+ * otherwise.
+ */
+int check_parse_req_alarm(int threshold_to_compare_to)
+{
+   int last_parse_req_errors;
+   int xcoder_b2b_parse_req_errors;
+
+   if (threshold_to_compare_to < 0)
+   {
+     return 0;
+   }
+
+   xcoder_b2b_parse_req_errors = b2b_xcoder.get_parse_req_err();
+   LM_INFO("xcoder_b2b_parse_req_errors = %d\n",xcoder_b2b_parse_req_errors);
+   last_parse_req_errors = get_last_parse_req();
+
+   if( (xcoder_b2b_parse_req_errors - last_parse_req_errors) > threshold_to_compare_to)
+   {
+      return (xcoder_b2b_parse_req_errors - last_parse_req_errors);
+   }
+   return 0;
+}
+
+/*
+ * Returns the number of errors that occurred in xcoder_b2b when parsing SIP replies since last checkup. If they exceed the threshold return the number of erros, and zero
+ * otherwise.
+ */
+int check_parse_reply_alarm(int threshold_to_compare_to)
+{
+   int last_parse_reply_errors;
+   int xcoder_b2b_parse_reply_errors;
+
+   if (threshold_to_compare_to < 0)
+   {
+     return 0;
+   }
+
+   xcoder_b2b_parse_reply_errors = b2b_xcoder.get_parse_resp_err();
+   LM_INFO("xcoder_b2b_parse_reply_errors = %d\n",xcoder_b2b_parse_reply_errors);
+   last_parse_reply_errors = get_last_parse_resp();
+
+   if( (xcoder_b2b_parse_reply_errors - last_parse_reply_errors) > threshold_to_compare_to)
+   {
+      return (xcoder_b2b_parse_reply_errors - last_parse_reply_errors);
+   }
+   return 0;
+}
+
+/*
+ * Returns the number of errors that occurred in xcoder_b2b when sending command get_ports to xcoder. If they exceed the threshold return the number of erros, and zero
+ * otherwise.
+ */
+int check_xcoder_port_alarm(int threshold_to_compare_to)
+{
+   int last_xcoder_port_errors;
+   int xcoder_b2b_xcoder_port_errors;
+
+   if (threshold_to_compare_to < 0)
+   {
+     return 0;
+   }
+
+   xcoder_b2b_xcoder_port_errors = b2b_xcoder.get_xcoder_ports_err();
+   LM_INFO("xcoder_b2b_xcoder_port_errors = %d\n",xcoder_b2b_xcoder_port_errors);
+   last_xcoder_port_errors = get_last_xcoder_ports();
+
+   if( (xcoder_b2b_xcoder_port_errors - last_xcoder_port_errors) > threshold_to_compare_to)
+   {
+      return (xcoder_b2b_xcoder_port_errors - last_xcoder_port_errors);
+   }
+   return 0;
+}
+
+/*
+ * Returns the number of errors that occurred in xcoder_b2b when sending command call_create to xcoder. If they exceed the threshold return the number of erros, and zero
+ * otherwise.
+ */
+int check_create_call_alarm(int threshold_to_compare_to)
+{
+   int last_create_call_errors;
+   int xcoder_b2b_create_call_errors;
+
+   if (threshold_to_compare_to < 0)
+   {
+     return 0;
+   }
+
+   xcoder_b2b_create_call_errors = b2b_xcoder.get_create_call_err();
+   LM_INFO("xcoder_b2b_create_call_errors = %d\n",xcoder_b2b_create_call_errors);
+   last_create_call_errors = get_last_create_call();
+
+   //This clause is >= to allow trigger if equal to 1, because is a sensitive and important alarm.
+   if( (xcoder_b2b_create_call_errors - last_create_call_errors) >= threshold_to_compare_to)
+   {
+      return (xcoder_b2b_create_call_errors - last_create_call_errors);
+   }
+   return 0;
+}
+
+/*
+ * Returns the number of active calls in transcoder. If they exceed the threshold return the number of calls, and zero
+ * otherwise.
+ */
+int check_max_calls_alarm(int threshold_to_compare_to)
+{
+   int last_active_calls;
+   int xcoder_b2b_active_calls;
+
+   if (threshold_to_compare_to < 0)
+   {
+     return 0;
+   }
+
+   xcoder_b2b_active_calls = b2b_xcoder.get_transcoder_calls();
+   LM_INFO("xcoder_b2b_active_calls = %d\n",xcoder_b2b_active_calls);
+   last_active_calls = get_last_create_call();
+
+   if( (xcoder_b2b_active_calls - last_active_calls) > threshold_to_compare_to)
+   {
+      return (xcoder_b2b_active_calls - last_active_calls);
+   }
+   return 0;
+}
diff -Naur opensips-1.8.3-tls/modules/snmpstats/snmp_xcoder_b2b_traps.h snmpstats/snmp_xcoder_b2b_traps.h
--- opensips-1.8.3-tls/modules/snmpstats/snmp_xcoder_b2b_traps.h	1970-01-01 01:00:00.000000000 +0100
+++ snmpstats/snmp_xcoder_b2b_traps.h	2013-09-24 11:20:48.271637250 +0100
@@ -0,0 +1,235 @@
+/*
+ * xcoder_b2b_traps.h
+ *
+ *  Created on: 16 de Abr de 2013
+ *      Author: x01458
+ */
+
+#ifndef XCODER_B2B_TRAPS_H_
+#define XCODER_B2B_TRAPS_H_
+
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include <time.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include "../../dprint.h"
+#include "../../lock_alloc.h"
+#include "utilities.h"
+#include "../xcoder_b2b/xcoder_b2b_load.h"
+
+/********************************************************************************
+ *
+ * VARIABLE DEFINITION
+ *
+ *********************************************************************************/
+
+/*
+ * Holds a list of traps and the correspondent numerical identifier
+ */
+typedef enum xcoder_b2b_alarm_traps
+{
+   TRAP_SERVICE_DOWN=1,
+   TRAP_LOW_FREE_MEMORY=2,
+   TRAP_UNSUPPORTED_METHODS=3,
+   TRAP_MAX_ACTIVE_CALLS=4,
+   TRAP_PARSE_REQUEST=5,
+   TRAP_PARSE_RESPONSE=6,
+   TRAP_XCODER_PORTS=7,
+   TRAP_XCODER_CREATE_CALL=8,
+   TOTAL_RETURN_VALUES
+}xcoder_b2b_traps;
+
+/*
+ * This structure is used to know the last trap sent. If a trap with severity<5 was sent, the system is NOT.
+ */
+typedef enum xcoder_b2b_traps_state
+{
+   SERVICE_OK=1,     //This means that the service is OK
+   SERVICE_NOK=2,    //This means that the service is Not OK
+}xcoder_b2b_trap_state;
+
+struct xcoder_binds b2b_xcoder;
+
+/*****************************************************************************************************************
+ *
+ * FUNCTION PROTOTYPES
+ *
+ *****************************************************************************************************************/
+
+/******************************************************************************
+ *        NAME: GenerateTrap
+ * DESCRIPTION: Sends off an trap to the master agent.
+ *              Traps are sent according with the format defined in PTIN-NOFIF-MIB
+ *
+ *    xcoder_b2b_alarm_traps : trap type
+ *    severity : severity of the trap
+ *
+ *****************************************************************************/
+int GenerateTrap(enum xcoder_b2b_alarm_traps id,int severity);
+
+
+/****************************************************************************************************************
+ *        NAME: GenerateTrap
+ * DESCRIPTION: Set specific information regarding ShutdownTrap
+ *
+ *    eventtype :          The type of alarm sent
+ *    probablecause :      The probable cause of the problem
+ *    severity :           The severity of the alarm
+ *    objectClassStr :     The class (type) of the entity affected by the problem
+ *    objectInstanceStr :  The entity affected by the problem
+ *    traptext :           Any other information regarding the trap been sent
+ *    trap_id :            This provides an integer value identifier for a notification
+ *    specifictext :       Detailed description of the problem
+ *    alarm_id :           Id of the alarm
+ *    ack :                This field show if the trap have been acknowledge or not
+ *
+ ******************************************************************************************************************/
+int add_xcoder_b2b_ShutdownTrap_info(int * eventtype,int * probablecause,const int severity,char * objectClassStr,char * objectInstanceStr,char * traptext,int * trap_id,char * specifictext,int * alarm_id,int * ack);
+
+/*
+ * Set specific information regarding Unsupported Methods trap. (description of parameters defined in add_xcoder_b2b_ShutdownTrap_info)
+ */
+int add_xcoder_b2b_UnsupportedMethods_info(int * eventtype,int * probablecause,const int severity,char * objectClassStr,char * objectInstanceStr,char * traptext,int * trap_id,char * specifictext,int * alarm_id,int * ack);
+
+/*
+ * Set specific information regarding low memory trap. (description of parameters defined in add_xcoder_b2b_ShutdownTrap_info)
+ */
+int add_xcoder_b2b_LowMemory_info(int * eventtype,int * probablecause,const int severity,char * objectClassStr,char * objectInstanceStr,char * traptext,int * trap_id,char * specifictext,int * alarm_id,int * ack);
+
+/*
+ * Set specific information regarding maximun transcoder calls
+ */
+int add_xcoder_b2b_maxCalls_info(int * eventtype,int * probablecause,const int severity,char * objectClassStr,char * objectInstanceStr,char * traptext,int * trap_id,char * specifictext,int * alarm_id,int * ack);
+
+/*
+ * Set specific information regarding parse request errors trap
+ */
+int add_xcoder_b2b_parseRequest_info(int * eventtype,int * probablecause,const int severity,char * objectClassStr,char * objectInstanceStr,char * traptext,int * trap_id,char * specifictext,int * alarm_id,int * ack);
+
+/*
+ * Set specific information regarding parse reply errors trap
+ */
+int add_xcoder_b2b_parseReply_info(int * eventtype,int * probablecause,const int severity,char * objectClassStr,char * objectInstanceStr,char * traptext,int * trap_id,char * specifictext,int * alarm_id,int * ack);
+
+/*
+ * Set specific information regarding get ports errors trap
+ */
+int add_xcoder_b2b_getPorts_info(int * eventtype,int * probablecause,const int severity,char * objectClassStr,char * objectInstanceStr,char * traptext,int * trap_id,char * specifictext,int * alarm_id,int * ack);
+
+/*
+ * Set specific information regarding create calls errors trap
+ */
+int
+add_xcoder_b2b_createCall_info(int * eventtype,int * probablecause,const int severity,char * objectClassStr,char * objectInstanceStr,char * traptext,int * trap_id,char * specifictext,int * alarm_id,int * ack);
+
+/******************************************************************************
+ *        NAME: check_memory_alarm
+ * DESCRIPTION: Returns the number of free memory if they exceed the threshold,
+ *        and zero otherwise
+ *
+ *        threshold_to_compare_to . threshold to verify if was crossed
+ *****************************************************************************/
+int check_memory_alarm(int threshold_to_compare_to);
+
+
+/*
+ * Returns the number of active transcoder calls if they exceed the threshold value, and zero
+ * otherwise.
+ */
+int check_transcoder_calls_alarm(int threshold_to_compare_to);
+
+/*
+ * Returns the number of unsupported methods received since last checkup if they exceed the threshold, and zero
+ * otherwise.
+ */
+int check_unsupported_methods_alarm(int threshold_to_compare_to);
+
+/*
+ * Returns the number of errors that occurred in xcoder_b2b when parsing SIP requests since last checkup. If they exceed the threshold return the number of erros, and zero
+ * otherwise.
+ */
+int check_parse_req_alarm(int threshold_to_compare_to);
+
+/*
+ * Returns the number of errors that occurred in xcoder_b2b when parsing SIP replies since last checkup. If they exceed the threshold return the number of erros, and zero
+ * otherwise.
+ */
+int check_parse_reply_alarm(int threshold_to_compare_to);
+
+/*
+ * Returns the number of errors that occurred in xcoder_b2b when sending command get_ports to xcoder. If they exceed the threshold return the number of erros, and zero
+ * otherwise.
+ */
+int check_xcoder_port_alarm(int threshold_to_compare_to);
+
+/*
+ * Returns the number of errors that occurred in xcoder_b2b when sending command call_create to xcoder. If they exceed the threshold return the number of erros, and zero
+ * otherwise.
+ */
+int check_create_call_alarm(int threshold_to_compare_to);
+
+/*
+ * Allows use of recursion in a snprintf implementation
+ */
+int Xsnprintf(char *dst, size_t size, const char *format, ...);
+
+/*
+ * Return a value stored in a count variable and increments it.
+ * This is a synchronized operation.
+ */
+int get_and_increment(int * count, int * value);
+
+/*
+ * Updates a value regarding a specific trap count variable
+ * This is a synchronized operation.
+ */
+int update_value(int value,xcoder_b2b_traps trap);
+
+/*
+ * Return the last_unsupported_method variable
+ * This is s synchronized operation
+ */
+int get_last_unsupported_methods(void);
+
+/*
+ * Return the last_parse_req variable. This is s synchronized operation
+ */
+int get_last_parse_req(void);
+
+/*
+ * Return the last_parse_resp variable. This is s synchronized operation
+ */
+int get_last_parse_resp(void);
+
+/*
+ * Return the last_xcoder_ports variable.This is s synchronized operation
+ */
+int get_last_xcoder_ports(void);
+
+/*
+ * Return the last_create_call variable. This is s synchronized operation
+ */
+int get_last_create_call(void);
+
+int * unsup_method_trap_state;      //Holds the last state regarding unsupported methods trap. SERVICE_OK if a trap with severity==5 was sent, and SERVICE_NOK otherwise.
+int * low_memory_trap_state;        //Holds the last state regarding low free memory trap. SERVICE_OK if a trap with severity==5 was sent, and SERVICE_NOK otherwise.
+int * parse_req_trap_state;         //Holds the last state regarding parse requests error trap. SERVICE_OK if a trap with severity==5 was sent, and SERVICE_NOK otherwise.
+int * parse_resp_trap_state;        //Holds the last state regarding parse reply trap. SERVICE_OK if a trap with severity==5 was sent, and SERVICE_NOK otherwise.
+int * xcoder_ports_trap_state;      //Holds the last state regarding get ports calls trap. SERVICE_OK if a trap with severity==5 was sent, and SERVICE_NOK otherwise.
+int * create_call_trap_state;       //Holds the last state regarding create call errors trap. SERVICE_OK if a trap with severity==5 was sent, and SERVICE_NOK otherwise.
+int * max_calls_trap_state;         //Holds the last state regarding max calls trap. SERVICE_OK if a trap with severity==5 was sent, and SERVICE_NOK otherwise.
+
+int * last_unsupported_methods;      // Holds the last number of received unsupported methods by xcoder_b2b that the snmpstats module is aware. At every alarm time slice this number is updated.
+int * last_parse_req;                // Holds the last number of errors ocurred in xcoder_b2b to parse SIP requests that snmpstats module is aware. At every alarm time slice this number is updated.
+int * last_parse_resp;               // Holds the last number of errors ocurred in xcoder_b2b to parse SIP replies that snmpstats module is aware. At every alarm time slice this number is updated.
+int * last_xcoder_ports;             // Holds the last number of errors ocurred in get_ports command in xcoder_b2b that snmpstats module is aware. At every alarm time slice this number is updated.
+int * last_create_call;              // Holds the last number of errors ocurred in call_create command in xcoder_b2b that snmpstats module is aware. At every alarm time slice this number is updated.
+
+int * trap_number;                   // Count the number of traps sent
+gen_lock_t * trap_lock;              // A lock used to increment the trap_number variable
+gen_lock_t * update_trap_values_lock;             // A lock used to update critical parameters in xcoder_b2b_trap
+
+#endif /* XCODER_B2B_TRAPS_H_ */
diff -Naur opensips-1.8.3-tls/modules/snmpstats/sub_agent.c snmpstats/sub_agent.c
--- opensips-1.8.3-tls/modules/snmpstats/sub_agent.c	2012-03-26 10:05:33.000000000 +0100
+++ snmpstats/sub_agent.c	2013-09-24 11:20:48.275637124 +0100
@@ -36,13 +36,20 @@
 
 #include "../../dprint.h"
 
+#include "snmp_xcoder_b2b_traps.h" //JORGE
+
 static int keep_running;
 
 /* The function handles Handles shutting down of the sub_agent process. */
 static void sigterm_handler(int signal) 
 {
 	/* Just exit.  The master agent will clean everything up for us */
-	exit(0);
+   //BEGIN JORGE
+   LM_NOTICE("Send shutdown trap in sigchld_handler\n");
+   agent_check_and_process(0);
+   GenerateTrap(TRAP_SERVICE_DOWN,1);
+   //END JORGE
+   exit(0);
 }
 
 /* This function:
@@ -81,6 +88,16 @@
 	init_openserSIPContactTable();
 	init_openserSIPRegUserLookupTable();
 
+//   Jorge, send initialization traps
+   GenerateTrap(TRAP_SERVICE_DOWN,5);
+   GenerateTrap(TRAP_LOW_FREE_MEMORY,5);
+   GenerateTrap(TRAP_UNSUPPORTED_METHODS,5);
+   GenerateTrap(TRAP_MAX_ACTIVE_CALLS,5);
+   GenerateTrap(TRAP_PARSE_REQUEST,5);
+   GenerateTrap(TRAP_PARSE_RESPONSE,5);
+   GenerateTrap(TRAP_XCODER_PORTS,5);
+   GenerateTrap(TRAP_XCODER_CREATE_CALL,5);
+
 	/* In case we recevie a request to stop (kill -TERM or kill -INT) */
 	keep_running = 1;
 
