diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/b2bl_db.c ./b2b_logic/b2bl_db.c
--- ./trunk/src/opensips_1_7/modules/b2b_logic/b2bl_db.c	2012-10-31 10:33:43.052947337 +0000
+++ ./b2b_logic/b2bl_db.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,647 +0,0 @@
-/*
- * $Id: b2bl_db.c 9327 2012-10-15 13:07:57Z osas $
- *
- * back-to-back logic module
- *
- * Copyright (C) 2011 Free Software Fundation
- *
- * This file is part of opensips, a free SIP server.
- *
- * opensips is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version
- *
- * opensips is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License 
- * along with this program; if not, write to the Free Software 
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * History:
- * --------
- *  2011-04-04  initial version (Anca Vamanu)
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-
-#include "../../db/db.h"
-#include "b2b_logic.h"
-#include "b2bl_db.h"
-
-#define B2BL_FETCH_SIZE  128
-static str str_key_col         = str_init("si_key");
-static str str_scenario_col    = str_init("scenario");
-static str str_sparam0_col     = str_init("sparam0");
-static str str_sparam1_col     = str_init("sparam1");
-static str str_sparam2_col     = str_init("sparam2");
-static str str_sparam3_col     = str_init("sparam3");
-static str str_sparam4_col     = str_init("sparam4");
-static str str_sdp_col         = str_init("sdp");
-static str str_sstate_col      = str_init("sstate");
-static str str_next_sstate_col = str_init("next_sstate");
-static str str_lifetime_col    = str_init("lifetime");
-static str str_e1_type_col     = str_init("e1_type");
-static str str_e1_sid_col      = str_init("e1_sid");
-static str str_e1_to_col       = str_init("e1_to");
-static str str_e1_from_col     = str_init("e1_from");
-static str str_e1_key_col      = str_init("e1_key");
-static str str_e2_type_col     = str_init("e2_type");
-static str str_e2_sid_col      = str_init("e2_sid");
-static str str_e2_to_col       = str_init("e2_to");
-static str str_e2_from_col     = str_init("e2_from");
-static str str_e2_key_col      = str_init("e2_key");
-static str str_e3_type_col     = str_init("e3_type");
-static str str_e3_sid_col      = str_init("e3_sid");
-static str str_e3_to_col       = str_init("e3_to");
-static str str_e3_from_col     = str_init("e3_from");
-static str str_e3_key_col      = str_init("e3_key");
-
-#define DB_COLS_NO  26
-static db_key_t qcols[DB_COLS_NO];
-static db_val_t qvals[DB_COLS_NO];
-static int n_query_update;
-
-/* initialize the column names and vals type -> take care always to keep this order */
-void b2bl_db_init(void)
-{
-	memset(qvals, 0, DB_COLS_NO* sizeof(db_val_t));
-
-	qcols[0]      = &str_key_col;
-	qvals[0].type = DB_STR;
-	qcols[1]      = &str_scenario_col;
-	qvals[1].type = DB_STR;
-	qcols[2]      = &str_sparam0_col;
-	qvals[2].type = DB_STR;
-	qcols[3]      = &str_sparam1_col;
-	qvals[3].type = DB_STR;
-	qcols[4]      = &str_sparam2_col;
-	qvals[4].type = DB_STR;
-	qcols[5]      = &str_sparam3_col;
-	qvals[5].type = DB_STR;
-	qcols[6]      = &str_sparam4_col;
-	qvals[6].type = DB_STR;
-	qcols[7]      = &str_sdp_col;
-	qvals[7].type = DB_STR;
-	n_query_update= 8;
-	qcols[8]      = &str_sstate_col;
-	qvals[8].type = DB_INT;
-	qcols[9]      = &str_next_sstate_col;
-	qvals[9].type = DB_INT;
-	qcols[10]     = &str_lifetime_col;
-	qvals[10].type= DB_INT;
-	qcols[11]     = &str_e1_type_col;
-	qvals[11].type= DB_INT;
-	qcols[12]     = &str_e1_sid_col;
-	qvals[12].type= DB_STR;
-	qcols[13]     = &str_e1_to_col;
-	qvals[13].type= DB_STR;
-	qcols[14]     = &str_e1_from_col;
-	qvals[14].type= DB_STR;
-	qcols[15]     = &str_e1_key_col;
-	qvals[15].type= DB_STR;
-	qcols[16]     = &str_e2_type_col;
-	qvals[16].type= DB_INT;
-	qcols[17]     = &str_e2_sid_col;
-	qvals[17].type= DB_STR;
-	qcols[18]     = &str_e2_to_col;
-	qvals[18].type= DB_STR;
-	qcols[19]     = &str_e2_from_col;
-	qvals[19].type= DB_STR;
-	qcols[20]     = &str_e2_key_col;
-	qvals[20].type= DB_STR;
-	qcols[21]     = &str_e3_type_col;
-	qvals[21].type= DB_INT;
-	qcols[22]     = &str_e3_sid_col;
-	qvals[22].type= DB_STR;
-	qcols[23]     = &str_e3_to_col;
-	qvals[23].type= DB_STR;
-	qcols[24]     = &str_e3_from_col;
-	qvals[24].type= DB_STR;
-	qcols[25]     = &str_e3_key_col;
-	qvals[25].type= DB_STR;
-}
-
-void b2bl_db_delete(b2bl_tuple_t* tuple)
-{
-	if(!tuple || !tuple->key || b2bl_db_mode==NO_DB ||
-		(b2bl_db_mode==WRITE_BACK && tuple->db_flag==INSERTDB_FLAG))
-		return;
-
-	LM_DBG("Delete key = %.*s\n", tuple->key->len, tuple->key->s);
-
-	if(b2bl_dbf.use_table(b2bl_db, &b2bl_dbtable)< 0)
-	{
-		LM_ERR("sql use table failed\n");
-		return;
-	}
-
-	qvals[0].val.str_val = *tuple->key;
-
-	if(b2bl_dbf.delete(b2bl_db, qcols, 0, qvals, 1) < 0)
-	{
-		LM_ERR("Failed to delete from database table [%.*s]\n",
-				tuple->key->len, tuple->key->s);
-	}
-}
-
-void b2b_logic_dump(int no_lock)
-{
-	b2bl_tuple_t* tuple;
-	int i;
-	int n_insert_cols;
-
-	if(b2bl_dbf.use_table(b2bl_db, &b2bl_dbtable)< 0)
-	{
-		LM_ERR("sql use table failed\n");
-		return;
-	}
-
-	for(i = 0; i< b2bl_hsize; i++)
-	{
-		if(!no_lock)
-			lock_get(&b2bl_htable[i].lock);
-		tuple = b2bl_htable[i].first;
-		while(tuple)
-		{
-			/* check the state of the scenario instantiation */
-			if(tuple->db_flag == NO_UPDATEDB_FLAG)
-				goto next;
-
-			if(tuple->key == NULL)
-			{
-				LM_ERR("No key stored\n");
-				goto next;
-			}
-			if(tuple->bridge_entities[0]==NULL || tuple->bridge_entities[1]== NULL)
-			{
-				LM_ERR("Bridge entities is NULL\n");
-				if(tuple->bridge_entities[0]==NULL)
-					LM_DBG("0 NULL\n");
-				else
-					LM_DBG("1 NULL\n");
-				goto next;
-			}
-
-			qvals[0].val.str_val = *tuple->key;
-			if(tuple->db_flag == INSERTDB_FLAG)
-			{
-				if(tuple->scenario)
-					qvals[1].val.str_val = tuple->scenario->id;
-				else{
-					qvals[1].val.str_val.len = 0;
-					qvals[1].val.str_val.s = "";
-				}
-
-				qvals[2].val.str_val = tuple->scenario_params[0];
-				qvals[3].val.str_val = tuple->scenario_params[1];
-				qvals[4].val.str_val = tuple->scenario_params[2];
-				qvals[5].val.str_val = tuple->scenario_params[3];
-				qvals[6].val.str_val = tuple->scenario_params[4];
-				qvals[7].val.str_val = tuple->sdp;
-			}
-
-
-			qvals[8].val.int_val  = tuple->scenario_state;
-			qvals[9].val.int_val  = tuple->next_scenario_state;
-			qvals[10].val.int_val = tuple->lifetime - get_ticks() + (int)time(NULL);
-			qvals[11].val.int_val = tuple->bridge_entities[0]->type;
-			qvals[12].val.str_val = tuple->bridge_entities[0]->scenario_id;
-			qvals[13].val.str_val = tuple->bridge_entities[0]->to_uri;
-			qvals[14].val.str_val = tuple->bridge_entities[0]->from_uri;
-			qvals[15].val.str_val = tuple->bridge_entities[0]->key;
-			qvals[16].val.int_val = tuple->bridge_entities[1]->type;
-			qvals[17].val.str_val = tuple->bridge_entities[1]->scenario_id;
-			qvals[18].val.str_val = tuple->bridge_entities[1]->to_uri;
-			qvals[19].val.str_val = tuple->bridge_entities[1]->from_uri;
-			qvals[20].val.str_val = tuple->bridge_entities[1]->key;
-
-			n_insert_cols = 21;
-
-			if(tuple->bridge_entities[2])
-			{
-				qvals[21].val.int_val = tuple->bridge_entities[2]->type;
-				qvals[22].val.str_val = tuple->bridge_entities[2]->scenario_id;
-				qvals[23].val.str_val = tuple->bridge_entities[2]->to_uri;
-				qvals[24].val.str_val = tuple->bridge_entities[2]->from_uri;
-				qvals[25].val.str_val = tuple->bridge_entities[2]->key;
-			}
-			n_insert_cols = DB_COLS_NO;
-
-			/* insert into database */
-			if(tuple->db_flag == INSERTDB_FLAG)
-			{
-				if(b2bl_dbf.insert(b2bl_db, qcols, qvals, n_insert_cols)< 0)
-				{
-					LM_ERR("Sql insert failed\n");
-					if(!no_lock)
-						lock_release(&b2bl_htable[i].lock);
-					return;
-				}
-			}
-			else
-			{
-				/*do update */
-				if(b2bl_dbf.update(b2bl_db, qcols, 0, qvals, qcols+n_query_update,
-					qvals+n_query_update, 1, DB_COLS_NO - n_query_update)< 0)
-				{
-					LM_ERR("Sql update failed\n");
-					if(!no_lock)
-						lock_release(&b2bl_htable[i].lock);
-					return;
-				}
-			}
-			tuple->db_flag = NO_UPDATEDB_FLAG;
-next:
-			tuple = tuple->next;
-		}
-		if(!no_lock)
-			lock_release(&b2bl_htable[i].lock);
-	}
-}
-
-static int b2bl_add_tuple(b2bl_tuple_t* tuple, str* params[])
-{
-	b2bl_tuple_t* shm_tuple= NULL;
-	unsigned int hash_index, local_index;
-	str* b2bl_key;
-	b2bl_entity_id_t* entity;
-	int i;
-	b2b_notify_t cback;
-	str* client_id = NULL;
-	unsigned int logic_restored = 0;
-
-	LM_DBG("Add tuple key [%.*s]\n", tuple->key->len, tuple->key->s);
-	if(b2bl_parse_key(tuple->key, &hash_index, &local_index)< 0)
-	{
-		LM_ERR("Wrong formatted b2b logic key\n");
-		return -1;
-	}
-	shm_tuple = b2bl_insert_new(NULL, hash_index, tuple->scenario, params,
-			(tuple->sdp.s?&tuple->sdp:NULL), NULL, local_index,
-			&b2bl_key, UPDATEDB_FLAG);
-	if(shm_tuple == NULL)
-	{
-		LM_ERR("Failed to insert new tuple\n");
-		return -1;
-	}
-	shm_tuple->lifetime = tuple->lifetime;
-	lock_release(&b2bl_htable[hash_index].lock);
-	shm_tuple->scenario_state= tuple->scenario_state;
-	shm_tuple->next_scenario_state= tuple->next_scenario_state;
-
-	/* add entities */
-	for(i=0; i< MAX_BRIDGE_ENT; i++)
-	{
-		if(!tuple->bridge_entities[i]->to_uri.len)
-			continue;
-		LM_DBG("Restore logic info for tuple:entity [%.*s][%d]\n",
-				b2bl_key->len, b2bl_key->s, i);
-
-		if(tuple->bridge_entities[i]->type == B2B_SERVER)
-			cback = b2b_server_notify;
-		else
-			cback = b2b_client_notify;
-
-		/* restore to the entities from b2b_entities module
-		 * the parameter and callback function */
-		if(b2b_api.restore_logic_info(tuple->bridge_entities[i]->type,
-			&tuple->bridge_entities[i]->key, cback)< 0)
-			LM_WARN("Failed to restore logic info for tuple:entity [%.*s][%d]\n",
-				b2bl_key->len, b2bl_key->s, i);
-		else
-			logic_restored = 1;
-
-		entity= b2bl_create_new_entity(tuple->bridge_entities[i]->type,
-			&tuple->bridge_entities[i]->key,&tuple->bridge_entities[i]->to_uri,
-			&tuple->bridge_entities[i]->from_uri, 0, &tuple->bridge_entities[i]->scenario_id, 0);
-		if(client_id)
-			pkg_free(client_id);
-		if(entity == NULL)
-		{
-			LM_ERR("Failed to create entity %d\n", i);
-			goto error;
-		}
-		shm_tuple->bridge_entities[i]= entity;
-		/* put the pointer in clients or servers array */
-		// FIXME: check if the restore logic is ok
-		if(tuple->bridge_entities[i]->type == B2B_SERVER)
-		{
-			if (shm_tuple->servers[0])
-				shm_tuple->servers[1] = entity;
-			else
-				shm_tuple->servers[0] = entity;
-		}
-		else
-		{
-			if (shm_tuple->clients[0])
-				shm_tuple->clients[1] = entity;
-			else
-				shm_tuple->clients[0] = entity;
-		}
-	}
-	if(shm_tuple->bridge_entities[1])
-		shm_tuple->bridge_entities[1]->peer = shm_tuple->bridge_entities[0];
-	if(shm_tuple->bridge_entities[0])
-		shm_tuple->bridge_entities[0]->peer = shm_tuple->bridge_entities[1];
-
-	/* Mark tuple without entities as expired */
-	if(logic_restored==0)
-		shm_tuple->lifetime = 1;
-
-	return 0;
-error:
-	shm_free(shm_tuple);
-	return -1;
-}
-
-int b2b_logic_restore(void)
-{
-	int i;
-	int nr_rows;
-	int _time;
-	db_res_t *result= NULL;
-	db_row_t *rows = NULL;
-	db_val_t *row_vals= NULL;
-	b2bl_tuple_t tuple;
-	str b2bl_key;
-	str scenario_id;
-	b2bl_entity_id_t bridge_entities[3];
-	str* params[MAX_SCENARIO_PARAMS];
-
-	if(b2bl_db == NULL)
-	{
-		LM_DBG("NULL database connection\n");
-		return 0;
-	}
-	if(b2bl_dbf.use_table(b2bl_db, &b2bl_dbtable)< 0)
-	{
-		LM_ERR("sql use table failed\n");
-		return -1;
-	}
-
-	if (DB_CAPABILITY(b2bl_dbf, DB_CAP_FETCH))
-	{
-		if(b2bl_dbf.query(b2bl_db, 0, 0, 0, qcols, 0,
-			DB_COLS_NO, 0, 0) < 0)
-		{
-			LM_ERR("Error while querying (fetch) database\n");
-			return -1;
-		}
-		if(b2bl_dbf.fetch_result(b2bl_db,&result,B2BL_FETCH_SIZE)<0)
-		{
-			LM_ERR("fetching rows failed\n");
-			return -1;
-		}
-	}
-	else
-	{
-		if (b2bl_dbf.query(b2bl_db, 0, 0, 0, qcols, 0,
-				DB_COLS_NO, 0, &result) < 0)
-		{
-			LM_ERR("querying presentity\n");
-			return -1;
-		}
-	}
-
-	nr_rows = RES_ROW_N(result);
-
-	do {
-		LM_DBG("loading [%i] records from db\n", nr_rows);
-
-		rows = RES_ROWS(result);
-
-		/* for every row */
-		for(i=0; i<nr_rows; i++)
-		{
-			row_vals = ROW_VALUES(rows +i);
-			memset(&tuple, 0, sizeof(b2bl_tuple_t));
-
-			b2bl_key.s = (char*)row_vals[0].val.string_val;
-			b2bl_key.len = b2bl_key.s?strlen(b2bl_key.s):0;
-
-			tuple.key = &b2bl_key;
-			if(row_vals[1].val.string_val)
-			{
-				scenario_id.s = (char*)row_vals[1].val.string_val;
-				scenario_id.len = strlen(scenario_id.s);
-				tuple.scenario = get_scenario_id(&scenario_id);
-			}
-			memset(bridge_entities, 0, 3*sizeof(b2bl_entity_id_t));
-			memset(params, 0, MAX_SCENARIO_PARAMS* sizeof(str*));
-			if(row_vals[2].val.string_val)
-			{
-				tuple.scenario_params[0].s =(char*)row_vals[2].val.string_val;
-				tuple.scenario_params[0].len = strlen(tuple.scenario_params[0].s);
-				params[0] = &tuple.scenario_params[0];
-			}
-			if(row_vals[3].val.string_val)
-			{
-				tuple.scenario_params[1].s =(char*)row_vals[3].val.string_val;
-				tuple.scenario_params[1].len = strlen(tuple.scenario_params[1].s);
-				params[1] = &tuple.scenario_params[1];
-			}
-			if(row_vals[4].val.string_val)
-			{
-				tuple.scenario_params[2].s =(char*)row_vals[4].val.string_val;
-				tuple.scenario_params[2].len = strlen(tuple.scenario_params[2].s);
-				params[2] = &tuple.scenario_params[2];
-			}
-			if(row_vals[5].val.string_val)
-			{
-				tuple.scenario_params[3].s =(char*)row_vals[5].val.string_val;
-				tuple.scenario_params[3].len = strlen(tuple.scenario_params[3].s);
-				params[3] = &tuple.scenario_params[3];
-			}
-			if(row_vals[6].val.string_val)
-			{
-				tuple.scenario_params[4].s =(char*)row_vals[6].val.string_val;
-				tuple.scenario_params[4].len = strlen(tuple.scenario_params[4].s);
-				params[4] = &tuple.scenario_params[4];
-			}
-			if(row_vals[7].val.string_val)
-			{
-				tuple.sdp.s =(char*)row_vals[7].val.string_val;
-				tuple.sdp.len = strlen(tuple.sdp.s);
-			}
-			tuple.scenario_state     =row_vals[8].val.int_val;
-			tuple.next_scenario_state=row_vals[9].val.int_val;
-			_time = (int)time(NULL);
-			if (row_vals[10].val.int_val <= _time)
-				tuple.lifetime = 1;
-			else
-				tuple.lifetime=row_vals[10].val.int_val - _time + get_ticks();
-
-			bridge_entities[0].type  = row_vals[11].val.int_val;
-			bridge_entities[0].scenario_id.s =(char*)row_vals[12].val.string_val;
-			bridge_entities[0].scenario_id.len=
-				bridge_entities[0].scenario_id.s?strlen(bridge_entities[0].scenario_id.s):0;
-			bridge_entities[0].to_uri.s  =(char*)row_vals[13].val.string_val;
-			bridge_entities[0].to_uri.len=
-				bridge_entities[0].to_uri.s?strlen(bridge_entities[0].to_uri.s):0;
-			bridge_entities[0].from_uri.s=(char*)row_vals[14].val.string_val;
-			bridge_entities[0].from_uri.len=
-				bridge_entities[0].from_uri.s?strlen(bridge_entities[0].from_uri.s):0;
-			bridge_entities[0].key.s  =(char*)row_vals[15].val.string_val;
-			bridge_entities[0].key.len=
-				bridge_entities[0].key.s?strlen(bridge_entities[0].key.s):0;
-
-			bridge_entities[1].type = row_vals[16].val.int_val;
-			bridge_entities[1].scenario_id.s  = (char*)row_vals[17].val.string_val;
-			bridge_entities[1].scenario_id.len=
-				bridge_entities[1].scenario_id.s?strlen(bridge_entities[1].scenario_id.s):0;
-			bridge_entities[1].to_uri.s  = (char*)row_vals[18].val.string_val;
-			bridge_entities[1].to_uri.len=
-				bridge_entities[1].to_uri.s?strlen(bridge_entities[1].to_uri.s):0;
-			bridge_entities[1].from_uri.s  = (char*)row_vals[19].val.string_val;
-			bridge_entities[1].from_uri.len=
-				bridge_entities[1].from_uri.s?strlen(bridge_entities[1].from_uri.s):0;
-			bridge_entities[1].key.s  = (char*)row_vals[20].val.string_val;
-			bridge_entities[1].key.len=
-				bridge_entities[1].key.s?strlen(bridge_entities[1].key.s):0;
-
-			if(row_vals[21].val.string_val)
-			{
-				bridge_entities[2].type = row_vals[21].val.int_val;
-				bridge_entities[2].scenario_id.s  = (char*)row_vals[22].val.string_val;
-				bridge_entities[2].scenario_id.len=
-					bridge_entities[2].scenario_id.s?strlen(bridge_entities[2].scenario_id.s):0;
-				bridge_entities[2].to_uri.s  = (char*)row_vals[23].val.string_val;
-				bridge_entities[2].to_uri.len=
-					bridge_entities[2].to_uri.s?strlen(bridge_entities[2].to_uri.s):0;
-				bridge_entities[2].from_uri.s  = (char*)row_vals[24].val.string_val;
-				bridge_entities[2].from_uri.len=
-					bridge_entities[2].from_uri.s?strlen(bridge_entities[2].from_uri.s):0;
-				bridge_entities[2].key.s  = (char*)row_vals[25].val.string_val;
-				bridge_entities[2].key.len=
-					bridge_entities[2].key.s?strlen(bridge_entities[2].key.s):0;
-			}
-
-			tuple.bridge_entities[0] = &bridge_entities[0];
-			tuple.bridge_entities[1] = &bridge_entities[1];
-			tuple.bridge_entities[2] = &bridge_entities[2];
-
-			if(b2bl_add_tuple(&tuple, params) < 0)
-			{
-				LM_ERR("Failed to add new tuple\n");
-				goto error;
-			}
-		}
-		/* any more data to be fetched ?*/
-		if (DB_CAPABILITY(b2bl_dbf, DB_CAP_FETCH)) {
-			if (b2bl_dbf.fetch_result( b2bl_db, &result,
-				B2BL_FETCH_SIZE ) < 0) 
-			{
-				LM_ERR("fetching more rows failed\n");
-				goto error;
-			}
-			nr_rows = RES_ROW_N(result);
-		} else {
-			nr_rows = 0;
-		}
-	}while (nr_rows>0);
-
-	b2bl_dbf.free_result(b2bl_db, result);
-	LM_DBG("Finished\n");
-
-	return 0;
-error:
-	if(result)
-		b2bl_dbf.free_result(b2bl_db, result);
-	return -1;
-}
-
-void b2bl_db_insert(b2bl_tuple_t* tuple)
-{
-	int ci;
-	int i;
-
-	qvals[0].val.str_val = *tuple->key;
-	if(tuple->scenario)
-		qvals[1].val.str_val = tuple->scenario->id;
-	else{
-		qvals[1].val.str_val.len = 0;
-		qvals[1].val.str_val.s = "";
-	}
-
-	qvals[2].val.str_val = tuple->scenario_params[0];
-	qvals[3].val.str_val = tuple->scenario_params[1];
-	qvals[4].val.str_val = tuple->scenario_params[2];
-	qvals[5].val.str_val = tuple->scenario_params[3];
-	qvals[6].val.str_val = tuple->scenario_params[4];
-	qvals[7].val.str_val = tuple->sdp;
-	qvals[8].val.int_val = tuple->scenario_state;
-	qvals[9].val.int_val = tuple->next_scenario_state;
-	qvals[10].val.int_val= tuple->lifetime - get_ticks() + (int)time(NULL);
-	ci = 11;
-
-	for(i = 0; i< 3; i++)
-	{
-		if(!tuple->bridge_entities[i])
-			break;
-		qvals[ci++].val.int_val = tuple->bridge_entities[i]->type;
-		qvals[ci++].val.str_val = tuple->bridge_entities[i]->scenario_id;
-		qvals[ci++].val.str_val = tuple->bridge_entities[i]->to_uri;
-		qvals[ci++].val.str_val = tuple->bridge_entities[i]->from_uri;
-		qvals[ci++].val.str_val = tuple->bridge_entities[i]->key;
-	}
-
-	if(b2bl_dbf.use_table(b2bl_db, &b2bl_dbtable)< 0)
-	{
-		LM_ERR("sql use table failed\n");
-		return;
-	}
-
-	if(b2bl_dbf.insert(b2bl_db, qcols, qvals, ci)< 0)
-	{
-		LM_ERR("Sql insert failed\n");
-	}
-}
-
-void b2bl_db_update(b2bl_tuple_t* tuple)
-{
-	int ci;
-	int i;
-
-	if(!tuple->key) {
-		LM_ERR("No key found\n");
-		return;
-	}
-	LM_DBG("key= %.*s\n", tuple->key->len, tuple->key->s);
-
-	qvals[0].val.str_val = *tuple->key;
-
-	qvals[8].val.int_val  = tuple->scenario_state;
-	qvals[9].val.int_val  = tuple->next_scenario_state;
-	qvals[10].val.int_val = tuple->lifetime -get_ticks() + (int)time(NULL);
-	ci = 11;
-
-	for(i = 0; i< 3; i++)
-	{
-		if(!tuple->bridge_entities[i])
-			break;
-		qvals[ci++].val.int_val = tuple->bridge_entities[i]->type;
-		qvals[ci++].val.str_val = tuple->bridge_entities[i]->scenario_id;
-		qvals[ci++].val.str_val = tuple->bridge_entities[i]->to_uri;
-		qvals[ci++].val.str_val = tuple->bridge_entities[i]->from_uri;
-		qvals[ci++].val.str_val = tuple->bridge_entities[i]->key;
-		LM_DBG("UPDATE %.*s\n", qvals[ci-1].val.str_val.len, qvals[ci-1].val.str_val.s);
-	}
-
-	if(b2bl_dbf.use_table(b2bl_db, &b2bl_dbtable)< 0)
-	{
-		LM_ERR("sql use table failed\n");
-		return;
-	}
-
-	if(b2bl_dbf.update(b2bl_db, qcols, 0, qvals, qcols+n_query_update,
-		qvals+n_query_update, 1, ci - n_query_update)< 0)
-	{
-		LM_ERR("Sql update failed\n");
-	}
-}
-
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/b2bl_db.h ./b2b_logic/b2bl_db.h
--- ./trunk/src/opensips_1_7/modules/b2b_logic/b2bl_db.h	2012-10-31 10:33:43.060947292 +0000
+++ ./b2b_logic/b2bl_db.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,39 +0,0 @@
-/*
- * $Id: b2bl_db.h 8371 2011-09-13 22:31:47Z osas $
- *
- * back-to-back logic module
- *
- * Copyright (C) 2011 Free Software Fundation
- *
- * This file is part of opensips, a free SIP server.
- *
- * opensips is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version
- *
- * opensips is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License 
- * along with this program; if not, write to the Free Software 
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * History:
- * --------
- *  2011-04-04  initial version (Anca Vamanu)
- */
-
-#ifndef B2BL_DB_H
-#define B2BL_DB_H
-
-#include "records.h"
-
-void b2b_logic_dump(int no_lock);
-int b2b_logic_restore(void);
-void b2bl_db_insert(b2bl_tuple_t* tuple);
-void b2bl_db_update(b2bl_tuple_t* tuple);
-
-#endif
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/b2b_logic.c ./b2b_logic/b2b_logic.c
--- ./trunk/src/opensips_1_7/modules/b2b_logic/b2b_logic.c	2012-10-31 10:33:43.048947363 +0000
+++ ./b2b_logic/b2b_logic.c	2012-10-31 10:33:26.536947345 +0000
@@ -50,6 +50,7 @@
 #include "b2b_load.h"
 #include "b2bl_db.h"
 
+
 #define TABLE_VERSION 2
 
 /** Functions declarations */
@@ -83,6 +84,7 @@
 str custom_headers_lst[HDR_LST_LEN];
 int custom_headers_lst_len =0;
 /* The list of the headers that are passed on the other side by default */
+/* Added new headers by Jorge*/
 static str default_headers[HDR_DEFAULT_LEN]=
 {
    {"Content-Type",12},
@@ -189,7 +191,12 @@
 
 	LM_DBG("start\n");
 
-	/* load b2b_entities api */
+	/* load xcoder_b2b_entities api */ //JORGE
+        if(load_xcoder_api(&b2b_xcoder)< 0) {
+                LM_ERR("can't load b2b_xcoder functions\n");
+                return -1;
+        }
+
 	if(load_b2b_api(&b2b_api)< 0)
 	{
 		LM_ERR("Failed to load b2b api\n");
@@ -1252,6 +1259,9 @@
 	if(tuple)
 		b2b_mark_todel(tuple);
 	lock_release(&b2bl_htable[hash_index].lock);
+
+	
+
 	return 0;
 }
 
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/b2b_logic.h ./b2b_logic/b2b_logic.h
--- ./trunk/src/opensips_1_7/modules/b2b_logic/b2b_logic.h	2012-10-31 10:33:43.056947361 +0000
+++ ./b2b_logic/b2b_logic.h	2012-10-31 10:33:26.540947353 +0000
@@ -32,6 +32,8 @@
 #include <libxml/parser.h>
 #include "../../str.h"
 #include "../b2b_entities/b2b_entities.h"
+#include "../xcoder_b2b/xcoder_b2b_load.h" //JORGE
+
 
 #define B2B_INIT_MAX_PARAMNO     5
 #define B2B_BRIDGING_STATE      -1
@@ -52,6 +54,7 @@
 #define HDR_DEFAULT_LEN   8
 
 extern b2b_api_t b2b_api;
+struct xcoder_binds b2b_xcoder; //JORGE
 
 enum b2bl_caller_type {
 	CALLER_MODULE,
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/doc/b2b_logic_admin.xml ./b2b_logic/doc/b2b_logic_admin.xml
--- ./trunk/src/opensips_1_7/modules/b2b_logic/doc/b2b_logic_admin.xml	2012-10-31 10:33:43.040947273 +0000
+++ ./b2b_logic/doc/b2b_logic_admin.xml	1970-01-01 01:00:00.000000000 +0100
@@ -1,567 +0,0 @@
-<!-- Module User's Guide -->
-
-<chapter>
-	
-	<title>&adminguide;</title>
-	
-	<section>
-	<title>Overview</title>
-	<para>
-		The B2BUA implementation in OpenSIPS is separated in two layers:
-			<itemizedlist>
-			<listitem>
-		a lower one(coded in b2b_entities module)- which implements the basic functions of a UAS and UAC
-			</listitem>
-			<listitem>
-		an upper one - which represents the logic engine of B2BUA, responsible of actually
-			implementing the B2BUA services using the functions offered by the low level.
-			</listitem>
-	</itemizedlist>
-	This module is a B2BUA upper level implementation that can be used with b2b_entities
-	module to have B2BUA that can be configured to provide some PBX services.
-	The B2B services are coded in an XML scenario document. The b2b_logic module
-	examines this document and uses the functions provided by the b2b_entities
-	module to achieve the actions specified in the document and enable the service.
-	</para>
-	<para>
-		A scenario can be instantiated in two ways:
-		<itemizedlist>
-			<listitem>
-				from the script - at the receipt of a initial message
-			</listitem>
-			<listitem>
-				with a extern command (MI) command - the server will connect two 
-				end points in a session(Third Party Call Control).
-			</listitem>
-		</itemizedlist>
-	</para>
-	</section>
-
-	<section>
-	<title>Dependencies</title>
-	<section>
-		<title>&osips; Modules</title>
-			<itemizedlist>
-			<listitem>
-			<para>
-				<emphasis>b2b_entities, a db module</emphasis>
-			</para>
-			</listitem>
-			</itemizedlist>
-	</section>
-	
-	<section>
-		<title>External Libraries or Applications</title>
-		<para>
-		The following libraries or applications must be installed before running
-		&osips; with this module loaded:
-		</para>
-			<itemizedlist>
-			<listitem>
-			<para>
-				<emphasis>libxml2-dev</emphasis>
-			</para>
-			</listitem>
-			</itemizedlist>
-	</section>
-	</section>
-
-	<section>
-		<title>Exported Parameters</title>
-	<section>
-		<title><varname>hash_size</varname> (int)</title>
-		<para>
-			The size of the hash table that stores the scenario instatiation entities.
-		</para>
-		<para>
-		<emphasis>Default value is <quote>9</quote>
-		</emphasis>
-		 (512 records).
-		</para>
-		<example>
-		<title>Set <varname>server_hsize</varname> parameter</title>
-		<programlisting format="linespecific">
-...
-modparam("b2b_logic", "hash_size", 10)
-...
-	</programlisting>
-		</example>
-	</section>
-
-	<section>
-		<title><varname>script_scenario</varname> (str)</title>
-		<para>
-			This parameter should be set with the path of a document
-			that contains a scenario that can be instantiated from the
-			script at the receipt of an initial message.
-		</para>
-		<para>
-		This parameter can be set more than once.
-		</para>
-		<example>
-		<title>Set <varname>script_scenario</varname> parameter</title>
-		<programlisting format="linespecific">
-...
-modparam("b2b_logic", "script_scenario", "/usr/local/opensips/scripts/b2b_prepaid.xml")
-...
-	</programlisting>
-		</example>
-	</section>
-
-	<section>
-		<title><varname>extern_scenario</varname> (str)</title>
-		<para>
-			This parameter should be set with the path of a document
-			that contains a scenario that can be instantiated with an MI command.
-		</para>
-		<para>
-		This parameter can be set more than once.
-		</para>
-		<example>
-		<title>Set <varname>script_scenario</varname> parameter</title>
-		<programlisting format="linespecific">
-...
-modparam("b2b_logic", "extern_scenario", "/usr/local/opensips/scripts/b2b_marketing.xml")
-...
-	</programlisting>
-		</example>
-	</section>
-
-	<section>
-		<title><varname>cleanup_period</varname> (int)</title>
-		<para>
-			The time interval at which to search for an hanged b2b context.
-			A scenario is considered expired if the duration of a session exceeds the
-			lifetime specified in the scenario.
-			At that moment, BYE is sent in all the dialogs from that context and the
-			context is deleted.
-		</para>
-		<para>
-		<emphasis>Default value is <quote>100</quote>.</emphasis>
-		</para>
-		<example>
-		<title>Set <varname>cleanup_period</varname> parameter</title>
-		<programlisting format="linespecific">
-...
-modparam("b2b_logic", "cleanup_period", 60)
-...
-	</programlisting>
-		</example>
-	</section>
-
-	<section>
-		<title><varname>custom_headers</varname> (str)</title>
-		<para>
-		A list of SIP header names delimited by ';' that should be passed
-		from the dialog of one side to the other side. There are a number
-		of headers that are passed by default. They are: 
-		<itemizedlist>
-			<listitem>Max-Forwards (it is decreased by 1)</listitem>
-			<listitem>Content-Type</listitem>
-			<listitem>Supported</listitem>
-			<listitem>Allow</listitem>
-			<listitem>Proxy-Require</listitem>
-			<listitem>Session-Expires</listitem>
-			<listitem>Min-SE</listitem>
-			<listitem>Require</listitem>
-			<listitem>RSeq</listitem>
-		</itemizedlist>
-		If you wish some other headers to be passed also you should define them
-		by setting this parameter.
-		</para>
-		<para>
-		<emphasis>Default value is <quote>NULL</quote>.</emphasis>
-		</para>
-		<example>
-		<title>Set <varname></varname> parameter</title>
-		<programlisting format="linespecific">
-...
-modparam("b2b_logic", "custom_headers", "User-Agent;Date")
-...
-	</programlisting>
-		</example>
-	</section>
-
-	<section>
-		<title><varname>use_init_sdp</varname> (int)</title>
-		<para>
-		This parameter modifies the behaviour of the B2BUA when bridging
-		and a provisional media uri is set. For playing media while the callee
-		answers (that is connecting the caller to a media server), the bridging
-		with the callee must start by sending an Invite to it. The correct way
-		is to send an Invite without a body in this case, but it has been observed
-		that not many gateways support this. So, the solution is to use the sdp
-		received in the first Invite from the caller and put it as the body for this
-		invite. By setting this parameter, this behavior is enabled.
-		You can also set use_init_sdp per scenario and overwrite this global value.
-		</para>
-		<para>
-		<emphasis>Default value is <quote>0</quote>.</emphasis>
-		</para>
-		<example>
-		<title>Set <varname></varname> parameter</title>
-		<programlisting format="linespecific">
-...
-modparam("b2b_logic", "use_init_sdp", 1)
-...
-	</programlisting>
-		</example>
-	</section>
-	<section>
-		<title><varname>db_url</varname> (str)</title>
-		<para>
-			Database URL.
-		</para>
-		<example>
-		<title>Set <varname>db_url</varname> parameter</title>
-		<programlisting format="linespecific">
-...
-modparam("b2b_logic", "db_url", "mysql://opensips:opensipsrw@127.0.0.1/opensips")
-...
-	</programlisting>
-		</example>
-	</section>
-	<section>
-		<title><varname>update_period</varname> (int)</title>
-		<para>
-			The time interval at which to update the info in database.
-		</para>
-		<para>
-		<emphasis>Default value is <quote>100</quote>.</emphasis>
-		</para>
-		<example>
-		<title>Set <varname>update_period</varname> parameter</title>
-		<programlisting format="linespecific">
-...
-modparam("b2b_logic", "update_period", 60)
-...
-	</programlisting>
-		</example>
-	</section>
-	<section>
-		<title><varname>max_duration</varname> (int)</title>
-		<para>
-			The maximum duration of a call.
-		</para>
-		<para>
-		<emphasis>Default value is <quote>12 * 3600 (12 hours)</quote>.</emphasis>
-		</para>
-		<para>If you set it to 0, there will be no limitation.</para>
-		<example>
-		<title>Set <varname>max_duration</varname> parameter</title>
-		<programlisting format="linespecific">
-...
-modparam("b2b_logic", "max_duration", 7200)
-...
-	</programlisting>
-		</example>
-	</section>
-
-	<section>
-		<title><varname>b2bl_key_avp</varname> (string)</title>
-		<para>
-			The name of the Attribute-Value-Pair (AVP) used to store the
-			b2b_logic entity key.  The avp will be set after calling
-			<quote>b2b_init_request</quote>.  The avp will be visible
-			in b2b_entities request/reply routes
-		</para>
-		<note><para>The avp is not visible in local_route.</para></note>
-		<para>
-		<emphasis>Default value is <quote>NULL</quote> (disabled).</emphasis>
-		</para>
-		<example>
-		<title>Set <varname>b2bl_key_avp</varname> parameter</title>
-		<programlisting format="linespecific">
-...
-modparam("b2b_logic", "b2bl_key_avp", "$avp(99)")
-...
-	</programlisting>
-		</example>
-	</section>
-
-	<section>
-		<title><varname>b2bl_from_spec_param</varname> (string)</title>
-		<para>
-			The name of the pseudo variable for storing the new
-			<quote>From</quote> header.
-			The PV must be set before calling <quote>b2b_init_request</quote>.
-		</para>
-		<para>
-		<emphasis>Default value is <quote>NULL</quote> (disabled).</emphasis>
-		</para>
-		<example>
-		<title>Set <varname>b2bl_from_spec_param</varname> parameter</title>
-		<programlisting format="linespecific">
-...
-modparam("b2b_logic", "b2bl_from_spec_param", "$var(b2bl_from)")
-...
-route{
-	...
-	# setting the From header
-	$var(b2bl_from) = "\"Call ID\" &lt;sip:user@opensips.org&gt;";
-	...
-	b2b_init_request("top hiding");
-	...
-}
-	</programlisting>
-		</example>
-	</section>
-
-	<section>
-		<title><varname>server_address</varname> (str)</title>
-		<para>
-			The IP address of the machine that will be used as Contact in
-			the generated messages. This is compulsory only when using external
-			scenarios. For the script scenarios, if it is not set, it is constructed
-			dynamically from the socket where the initiating request was received.
-			This socket will be used to send all the requests, replies for that
-			scenario instantiation.
-		</para>
-		<example>
-		<title>Set <varname>server_address</varname> parameter</title>
-		<programlisting format="linespecific">
-...
-modparam("b2b_logic", "server_address", "sip:sa@10.10.10.10:5060")
-...
-	</programlisting>
-		</example>
-	</section>
-
-	<section>
-		<title><varname>init_callid_hdr</varname> (str)</title>
-		<para>
-			The module offers the possibility to insert the original callid in a header
-			in the generated Invites. If you want this, set this parameter to the name
-			of the header in which to insert the original callid.
-		</para>
-		<example>
-		<title>Set <varname>init_callid_hdr</varname> parameter</title>
-		<programlisting format="linespecific">
-...
-modparam("b2b_logic", "init_callid_hdr", "Init-CallID")
-...
-	</programlisting>
-		</example>
-	</section>
-	<section>
-		<title><varname>db_mode</varname> (int)</title>
-		<para>
-			The B2B modules have support for the 3 type of database storage
-		</para>
-		<para>
-		<itemizedlist>
-				<listitem>NO DB STORAGE - set this parameter to 0</listitem>
-				<listitem>WRITE THROUGH (synchronous write in database) - set this parameter to 1</listitem>
-				<listitem>WRITE BACK (update in db from time to time) - set this parameter to 2</listitem>
-		</itemizedlist>
-		</para>
-		<para>
-		<emphasis>Default value is <quote>2</quote> (WRITE BACK).</emphasis>
-		</para>
-		<example>
-		<title>Set <varname>db_mode</varname> parameter</title>
-		<programlisting format="linespecific">
-...
-modparam("b2b_logic", "db_mode", 1)
-...
-	</programlisting>
-		</example>
-	</section>
-
-	</section>
-
-	<section>
-		<title>Exported Functions</title>
-	<section>
-		<title>
-		<function moreinfo="none">b2b_init_request</function>
-		</title>
-		<para>
-			This is the function that must be called by the script writer
-			on an initial INVITE for which a B2B scenario must be instantiated.
-			It is up to the script writer to decide which are the criteria to decide
-			for which messages certain scenarios must be instantiated.
-		</para>
-		<para>
-			The first parameter is the identifier for the scenario. This is defined
-			in the XML document as an attribute of the root node.
-		</para>
-		<para>
-			Then it can take at most 4 other parameters that represent the parameters for
-			the xml scenario. The expected number of parameters is also specified as an attribute
-			in the root node of the XML scenario.
-		</para>
-	<note><para>
-		Do not call t_newtran() from the script on this request. It will be called internally
-		by the function. Calling t_newtran() from the script will result in the transaction remaining
-		in memory for ever.
-	</para></note>
-		<example>
-			<title><function>b2b_init_request</function> usage</title>
-		<programlisting format="linespecific">
-...
-if(is_method("INVITE") &amp;&amp; !has_totag() &amp;&amp; prepaid_user())
-   b2b_init_request("prepaid", "sip:320@opensips.org:5070",
-      "sip:321@opensips.org:5070"));
-...
-	</programlisting>
-		</example>
-	</section>
-	<section>
-		<title>
-		<function moreinfo="none">b2b_bridge_request(b2bl_key,entity_no)</function>
-		</title>
-		<para>
-			This function will bridge an initial INVITE with one of the
-			particapnts from an existing b2b dialog.
-		</para>
-		<para>Parameters:</para>
-		<itemizedlist>
-			<listitem><para>
-				<emphasis>b2bl_key</emphasis> - a pseudo-variable that
-				contains the b2b_logic key
-			</para></listitem>
-			<listitem><para>
-				<emphasis>entity_no</emphasis> - a pseudo-variable that
-				holds the entity of the particapnt to bridge.
-			</para></listitem>
-		</itemizedlist>
-		<example>
-			<title><function>b2b_bridge_request</function> usage</title>
-		<programlisting format="linespecific">
-...
-modparam("b2b_logic", "b2bl_key_avp", "$avp(99)")
-...
-route(X)
-{
-   # handling b2b calls here
-   ...
-   b2b_init_request("top hiding");
-   xlog("L_INFO","[$mi] got b2bl_key='$avp(99)'\n");
-   # saving the b2b key into the local cache
-   cache_store("local","some_b2bl_key_identifier","$avp(99)");
-   ...
-}
-
-route(Y)
-{
-   # handling calls to bridge to existing b2b calls
-   ...
-   # retrieving the key of a b2b call
-   cache_fetch("local","some_b2bl_key_identifier", $avp(98) );
-   $var(entity) = 1;
-   b2b_bridge_request("$avp(98)","$var(entity)");
-   ...
-}
-...
-		</programlisting>
-		</example>
-	</section>
-
-</section>
-
-<section>
-	<title>Exported MI Functions</title>
-	<section>
-		<title>
-		<function moreinfo="none">b2b_trigger_scenario</function>
-		</title>
-		<para>
-		This command instantiated a B2B scenario.
-		</para>
-		<para>
-		Name: <emphasis>b2b_trigger_scenario</emphasis>
-		</para>
-		<para>Parameters:</para>
-		<itemizedlist>
-			<listitem>
-				<para>senario_id : the id of the scenario to be instantiated.
-				</para>
-			</listitem>
-			<listitem>
-				<para>scenario parameters - it can take 4 more parameters that are scenario parameters</para>
-			</listitem>
-		</itemizedlist>
-		<para>
-		MI FIFO Command Format:
-		</para>
-	<programlisting  format="linespecific">
-	:b2b_trigger_scenario:fifo_reply
-	marketing
-	sip:bob@opensips.org
-	sip:322@opensips.org:5070
-	sip:alice@opensips.org
-	_empty_line_
-		</programlisting>
-	</section>
-
-	<section>
-		<title>
-		<function moreinfo="none">b2b_bridge</function>
-		</title>
-		<para>
-			This command can be used by an external application to tell B2BUA to bridge a
-			call party from an on going dialog to another destination. By default the caller
-			is bridged to the new uri and BYE is set to the callee. You can instead bridge
-			the callee if you send 1 as the third parameter.
-		</para>
-		<para>
-		Name: <emphasis>b2b_bridge</emphasis>
-		</para>
-		<para>Parameters:</para>
-		<itemizedlist>
-			<listitem>
-				<para>dialog-id : the id of the dialog. If you set the module parameter dialog-id
-				the server will include the dialogid in the generated Invites as the content of a
-				header with name 'Dialog-ID'.
-				</para>
-			</listitem>
-			<listitem>
-				<para>new uri - the uri of the new destination</para>
-			</listitem>
-			<listitem>
-				<para>flag to specify that the callee must be bridged to the new destination.
-					It is optional. If not present the caller will be bridged.</para>
-			</listitem>
-		</itemizedlist>
-		<para>MI FIFO Command Format:</para>
-	<programlisting  format="linespecific">
-	:b2b_bridge:fifo_reply
-	1020.30
-	sip:alice@opensips.org
-	_empty_line_
-	</programlisting>
-		<para>opensipsctl Command Format:</para>
-	<programlisting  format="linespecific">
-	opensipsctl b2b_bridge 1020.30 sip:alice@opensips.org
-	</programlisting>
-	</section>
-
-	<section>
-		<title>
-		<function moreinfo="none">b2b_list</function>
-		</title>
-		<para>
-			This command can be used to list the internals of b2b_logic entities.
-		</para>
-		<para>
-		Name: <emphasis>b2b_list</emphasis>
-		</para>
-		<para>Parameters: <emphasis>none</emphasis></para>
-		<itemizedlist>
-		</itemizedlist>
-		<para>MI FIFO Command Format:</para>
-	<programlisting  format="linespecific">
-	:b2b_list:_reply_fifo_file_
-	_empty_line_
-	</programlisting>
-		<para>opensipsctl Command Format:</para>
-	<programlisting  format="linespecific">
-	opensipsctl fifo b2b_list
-	</programlisting>
-	</section>
-
-</section>
-
-</chapter>
-
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/doc/b2b_logic_devel.xml ./b2b_logic/doc/b2b_logic_devel.xml
--- ./trunk/src/opensips_1_7/modules/b2b_logic/doc/b2b_logic_devel.xml	2012-10-31 10:33:43.036947224 +0000
+++ ./b2b_logic/doc/b2b_logic_devel.xml	1970-01-01 01:00:00.000000000 +0100
@@ -1,252 +0,0 @@
-<!-- Module Developer's Guide -->
-
-<chapter>
-    <title>&develguide;</title>
-	<para>
-   The module provides an API that can be used from other &osips;
-   modules. The API offers the functions for instantiating b2b
-   scenarios from other modules (this comes as an addition to the
-   other two means of instantiating b2b scenarios - from script
-   and with an MI command). Also the instantiations can be
-   dynamically controlled, by commanding the bridging of an entity
-   involved in a call to another entity or the termination of the
-   call or even bridging two existing calls.
-   </para>
- 		<section>
-				<title>
-				<function moreinfo="none">b2b_logic_bind(b2bl_api_t* api)</function>
-				</title>
-			<para>
-   This function binds the b2b_entities modules and fills the
-   structure the exported functions that will be described in
-   detail.
-			</para>
-		<example>
-		<title><function>b2bl_api_t</function> structure</title>
-	<programlisting format="linespecific">
-...
-typedef struct b2bl_api
-{
-	b2bl_init_f init;
-	b2bl_bridge_f bridge;
-	b2bl_bridge_extern_f bridge_extern;
-	b2bl_bridge_2calls_t bridge_2calls;
-	b2bl_terminate_call_t terminate_call;
-	b2bl_set_state_f set_state;
-	b2bl_bridge_msg_t bridge_msg;
-}b2bl_api_t;
-...
-</programlisting>
-		</example>
-
-		</section>
-	
-	<section>
-		<title>
-		<function moreinfo="none">init</function>
-		</title>
-		<para>
-			Field type:
-		</para>
-			<programlisting format="linespecific">
-...
-typedef str* (*b2bl_init_f)(struct sip_msg* msg, str* name, str* args[5],
-		b2bl_cback_f, void* param);
-...
-</programlisting>
-	<para>
-   Initializing a b2b scenario. The last two parameters are the
-   callback function and the parameter to be called in 3
-   situations that will be listed below. The callback function has
-   the following definition:
-	</para>
-	<programlisting format="linespecific">
-...
-typedef int (*b2b_notify_t)(struct sip_msg* msg, str* id, int type, void* param);
-...
-</programlisting>
-	<para>
-   The first argument is the callback given in the init function.
-	</para>
-	<para>
-   The second argument is a structure with some statistics about
-   the call -start time, setup time, call time.
-	</para>
-	<para>
-   The third argument is the current state of the scenario
-   instantiation.
-	</para>
-	<para>
-   The last argument is the event that triggered the callback.
-   There are 3 events when the callback is called:
-   </para>
-   <itemizedlist>
-	<listitem>
-		<para>
-			<emphasis>when a BYE is received from either side- event parameter
-	will also show from which side the BYE is received, so it
-	can be B2B_BYE_E1 or B2B_BYE_E2</emphasis>
-		</para>
-	</listitem>
-	<listitem>
-     <para>
-		<emphasis>If while bridging, a negative reply is received from the
-     second entity - the event is B2B_REJECT_E2.</emphasis>
-		</para>
-	</listitem>
-	<listitem>
-     <para>
-		<emphasis>When the b2b logic entity is deleted- the evnet is
-     B2B_DESTROY</emphasis>
-		</para>
-	</listitem>
-	</itemizedlist>
-	<para>
-	The return code controls what will happen with the
-   request/reply that caused the event (except for the last event,
-   when the return code does not matter)
-   </para>
-	<itemizedlist>
-	<listitem>
-		<para>
-			<emphasis>-1 - error</emphasis>
-		</para>
-	</listitem>
-	<listitem>
-		<para>
-		<emphasis>0 - drop the BYE or reply</emphasis>
-		</para>
-	</listitem>
-	<listitem>
-		<para>
-			<emphasis>   1 - send the BYE or reply on the other side</emphasis>
-		</para>
-	</listitem>
-	<listitem>
-		<para>
-			<emphasis>2 - do what the scenario tells, if no rule defined send the
-       BYE or reply on the other side</emphasis>
-		</para>
-	</listitem>
-</itemizedlist>
-</section>
-
-<section>
-		<title>
-		<function moreinfo="none">bridge</function>
-		</title>
-		<para>
-			Field type:
-		</para>
-			<programlisting format="linespecific">
-...
-typedef int (*b2bl_bridge_f)(str* key, str* new_uri, str* new_from_dname,int entity_type);
-...
-</programlisting>
-		<para>
-   This function allows bridging an entity that is in a call
-   handled by b2b_logic to another entity.
-		</para>
-</section>
-
-<section>
-		<title>
-		<function moreinfo="none">bridge_extern</function>
-		</title>
-		<para>
-			Field type:
-		</para>
-			<programlisting format="linespecific">
-...
-typedef str* (*b2bl_bridge_extern_f)(str* scenario_name, str* args[5],
-                b2bl_cback_f cbf, void* cb_param);
-...
-</programlisting>
-		<para>
-   This function allows initiating an extern scenario, when the
-   B2BUA starts a call from the middle.
-		</para>
-</section>
-
-<section>
-		<title>
-		<function moreinfo="none">bridge_2calls</function>
-		</title>
-		<para>
-			Field type:
-		</para>
-			<programlisting format="linespecific">
-...
-typedef int (*b2bl_bridge_2calls_t)(str* key1, str* key2);
-...
-</programlisting>
-	<para>
-   With this function it is possible to bridge two existing calls.
-   The first entity from the two calls will be connected and BYE
-   will be sent to their peers.
-	</para>
-</section>
-
-<section>
-		<title>
-		<function moreinfo="none">terminate_call</function>
-		</title>
-		<para>
-			Field type:
-		</para>
-			<programlisting format="linespecific">
-...
-typedef int (*b2bl_terminate_call_t)(str* key);
-...
-</programlisting>
-	<para>
-	Terminate a call.
-	</para>
-</section>
-
-<section>
-		<title>
-		<function moreinfo="none">set_state</function>
-		</title>
-		<para>
-			Field type:
-		</para>
-			<programlisting format="linespecific">
-...
-typedef int (*b2bl_set_state_f)(str* key, int state);
-...
-</programlisting>
-	<para>
-   Set the scenario state.
-	</para>
-</section>
-
-<section>
-		<title>
-		<function moreinfo="none">bridge_msg</function>
-		</title>
-		<para>
-			Field type:
-		</para>
-			<programlisting format="linespecific">
-...
-typedef int (*b2bl_bridge_msg_t)(struct sip_msg* msg, str* key, int entity_no);
-...
-</programlisting>
-	<para>
-   This function allows bridging an incoming call to an entity from an
-   existing call.
-	</para>
-	<para>
-   The first argument is the INVITE message of the current incoming call.
-	</para>
-	<para>
-   The second argument is the b2bl_key of an existing call.
-	</para>
-	<para>
-   The third argument is the entity identifier.
-	</para>
-</section>
-
-</chapter>
-
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/doc/b2b_logic.xml ./b2b_logic/doc/b2b_logic.xml
--- ./trunk/src/opensips_1_7/modules/b2b_logic/doc/b2b_logic.xml	2012-10-31 10:33:43.040947273 +0000
+++ ./b2b_logic/doc/b2b_logic.xml	1970-01-01 01:00:00.000000000 +0100
@@ -1,75 +0,0 @@
-<?xml version="1.0" encoding='ISO-8859-1'?>
-<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
-"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
-
-
-<!ENTITY admin SYSTEM "b2b_logic_admin.xml">
-<!ENTITY devel SYSTEM "b2b_logic_devel.xml">
-<!ENTITY faq SYSTEM "../../../doc/module_faq.xml">
-
-<!-- Include general documentation entities -->
-<!ENTITY % docentities SYSTEM "../../../doc/entities.xml">
-%docentities;
-
-]>
-
-<book>
-    <bookinfo>
-	<title>B2B_LOGIC</title>
-	<productname class="trade">&osipsname;</productname>
-	<authorgroup>
-	    <author>
-		<firstname>Anca-Maria</firstname>
-		<surname>Vamanu</surname>
-		<affiliation><orgname>&osips;</orgname></affiliation>
-		<address>
-		<email>anca@opensips.org</email>
-		<otheraddr>
-		<ulink url="http://www.opensips.org">http://opensips.org</ulink>
-		</otheraddr>
-		</address>
-	    </author>
-	    <editor>
-		<firstname>Anca-Maria</firstname>
-		<surname>Vamanu</surname>
-		<address>
-		    <email>anca@opensips.org</email>
-		</address>
-	    </editor>
-	    <editor>
-		<firstname>Ovidiu</firstname>
-		<surname>Sas</surname>
-		<address>
-		    <email>osas@voipembedded.com</email>
-		</address>
-	    </editor>
-	  	</authorgroup>
-	<copyright>
-		<year>2009</year>
-		<holder>
-		<firstname>Anca-Maria</firstname>
-		<surname>Vamanu</surname>
-		</holder>
-	</copyright>
-	<copyright>
-		<year>2010</year>
-		<holder>
-		<ulink url="http://www.voipembedded.com">VoIP Embedded, Inc.</ulink>
-		</holder>
-	</copyright>
-	<revhistory>
-	    <revision>
-		<revnumber>$Revision: 8137 $</revnumber>
-		<date>$Date: 2011-07-07 13:02:20 +0100 (Thu, 07 Jul 2011) $</date>
-	    </revision>
-	</revhistory>
-  </bookinfo>
-    <toc></toc>
-    
-	&admin;
-	&devel;
-    &faq;
-    
-</book>
-
-
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/doc/.svn/all-wcprops ./b2b_logic/doc/.svn/all-wcprops
--- ./trunk/src/opensips_1_7/modules/b2b_logic/doc/.svn/all-wcprops	2012-10-31 10:33:43.036947224 +0000
+++ ./b2b_logic/doc/.svn/all-wcprops	1970-01-01 01:00:00.000000000 +0100
@@ -1,23 +0,0 @@
-K 25
-svn:wc:ra_dav:version-url
-V 66
-/svnroot/opensips/!svn/ver/8164/branches/1.7/modules/b2b_logic/doc
-END
-b2b_logic_devel.xml
-K 25
-svn:wc:ra_dav:version-url
-V 86
-/svnroot/opensips/!svn/ver/8164/branches/1.7/modules/b2b_logic/doc/b2b_logic_devel.xml
-END
-b2b_logic.xml
-K 25
-svn:wc:ra_dav:version-url
-V 80
-/svnroot/opensips/!svn/ver/8164/branches/1.7/modules/b2b_logic/doc/b2b_logic.xml
-END
-b2b_logic_admin.xml
-K 25
-svn:wc:ra_dav:version-url
-V 86
-/svnroot/opensips/!svn/ver/8164/branches/1.7/modules/b2b_logic/doc/b2b_logic_admin.xml
-END
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/doc/.svn/entries ./b2b_logic/doc/.svn/entries
--- ./trunk/src/opensips_1_7/modules/b2b_logic/doc/.svn/entries	2012-10-31 10:33:43.032947363 +0000
+++ ./b2b_logic/doc/.svn/entries	1970-01-01 01:00:00.000000000 +0100
@@ -1,130 +0,0 @@
-10
-
-dir
-9400
-https://opensips.svn.sourceforge.net/svnroot/opensips/branches/1.7/modules/b2b_logic/doc
-https://opensips.svn.sourceforge.net/svnroot/opensips
-
-
-
-2011-07-07T12:02:20.162258Z
-8137
-osas
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-689a6050-402a-0410-94f2-e92a70836424
-
-b2b_logic_devel.xml
-file
-
-
-
-
-2012-10-30T18:03:15.000000Z
-5f780bb347873def1f9013f6efa09a4a
-2011-07-07T12:02:20.162258Z
-8137
-osas
-has-props
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-6112
-
-b2b_logic.xml
-file
-
-
-
-
-2012-10-30T18:03:15.000000Z
-40ba01a65c1ef245637d51a4aa1e53d1
-2011-07-07T12:02:20.162258Z
-8137
-osas
-has-props
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-1711
-
-b2b_logic_admin.xml
-file
-
-
-
-
-2012-10-30T18:03:15.000000Z
-ad6de7cb8f02f0d98a33b6010a15a429
-2011-07-07T12:02:20.162258Z
-8137
-osas
-has-props
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-16459
-
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/doc/.svn/prop-base/b2b_logic_admin.xml.svn-base ./b2b_logic/doc/.svn/prop-base/b2b_logic_admin.xml.svn-base
--- ./trunk/src/opensips_1_7/modules/b2b_logic/doc/.svn/prop-base/b2b_logic_admin.xml.svn-base	2012-10-31 10:33:43.024947064 +0000
+++ ./b2b_logic/doc/.svn/prop-base/b2b_logic_admin.xml.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-K 12
-svn:keywords
-V 16
-Id Revision Date
-END
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/doc/.svn/prop-base/b2b_logic_devel.xml.svn-base ./b2b_logic/doc/.svn/prop-base/b2b_logic_devel.xml.svn-base
--- ./trunk/src/opensips_1_7/modules/b2b_logic/doc/.svn/prop-base/b2b_logic_devel.xml.svn-base	2012-10-31 10:33:43.020947311 +0000
+++ ./b2b_logic/doc/.svn/prop-base/b2b_logic_devel.xml.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-K 12
-svn:keywords
-V 16
-Id Revision Date
-END
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/doc/.svn/prop-base/b2b_logic.xml.svn-base ./b2b_logic/doc/.svn/prop-base/b2b_logic.xml.svn-base
--- ./trunk/src/opensips_1_7/modules/b2b_logic/doc/.svn/prop-base/b2b_logic.xml.svn-base	2012-10-31 10:33:43.024947064 +0000
+++ ./b2b_logic/doc/.svn/prop-base/b2b_logic.xml.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-K 12
-svn:keywords
-V 16
-Id Revision Date
-END
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/doc/.svn/text-base/b2b_logic_admin.xml.svn-base ./b2b_logic/doc/.svn/text-base/b2b_logic_admin.xml.svn-base
--- ./trunk/src/opensips_1_7/modules/b2b_logic/doc/.svn/text-base/b2b_logic_admin.xml.svn-base	2012-10-31 10:33:43.020947311 +0000
+++ ./b2b_logic/doc/.svn/text-base/b2b_logic_admin.xml.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,567 +0,0 @@
-<!-- Module User's Guide -->
-
-<chapter>
-	
-	<title>&adminguide;</title>
-	
-	<section>
-	<title>Overview</title>
-	<para>
-		The B2BUA implementation in OpenSIPS is separated in two layers:
-			<itemizedlist>
-			<listitem>
-		a lower one(coded in b2b_entities module)- which implements the basic functions of a UAS and UAC
-			</listitem>
-			<listitem>
-		an upper one - which represents the logic engine of B2BUA, responsible of actually
-			implementing the B2BUA services using the functions offered by the low level.
-			</listitem>
-	</itemizedlist>
-	This module is a B2BUA upper level implementation that can be used with b2b_entities
-	module to have B2BUA that can be configured to provide some PBX services.
-	The B2B services are coded in an XML scenario document. The b2b_logic module
-	examines this document and uses the functions provided by the b2b_entities
-	module to achieve the actions specified in the document and enable the service.
-	</para>
-	<para>
-		A scenario can be instantiated in two ways:
-		<itemizedlist>
-			<listitem>
-				from the script - at the receipt of a initial message
-			</listitem>
-			<listitem>
-				with a extern command (MI) command - the server will connect two 
-				end points in a session(Third Party Call Control).
-			</listitem>
-		</itemizedlist>
-	</para>
-	</section>
-
-	<section>
-	<title>Dependencies</title>
-	<section>
-		<title>&osips; Modules</title>
-			<itemizedlist>
-			<listitem>
-			<para>
-				<emphasis>b2b_entities, a db module</emphasis>
-			</para>
-			</listitem>
-			</itemizedlist>
-	</section>
-	
-	<section>
-		<title>External Libraries or Applications</title>
-		<para>
-		The following libraries or applications must be installed before running
-		&osips; with this module loaded:
-		</para>
-			<itemizedlist>
-			<listitem>
-			<para>
-				<emphasis>libxml2-dev</emphasis>
-			</para>
-			</listitem>
-			</itemizedlist>
-	</section>
-	</section>
-
-	<section>
-		<title>Exported Parameters</title>
-	<section>
-		<title><varname>hash_size</varname> (int)</title>
-		<para>
-			The size of the hash table that stores the scenario instatiation entities.
-		</para>
-		<para>
-		<emphasis>Default value is <quote>9</quote>
-		</emphasis>
-		 (512 records).
-		</para>
-		<example>
-		<title>Set <varname>server_hsize</varname> parameter</title>
-		<programlisting format="linespecific">
-...
-modparam("b2b_logic", "hash_size", 10)
-...
-	</programlisting>
-		</example>
-	</section>
-
-	<section>
-		<title><varname>script_scenario</varname> (str)</title>
-		<para>
-			This parameter should be set with the path of a document
-			that contains a scenario that can be instantiated from the
-			script at the receipt of an initial message.
-		</para>
-		<para>
-		This parameter can be set more than once.
-		</para>
-		<example>
-		<title>Set <varname>script_scenario</varname> parameter</title>
-		<programlisting format="linespecific">
-...
-modparam("b2b_logic", "script_scenario", "/usr/local/opensips/scripts/b2b_prepaid.xml")
-...
-	</programlisting>
-		</example>
-	</section>
-
-	<section>
-		<title><varname>extern_scenario</varname> (str)</title>
-		<para>
-			This parameter should be set with the path of a document
-			that contains a scenario that can be instantiated with an MI command.
-		</para>
-		<para>
-		This parameter can be set more than once.
-		</para>
-		<example>
-		<title>Set <varname>script_scenario</varname> parameter</title>
-		<programlisting format="linespecific">
-...
-modparam("b2b_logic", "extern_scenario", "/usr/local/opensips/scripts/b2b_marketing.xml")
-...
-	</programlisting>
-		</example>
-	</section>
-
-	<section>
-		<title><varname>cleanup_period</varname> (int)</title>
-		<para>
-			The time interval at which to search for an hanged b2b context.
-			A scenario is considered expired if the duration of a session exceeds the
-			lifetime specified in the scenario.
-			At that moment, BYE is sent in all the dialogs from that context and the
-			context is deleted.
-		</para>
-		<para>
-		<emphasis>Default value is <quote>100</quote>.</emphasis>
-		</para>
-		<example>
-		<title>Set <varname>cleanup_period</varname> parameter</title>
-		<programlisting format="linespecific">
-...
-modparam("b2b_logic", "cleanup_period", 60)
-...
-	</programlisting>
-		</example>
-	</section>
-
-	<section>
-		<title><varname>custom_headers</varname> (str)</title>
-		<para>
-		A list of SIP header names delimited by ';' that should be passed
-		from the dialog of one side to the other side. There are a number
-		of headers that are passed by default. They are: 
-		<itemizedlist>
-			<listitem>Max-Forwards (it is decreased by 1)</listitem>
-			<listitem>Content-Type</listitem>
-			<listitem>Supported</listitem>
-			<listitem>Allow</listitem>
-			<listitem>Proxy-Require</listitem>
-			<listitem>Session-Expires</listitem>
-			<listitem>Min-SE</listitem>
-			<listitem>Require</listitem>
-			<listitem>RSeq</listitem>
-		</itemizedlist>
-		If you wish some other headers to be passed also you should define them
-		by setting this parameter.
-		</para>
-		<para>
-		<emphasis>Default value is <quote>NULL</quote>.</emphasis>
-		</para>
-		<example>
-		<title>Set <varname></varname> parameter</title>
-		<programlisting format="linespecific">
-...
-modparam("b2b_logic", "custom_headers", "User-Agent;Date")
-...
-	</programlisting>
-		</example>
-	</section>
-
-	<section>
-		<title><varname>use_init_sdp</varname> (int)</title>
-		<para>
-		This parameter modifies the behaviour of the B2BUA when bridging
-		and a provisional media uri is set. For playing media while the callee
-		answers (that is connecting the caller to a media server), the bridging
-		with the callee must start by sending an Invite to it. The correct way
-		is to send an Invite without a body in this case, but it has been observed
-		that not many gateways support this. So, the solution is to use the sdp
-		received in the first Invite from the caller and put it as the body for this
-		invite. By setting this parameter, this behavior is enabled.
-		You can also set use_init_sdp per scenario and overwrite this global value.
-		</para>
-		<para>
-		<emphasis>Default value is <quote>0</quote>.</emphasis>
-		</para>
-		<example>
-		<title>Set <varname></varname> parameter</title>
-		<programlisting format="linespecific">
-...
-modparam("b2b_logic", "use_init_sdp", 1)
-...
-	</programlisting>
-		</example>
-	</section>
-	<section>
-		<title><varname>db_url</varname> (str)</title>
-		<para>
-			Database URL.
-		</para>
-		<example>
-		<title>Set <varname>db_url</varname> parameter</title>
-		<programlisting format="linespecific">
-...
-modparam("b2b_logic", "db_url", "mysql://opensips:opensipsrw@127.0.0.1/opensips")
-...
-	</programlisting>
-		</example>
-	</section>
-	<section>
-		<title><varname>update_period</varname> (int)</title>
-		<para>
-			The time interval at which to update the info in database.
-		</para>
-		<para>
-		<emphasis>Default value is <quote>100</quote>.</emphasis>
-		</para>
-		<example>
-		<title>Set <varname>update_period</varname> parameter</title>
-		<programlisting format="linespecific">
-...
-modparam("b2b_logic", "update_period", 60)
-...
-	</programlisting>
-		</example>
-	</section>
-	<section>
-		<title><varname>max_duration</varname> (int)</title>
-		<para>
-			The maximum duration of a call.
-		</para>
-		<para>
-		<emphasis>Default value is <quote>12 * 3600 (12 hours)</quote>.</emphasis>
-		</para>
-		<para>If you set it to 0, there will be no limitation.</para>
-		<example>
-		<title>Set <varname>max_duration</varname> parameter</title>
-		<programlisting format="linespecific">
-...
-modparam("b2b_logic", "max_duration", 7200)
-...
-	</programlisting>
-		</example>
-	</section>
-
-	<section>
-		<title><varname>b2bl_key_avp</varname> (string)</title>
-		<para>
-			The name of the Attribute-Value-Pair (AVP) used to store the
-			b2b_logic entity key.  The avp will be set after calling
-			<quote>b2b_init_request</quote>.  The avp will be visible
-			in b2b_entities request/reply routes
-		</para>
-		<note><para>The avp is not visible in local_route.</para></note>
-		<para>
-		<emphasis>Default value is <quote>NULL</quote> (disabled).</emphasis>
-		</para>
-		<example>
-		<title>Set <varname>b2bl_key_avp</varname> parameter</title>
-		<programlisting format="linespecific">
-...
-modparam("b2b_logic", "b2bl_key_avp", "$avp(99)")
-...
-	</programlisting>
-		</example>
-	</section>
-
-	<section>
-		<title><varname>b2bl_from_spec_param</varname> (string)</title>
-		<para>
-			The name of the pseudo variable for storing the new
-			<quote>From</quote> header.
-			The PV must be set before calling <quote>b2b_init_request</quote>.
-		</para>
-		<para>
-		<emphasis>Default value is <quote>NULL</quote> (disabled).</emphasis>
-		</para>
-		<example>
-		<title>Set <varname>b2bl_from_spec_param</varname> parameter</title>
-		<programlisting format="linespecific">
-...
-modparam("b2b_logic", "b2bl_from_spec_param", "$var(b2bl_from)")
-...
-route{
-	...
-	# setting the From header
-	$var(b2bl_from) = "\"Call ID\" &lt;sip:user@opensips.org&gt;";
-	...
-	b2b_init_request("top hiding");
-	...
-}
-	</programlisting>
-		</example>
-	</section>
-
-	<section>
-		<title><varname>server_address</varname> (str)</title>
-		<para>
-			The IP address of the machine that will be used as Contact in
-			the generated messages. This is compulsory only when using external
-			scenarios. For the script scenarios, if it is not set, it is constructed
-			dynamically from the socket where the initiating request was received.
-			This socket will be used to send all the requests, replies for that
-			scenario instantiation.
-		</para>
-		<example>
-		<title>Set <varname>server_address</varname> parameter</title>
-		<programlisting format="linespecific">
-...
-modparam("b2b_logic", "server_address", "sip:sa@10.10.10.10:5060")
-...
-	</programlisting>
-		</example>
-	</section>
-
-	<section>
-		<title><varname>init_callid_hdr</varname> (str)</title>
-		<para>
-			The module offers the possibility to insert the original callid in a header
-			in the generated Invites. If you want this, set this parameter to the name
-			of the header in which to insert the original callid.
-		</para>
-		<example>
-		<title>Set <varname>init_callid_hdr</varname> parameter</title>
-		<programlisting format="linespecific">
-...
-modparam("b2b_logic", "init_callid_hdr", "Init-CallID")
-...
-	</programlisting>
-		</example>
-	</section>
-	<section>
-		<title><varname>db_mode</varname> (int)</title>
-		<para>
-			The B2B modules have support for the 3 type of database storage
-		</para>
-		<para>
-		<itemizedlist>
-				<listitem>NO DB STORAGE - set this parameter to 0</listitem>
-				<listitem>WRITE THROUGH (synchronous write in database) - set this parameter to 1</listitem>
-				<listitem>WRITE BACK (update in db from time to time) - set this parameter to 2</listitem>
-		</itemizedlist>
-		</para>
-		<para>
-		<emphasis>Default value is <quote>2</quote> (WRITE BACK).</emphasis>
-		</para>
-		<example>
-		<title>Set <varname>db_mode</varname> parameter</title>
-		<programlisting format="linespecific">
-...
-modparam("b2b_logic", "db_mode", 1)
-...
-	</programlisting>
-		</example>
-	</section>
-
-	</section>
-
-	<section>
-		<title>Exported Functions</title>
-	<section>
-		<title>
-		<function moreinfo="none">b2b_init_request</function>
-		</title>
-		<para>
-			This is the function that must be called by the script writer
-			on an initial INVITE for which a B2B scenario must be instantiated.
-			It is up to the script writer to decide which are the criteria to decide
-			for which messages certain scenarios must be instantiated.
-		</para>
-		<para>
-			The first parameter is the identifier for the scenario. This is defined
-			in the XML document as an attribute of the root node.
-		</para>
-		<para>
-			Then it can take at most 4 other parameters that represent the parameters for
-			the xml scenario. The expected number of parameters is also specified as an attribute
-			in the root node of the XML scenario.
-		</para>
-	<note><para>
-		Do not call t_newtran() from the script on this request. It will be called internally
-		by the function. Calling t_newtran() from the script will result in the transaction remaining
-		in memory for ever.
-	</para></note>
-		<example>
-			<title><function>b2b_init_request</function> usage</title>
-		<programlisting format="linespecific">
-...
-if(is_method("INVITE") &amp;&amp; !has_totag() &amp;&amp; prepaid_user())
-   b2b_init_request("prepaid", "sip:320@opensips.org:5070",
-      "sip:321@opensips.org:5070"));
-...
-	</programlisting>
-		</example>
-	</section>
-	<section>
-		<title>
-		<function moreinfo="none">b2b_bridge_request(b2bl_key,entity_no)</function>
-		</title>
-		<para>
-			This function will bridge an initial INVITE with one of the
-			particapnts from an existing b2b dialog.
-		</para>
-		<para>Parameters:</para>
-		<itemizedlist>
-			<listitem><para>
-				<emphasis>b2bl_key</emphasis> - a pseudo-variable that
-				contains the b2b_logic key
-			</para></listitem>
-			<listitem><para>
-				<emphasis>entity_no</emphasis> - a pseudo-variable that
-				holds the entity of the particapnt to bridge.
-			</para></listitem>
-		</itemizedlist>
-		<example>
-			<title><function>b2b_bridge_request</function> usage</title>
-		<programlisting format="linespecific">
-...
-modparam("b2b_logic", "b2bl_key_avp", "$avp(99)")
-...
-route(X)
-{
-   # handling b2b calls here
-   ...
-   b2b_init_request("top hiding");
-   xlog("L_INFO","[$mi] got b2bl_key='$avp(99)'\n");
-   # saving the b2b key into the local cache
-   cache_store("local","some_b2bl_key_identifier","$avp(99)");
-   ...
-}
-
-route(Y)
-{
-   # handling calls to bridge to existing b2b calls
-   ...
-   # retrieving the key of a b2b call
-   cache_fetch("local","some_b2bl_key_identifier", $avp(98) );
-   $var(entity) = 1;
-   b2b_bridge_request("$avp(98)","$var(entity)");
-   ...
-}
-...
-		</programlisting>
-		</example>
-	</section>
-
-</section>
-
-<section>
-	<title>Exported MI Functions</title>
-	<section>
-		<title>
-		<function moreinfo="none">b2b_trigger_scenario</function>
-		</title>
-		<para>
-		This command instantiated a B2B scenario.
-		</para>
-		<para>
-		Name: <emphasis>b2b_trigger_scenario</emphasis>
-		</para>
-		<para>Parameters:</para>
-		<itemizedlist>
-			<listitem>
-				<para>senario_id : the id of the scenario to be instantiated.
-				</para>
-			</listitem>
-			<listitem>
-				<para>scenario parameters - it can take 4 more parameters that are scenario parameters</para>
-			</listitem>
-		</itemizedlist>
-		<para>
-		MI FIFO Command Format:
-		</para>
-	<programlisting  format="linespecific">
-	:b2b_trigger_scenario:fifo_reply
-	marketing
-	sip:bob@opensips.org
-	sip:322@opensips.org:5070
-	sip:alice@opensips.org
-	_empty_line_
-		</programlisting>
-	</section>
-
-	<section>
-		<title>
-		<function moreinfo="none">b2b_bridge</function>
-		</title>
-		<para>
-			This command can be used by an external application to tell B2BUA to bridge a
-			call party from an on going dialog to another destination. By default the caller
-			is bridged to the new uri and BYE is set to the callee. You can instead bridge
-			the callee if you send 1 as the third parameter.
-		</para>
-		<para>
-		Name: <emphasis>b2b_bridge</emphasis>
-		</para>
-		<para>Parameters:</para>
-		<itemizedlist>
-			<listitem>
-				<para>dialog-id : the id of the dialog. If you set the module parameter dialog-id
-				the server will include the dialogid in the generated Invites as the content of a
-				header with name 'Dialog-ID'.
-				</para>
-			</listitem>
-			<listitem>
-				<para>new uri - the uri of the new destination</para>
-			</listitem>
-			<listitem>
-				<para>flag to specify that the callee must be bridged to the new destination.
-					It is optional. If not present the caller will be bridged.</para>
-			</listitem>
-		</itemizedlist>
-		<para>MI FIFO Command Format:</para>
-	<programlisting  format="linespecific">
-	:b2b_bridge:fifo_reply
-	1020.30
-	sip:alice@opensips.org
-	_empty_line_
-	</programlisting>
-		<para>opensipsctl Command Format:</para>
-	<programlisting  format="linespecific">
-	opensipsctl b2b_bridge 1020.30 sip:alice@opensips.org
-	</programlisting>
-	</section>
-
-	<section>
-		<title>
-		<function moreinfo="none">b2b_list</function>
-		</title>
-		<para>
-			This command can be used to list the internals of b2b_logic entities.
-		</para>
-		<para>
-		Name: <emphasis>b2b_list</emphasis>
-		</para>
-		<para>Parameters: <emphasis>none</emphasis></para>
-		<itemizedlist>
-		</itemizedlist>
-		<para>MI FIFO Command Format:</para>
-	<programlisting  format="linespecific">
-	:b2b_list:_reply_fifo_file_
-	_empty_line_
-	</programlisting>
-		<para>opensipsctl Command Format:</para>
-	<programlisting  format="linespecific">
-	opensipsctl fifo b2b_list
-	</programlisting>
-	</section>
-
-</section>
-
-</chapter>
-
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/doc/.svn/text-base/b2b_logic_devel.xml.svn-base ./b2b_logic/doc/.svn/text-base/b2b_logic_devel.xml.svn-base
--- ./trunk/src/opensips_1_7/modules/b2b_logic/doc/.svn/text-base/b2b_logic_devel.xml.svn-base	2012-10-31 10:33:43.016947340 +0000
+++ ./b2b_logic/doc/.svn/text-base/b2b_logic_devel.xml.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,252 +0,0 @@
-<!-- Module Developer's Guide -->
-
-<chapter>
-    <title>&develguide;</title>
-	<para>
-   The module provides an API that can be used from other &osips;
-   modules. The API offers the functions for instantiating b2b
-   scenarios from other modules (this comes as an addition to the
-   other two means of instantiating b2b scenarios - from script
-   and with an MI command). Also the instantiations can be
-   dynamically controlled, by commanding the bridging of an entity
-   involved in a call to another entity or the termination of the
-   call or even bridging two existing calls.
-   </para>
- 		<section>
-				<title>
-				<function moreinfo="none">b2b_logic_bind(b2bl_api_t* api)</function>
-				</title>
-			<para>
-   This function binds the b2b_entities modules and fills the
-   structure the exported functions that will be described in
-   detail.
-			</para>
-		<example>
-		<title><function>b2bl_api_t</function> structure</title>
-	<programlisting format="linespecific">
-...
-typedef struct b2bl_api
-{
-	b2bl_init_f init;
-	b2bl_bridge_f bridge;
-	b2bl_bridge_extern_f bridge_extern;
-	b2bl_bridge_2calls_t bridge_2calls;
-	b2bl_terminate_call_t terminate_call;
-	b2bl_set_state_f set_state;
-	b2bl_bridge_msg_t bridge_msg;
-}b2bl_api_t;
-...
-</programlisting>
-		</example>
-
-		</section>
-	
-	<section>
-		<title>
-		<function moreinfo="none">init</function>
-		</title>
-		<para>
-			Field type:
-		</para>
-			<programlisting format="linespecific">
-...
-typedef str* (*b2bl_init_f)(struct sip_msg* msg, str* name, str* args[5],
-		b2bl_cback_f, void* param);
-...
-</programlisting>
-	<para>
-   Initializing a b2b scenario. The last two parameters are the
-   callback function and the parameter to be called in 3
-   situations that will be listed below. The callback function has
-   the following definition:
-	</para>
-	<programlisting format="linespecific">
-...
-typedef int (*b2b_notify_t)(struct sip_msg* msg, str* id, int type, void* param);
-...
-</programlisting>
-	<para>
-   The first argument is the callback given in the init function.
-	</para>
-	<para>
-   The second argument is a structure with some statistics about
-   the call -start time, setup time, call time.
-	</para>
-	<para>
-   The third argument is the current state of the scenario
-   instantiation.
-	</para>
-	<para>
-   The last argument is the event that triggered the callback.
-   There are 3 events when the callback is called:
-   </para>
-   <itemizedlist>
-	<listitem>
-		<para>
-			<emphasis>when a BYE is received from either side- event parameter
-	will also show from which side the BYE is received, so it
-	can be B2B_BYE_E1 or B2B_BYE_E2</emphasis>
-		</para>
-	</listitem>
-	<listitem>
-     <para>
-		<emphasis>If while bridging, a negative reply is received from the
-     second entity - the event is B2B_REJECT_E2.</emphasis>
-		</para>
-	</listitem>
-	<listitem>
-     <para>
-		<emphasis>When the b2b logic entity is deleted- the evnet is
-     B2B_DESTROY</emphasis>
-		</para>
-	</listitem>
-	</itemizedlist>
-	<para>
-	The return code controls what will happen with the
-   request/reply that caused the event (except for the last event,
-   when the return code does not matter)
-   </para>
-	<itemizedlist>
-	<listitem>
-		<para>
-			<emphasis>-1 - error</emphasis>
-		</para>
-	</listitem>
-	<listitem>
-		<para>
-		<emphasis>0 - drop the BYE or reply</emphasis>
-		</para>
-	</listitem>
-	<listitem>
-		<para>
-			<emphasis>   1 - send the BYE or reply on the other side</emphasis>
-		</para>
-	</listitem>
-	<listitem>
-		<para>
-			<emphasis>2 - do what the scenario tells, if no rule defined send the
-       BYE or reply on the other side</emphasis>
-		</para>
-	</listitem>
-</itemizedlist>
-</section>
-
-<section>
-		<title>
-		<function moreinfo="none">bridge</function>
-		</title>
-		<para>
-			Field type:
-		</para>
-			<programlisting format="linespecific">
-...
-typedef int (*b2bl_bridge_f)(str* key, str* new_uri, str* new_from_dname,int entity_type);
-...
-</programlisting>
-		<para>
-   This function allows bridging an entity that is in a call
-   handled by b2b_logic to another entity.
-		</para>
-</section>
-
-<section>
-		<title>
-		<function moreinfo="none">bridge_extern</function>
-		</title>
-		<para>
-			Field type:
-		</para>
-			<programlisting format="linespecific">
-...
-typedef str* (*b2bl_bridge_extern_f)(str* scenario_name, str* args[5],
-                b2bl_cback_f cbf, void* cb_param);
-...
-</programlisting>
-		<para>
-   This function allows initiating an extern scenario, when the
-   B2BUA starts a call from the middle.
-		</para>
-</section>
-
-<section>
-		<title>
-		<function moreinfo="none">bridge_2calls</function>
-		</title>
-		<para>
-			Field type:
-		</para>
-			<programlisting format="linespecific">
-...
-typedef int (*b2bl_bridge_2calls_t)(str* key1, str* key2);
-...
-</programlisting>
-	<para>
-   With this function it is possible to bridge two existing calls.
-   The first entity from the two calls will be connected and BYE
-   will be sent to their peers.
-	</para>
-</section>
-
-<section>
-		<title>
-		<function moreinfo="none">terminate_call</function>
-		</title>
-		<para>
-			Field type:
-		</para>
-			<programlisting format="linespecific">
-...
-typedef int (*b2bl_terminate_call_t)(str* key);
-...
-</programlisting>
-	<para>
-	Terminate a call.
-	</para>
-</section>
-
-<section>
-		<title>
-		<function moreinfo="none">set_state</function>
-		</title>
-		<para>
-			Field type:
-		</para>
-			<programlisting format="linespecific">
-...
-typedef int (*b2bl_set_state_f)(str* key, int state);
-...
-</programlisting>
-	<para>
-   Set the scenario state.
-	</para>
-</section>
-
-<section>
-		<title>
-		<function moreinfo="none">bridge_msg</function>
-		</title>
-		<para>
-			Field type:
-		</para>
-			<programlisting format="linespecific">
-...
-typedef int (*b2bl_bridge_msg_t)(struct sip_msg* msg, str* key, int entity_no);
-...
-</programlisting>
-	<para>
-   This function allows bridging an incoming call to an entity from an
-   existing call.
-	</para>
-	<para>
-   The first argument is the INVITE message of the current incoming call.
-	</para>
-	<para>
-   The second argument is the b2bl_key of an existing call.
-	</para>
-	<para>
-   The third argument is the entity identifier.
-	</para>
-</section>
-
-</chapter>
-
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/doc/.svn/text-base/b2b_logic.xml.svn-base ./b2b_logic/doc/.svn/text-base/b2b_logic.xml.svn-base
--- ./trunk/src/opensips_1_7/modules/b2b_logic/doc/.svn/text-base/b2b_logic.xml.svn-base	2012-10-31 10:33:43.016947340 +0000
+++ ./b2b_logic/doc/.svn/text-base/b2b_logic.xml.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,75 +0,0 @@
-<?xml version="1.0" encoding='ISO-8859-1'?>
-<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
-"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
-
-
-<!ENTITY admin SYSTEM "b2b_logic_admin.xml">
-<!ENTITY devel SYSTEM "b2b_logic_devel.xml">
-<!ENTITY faq SYSTEM "../../../doc/module_faq.xml">
-
-<!-- Include general documentation entities -->
-<!ENTITY % docentities SYSTEM "../../../doc/entities.xml">
-%docentities;
-
-]>
-
-<book>
-    <bookinfo>
-	<title>B2B_LOGIC</title>
-	<productname class="trade">&osipsname;</productname>
-	<authorgroup>
-	    <author>
-		<firstname>Anca-Maria</firstname>
-		<surname>Vamanu</surname>
-		<affiliation><orgname>&osips;</orgname></affiliation>
-		<address>
-		<email>anca@opensips.org</email>
-		<otheraddr>
-		<ulink url="http://www.opensips.org">http://opensips.org</ulink>
-		</otheraddr>
-		</address>
-	    </author>
-	    <editor>
-		<firstname>Anca-Maria</firstname>
-		<surname>Vamanu</surname>
-		<address>
-		    <email>anca@opensips.org</email>
-		</address>
-	    </editor>
-	    <editor>
-		<firstname>Ovidiu</firstname>
-		<surname>Sas</surname>
-		<address>
-		    <email>osas@voipembedded.com</email>
-		</address>
-	    </editor>
-	  	</authorgroup>
-	<copyright>
-		<year>2009</year>
-		<holder>
-		<firstname>Anca-Maria</firstname>
-		<surname>Vamanu</surname>
-		</holder>
-	</copyright>
-	<copyright>
-		<year>2010</year>
-		<holder>
-		<ulink url="http://www.voipembedded.com">VoIP Embedded, Inc.</ulink>
-		</holder>
-	</copyright>
-	<revhistory>
-	    <revision>
-		<revnumber>$Revision$</revnumber>
-		<date>$Date$</date>
-	    </revision>
-	</revhistory>
-  </bookinfo>
-    <toc></toc>
-    
-	&admin;
-	&devel;
-    &faq;
-    
-</book>
-
-
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/logic.c ./b2b_logic/logic.c
--- ./trunk/src/opensips_1_7/modules/b2b_logic/logic.c	2012-10-31 10:33:43.068947294 +0000
+++ ./b2b_logic/logic.c	2012-10-31 10:33:26.544947350 +0000
@@ -90,12 +90,10 @@
 	str body;
 
 	body.s=get_body(msg);
-
 	if(!msg->body_lumps)
 		return 0;
 	len = lumps_len(msg, msg->body_lumps, 0)
 		+ get_content_length(msg);
-
 	LM_DBG("*** len = %d\n", len);
 
 	buf=(char*)pkg_malloc(len+1);
@@ -112,7 +110,7 @@
 
 	new_body->s = buf;
 	new_body->len = len;
-
+	
 	memcpy(buf+offset, msg->buf+s_offset, len - offset);
 
 	LM_DBG("new_body= [%.*s], len=%d\n", new_body->len, new_body->s, len);
@@ -2689,6 +2687,8 @@
 	tuple->lifetime = 60 + get_ticks();
 
 	/* create new server */
+
+
 	server_id = b2b_api.server_new(msg, &tuple->local_contact,
 			b2b_server_notify, b2bl_key);
 	if(server_id == NULL)
@@ -2738,12 +2738,69 @@
 
 	client_id = b2b_api.client_new(&ci, b2b_client_notify,
 			b2b_add_dlginfo, b2bl_key);
+
 	if(client_id == NULL)
 	{
 		LM_ERR("failed to create new b2b client instance\n");
 		goto error;
 	}
 
+	// (JORGE) Get ids and add them in them connections structures
+
+//	if(b2bl_key == NULL || b2bl_key->s == NULL)
+//	{
+//		LM_ERR("failed to retrieve b2bl_key\n");
+//		goto error;
+//	}
+
+	struct to_body *pfrom;          //Structure contFrom header
+
+	if( parse_from_header( msg ) != 0 )
+	{                    // Parse header FROM
+		LM_ERR("ERROR: Bad Header\n");
+		goto error;
+	}
+
+	pfrom = get_from(msg);          //Get structure containing From header
+//	if(pfrom==NULL)
+//	{
+//		LM_ERR("Error. pfrom has null value\n");
+//		goto error;
+//	}
+
+//	int len_from_tag = pfrom->tag_value.len+1;
+//	int len_callid = msg->callid->body.len+1;
+//	int len_b2b_call_ID = client_id->len+1;
+//	int len_server_call_ID = server_id->len+1;
+//	int len_key = b2bl_key->len+1;
+//	int len_from_tag_gen = from_tag_gen.len+1;
+//
+//	if(len_from_tag<128 || len_callid<128 || len_b2b_call_ID<128 || len_server_call_ID<128 || len_key<128 || len_from_tag_gen<128)
+//	{
+//		LM_ERR("Value higher than acceptable size.len_from_tag %d | len_callid %d | len_b2b_call_ID %d | len_server_call_ID %d | len_key %d | len_from_tag_gen %d\n",
+//				len_from_tag,len_callid,len_b2b_call_ID,len_server_call_ID,len_key,len_from_tag_gen);
+//		goto error;
+//	}
+
+	char from_tag[128]; bzero(from_tag,128);
+	snprintf(from_tag,pfrom->tag_value.len+1,pfrom->tag_value.s);
+
+	char orig_call_ID[128]; bzero(orig_call_ID,128);
+	char b2b_call_ID[128]; bzero(b2b_call_ID,128);
+	char b2b_server_call_ID[128]; bzero(b2b_server_call_ID,128);
+	char b2b_key[128]; bzero(b2b_key,128);
+	char b2b_from_tag_gen[128]; bzero(b2b_from_tag_gen,128);
+
+	snprintf(orig_call_ID,msg->callid->body.len+1,msg->callid->body.s);
+	snprintf(b2b_call_ID,client_id->len+1,client_id->s);
+	snprintf(b2b_server_call_ID,server_id->len+1,server_id->s);
+	snprintf(b2b_key,b2bl_key->len+1,b2bl_key->s);
+	snprintf(b2b_from_tag_gen,from_tag_gen.len+1,from_tag_gen.s);
+
+	b2b_xcoder.add_b2b_callID(orig_call_ID,b2b_call_ID,b2b_server_call_ID,b2b_key,from_tag,b2b_from_tag_gen);
+
+	// End of (JORGE) modifications
+
 	client_entity = b2bl_create_new_entity(B2B_CLIENT, client_id, &to_uri, &from_uri,
 			0, 0, 0);
 	if(client_entity == NULL)
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/Makefile ./b2b_logic/Makefile
--- ./trunk/src/opensips_1_7/modules/b2b_logic/Makefile	2012-10-31 10:33:43.064947343 +0000
+++ ./b2b_logic/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,14 +0,0 @@
-# $Id: Makefile 806 2006-04-14 11:00:10Z bogdan_iancu $
-#
-# WARNING: do not run this directly, it should be run by the master Makefile
-
-include ../../Makefile.defs
-auto_gen=
-NAME=b2b_logic.so
-LIBS= 
-
-DEFS+=-I$(SYSBASE)/include/libxml2 -I$(LOCALBASE)/include/libxml2 \
-      -I$(LOCALBASE)/include
-LIBS=-L$(SYSBASE)/include/lib  -L$(LOCALBASE)/lib -lxml2
-
-include ../../Makefile.modules
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/pidf.c ./b2b_logic/pidf.c
--- ./trunk/src/opensips_1_7/modules/b2b_logic/pidf.c	2012-10-31 10:33:43.048947363 +0000
+++ ./b2b_logic/pidf.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,98 +0,0 @@
-/*
- * $Id: pidf.c 8371 2011-09-13 22:31:47Z osas $
- *
- * back-to-back logic module
- *
- * Copyright (C) 2009 Free Software Fundation
- *
- * This file is part of opensips, a free SIP server.
- *
- * opensips is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version
- *
- * opensips is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License 
- * along with this program; if not, write to the Free Software 
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * History:
- * --------
- *  2009-08-03  initial version (Anca Vamanu)
- */
-
-
-#include <libxml/parser.h>
-#include "pidf.h"
-
-xmlAttrPtr xmlNodeGetAttrByName(xmlNodePtr node, const char *name)
-{
-	xmlAttrPtr attr = node->properties;
-	while (attr) {
-		if (xmlStrcasecmp(attr->name, (unsigned char*)name) == 0)
-			return attr;
-		attr = attr->next;
-	}
-	return NULL;
-}
-
-unsigned char *xmlNodeGetAttrContentByName(xmlNodePtr node, const char *name)
-{
-	xmlAttrPtr attr = xmlNodeGetAttrByName(node, name);
-	if (attr)
-		return xmlNodeGetContent(attr->children);
-	else
-		return NULL;
-}
-
-xmlNodePtr xmlNodeGetChildByName(xmlNodePtr node, const char *name)
-{
-	xmlNodePtr cur = node->children;
-	while (cur) {
-		if (xmlStrcasecmp(cur->name, (unsigned char*)name) == 0)
-			return cur;
-		cur = cur->next;
-	}
-	return NULL;
-}
-
-xmlNodePtr xmlNodeGetNodeByName(xmlNodePtr node, const char *name,
-															const char *ns)
-{
-	xmlNodePtr cur = node;
-	while (cur) {
-		xmlNodePtr match = NULL;
-		if (xmlStrcasecmp(cur->name, (unsigned char*)name) == 0) {
-			if (!ns || (cur->ns && xmlStrcasecmp(cur->ns->prefix,
-							(unsigned char*)ns) == 0))
-				return cur;
-		}
-		match = xmlNodeGetNodeByName(cur->children, name, ns);
-		if (match)
-			return match;
-		cur = cur->next;
-	}
-	return NULL;
-}
-
-xmlNodePtr xmlDocGetNodeByName(xmlDocPtr doc, const char *name, const char *ns)
-{
-	xmlNodePtr cur = doc->children;
-	return xmlNodeGetNodeByName(cur, name, ns);
-}
-
-char *xmlNodeGetNodeContentByName(xmlNodePtr root, const char *name,
-		const char *ns)
-{
-	xmlNodePtr node = xmlNodeGetNodeByName(root, name, ns);
-	if (node)
-		return (char*)xmlNodeGetContent(node->children);
-	else
-		return NULL;
-}
-
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/pidf.h ./b2b_logic/pidf.h
--- ./trunk/src/opensips_1_7/modules/b2b_logic/pidf.h	2012-10-31 10:33:43.056947361 +0000
+++ ./b2b_logic/pidf.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,41 +0,0 @@
-/*
- * $Id: pidf.h 8371 2011-09-13 22:31:47Z osas $
- *
- * back-to-back logic module
- *
- * Copyright (C) 2009 Free Software Fundation
- *
- * This file is part of opensips, a free SIP server.
- *
- * opensips is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version
- *
- * opensips is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License 
- * along with this program; if not, write to the Free Software 
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * History:
- * --------
- *  2009-08-03  initial version (Anca Vamanu)
- */
-
-#ifndef _B2BL_PIDF_H_
-#define _B2BL_PIDF_H_
-
-unsigned char *xmlNodeGetAttrContentByName(xmlNodePtr node, const char *name);
-
-xmlNodePtr xmlNodeGetChildByName(xmlNodePtr node, const char *name);
-
-xmlNodePtr xmlDocGetNodeByName(xmlDocPtr doc, const char *name, const char *ns);
-
-char *xmlNodeGetNodeContentByName(xmlNodePtr root, const char *name,
-		const char *ns);
-
-#endif
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/README ./b2b_logic/README
--- ./trunk/src/opensips_1_7/modules/b2b_logic/README	2012-10-31 10:33:43.064947343 +0000
+++ ./b2b_logic/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,628 +0,0 @@
-B2B_LOGIC
-
-Anca-Maria Vamanu
-
-   OpenSIPS
-
-Edited by
-
-Anca-Maria Vamanu
-
-Edited by
-
-Ovidiu Sas
-
-   Copyright  2009 Anca-Maria
-   Vamanu
-
-   Copyright  2010 VoIP Embedded, Inc.
-   Revision History
-   Revision $Revision: 8137 $ $Date: 2011-07-07 15:02:20 +0300
-                              (Thu, 07 Jul 2011) $
-     __________________________________________________________
-
-   Table of Contents
-
-   1. Admin Guide
-
-        1.1. Overview
-        1.2. Dependencies
-
-              1.2.1. OpenSIPS Modules
-              1.2.2. External Libraries or Applications
-
-        1.3. Exported Parameters
-
-              1.3.1. hash_size (int)
-              1.3.2. script_scenario (str)
-              1.3.3. extern_scenario (str)
-              1.3.4. cleanup_period (int)
-              1.3.5. custom_headers (str)
-              1.3.6. use_init_sdp (int)
-              1.3.7. db_url (str)
-              1.3.8. update_period (int)
-              1.3.9. max_duration (int)
-              1.3.10. b2bl_key_avp (string)
-              1.3.11. b2bl_from_spec_param (string)
-              1.3.12. server_address (str)
-              1.3.13. init_callid_hdr (str)
-              1.3.14. db_mode (int)
-
-        1.4. Exported Functions
-
-              1.4.1. b2b_init_request
-              1.4.2. b2b_bridge_request(b2bl_key,entity_no)
-
-        1.5. Exported MI Functions
-
-              1.5.1. b2b_trigger_scenario
-              1.5.2. b2b_bridge
-              1.5.3. b2b_list
-
-   2. Developer Guide
-
-        2.1. b2b_logic_bind(b2bl_api_t* api)
-        2.2. init
-        2.3. bridge
-        2.4. bridge_extern
-        2.5. bridge_2calls
-        2.6. terminate_call
-        2.7. set_state
-        2.8. bridge_msg
-
-   List of Examples
-
-   1.1. Set server_hsize parameter
-   1.2. Set script_scenario parameter
-   1.3. Set script_scenario parameter
-   1.4. Set cleanup_period parameter
-   1.5. Set parameter
-   1.6. Set parameter
-   1.7. Set db_url parameter
-   1.8. Set update_period parameter
-   1.9. Set max_duration parameter
-   1.10. Set b2bl_key_avp parameter
-   1.11. Set b2bl_from_spec_param parameter
-   1.12. Set server_address parameter
-   1.13. Set init_callid_hdr parameter
-   1.14. Set db_mode parameter
-   1.15. b2b_init_request usage
-   1.16. b2b_bridge_request usage
-   2.1. b2bl_api_t structure
-
-Chapter 1. Admin Guide
-
-1.1. Overview
-
-   The B2BUA implementation in OpenSIPS is separated in two
-   layers:
-     * a lower one(coded in b2b_entities module)- which implements
-       the basic functions of a UAS and UAC
-     * an upper one - which represents the logic engine of B2BUA,
-       responsible of actually implementing the B2BUA services
-       using the functions offered by the low level.
-
-   This module is a B2BUA upper level implementation that can be
-   used with b2b_entities module to have B2BUA that can be
-   configured to provide some PBX services. The B2B services are
-   coded in an XML scenario document. The b2b_logic module
-   examines this document and uses the functions provided by the
-   b2b_entities module to achieve the actions specified in the
-   document and enable the service.
-
-   A scenario can be instantiated in two ways:
-     * from the script - at the receipt of a initial message
-     * with a extern command (MI) command - the server will
-       connect two end points in a session(Third Party Call
-       Control).
-
-1.2. Dependencies
-
-1.2.1. OpenSIPS Modules
-
-     * b2b_entities, a db module
-
-1.2.2. External Libraries or Applications
-
-   The following libraries or applications must be installed
-   before running OpenSIPS with this module loaded:
-     * libxml2-dev
-
-1.3. Exported Parameters
-
-1.3.1. hash_size (int)
-
-   The size of the hash table that stores the scenario
-   instatiation entities.
-
-   Default value is 9 (512 records).
-
-   Example 1.1. Set server_hsize parameter
-...
-modparam("b2b_logic", "hash_size", 10)
-...
-
-1.3.2. script_scenario (str)
-
-   This parameter should be set with the path of a document that
-   contains a scenario that can be instantiated from the script at
-   the receipt of an initial message.
-
-   This parameter can be set more than once.
-
-   Example 1.2. Set script_scenario parameter
-...
-modparam("b2b_logic", "script_scenario", "/usr/local/opensips/scripts/b2
-b_prepaid.xml")
-...
-
-1.3.3. extern_scenario (str)
-
-   This parameter should be set with the path of a document that
-   contains a scenario that can be instantiated with an MI
-   command.
-
-   This parameter can be set more than once.
-
-   Example 1.3. Set script_scenario parameter
-...
-modparam("b2b_logic", "extern_scenario", "/usr/local/opensips/scripts/b2
-b_marketing.xml")
-...
-
-1.3.4. cleanup_period (int)
-
-   The time interval at which to search for an hanged b2b context.
-   A scenario is considered expired if the duration of a session
-   exceeds the lifetime specified in the scenario. At that moment,
-   BYE is sent in all the dialogs from that context and the
-   context is deleted.
-
-   Default value is 100.
-
-   Example 1.4. Set cleanup_period parameter
-...
-modparam("b2b_logic", "cleanup_period", 60)
-...
-
-1.3.5. custom_headers (str)
-
-   A list of SIP header names delimited by ';' that should be
-   passed from the dialog of one side to the other side. There are
-   a number of headers that are passed by default. They are:
-     * Max-Forwards (it is decreased by 1)
-     * Content-Type
-     * Supported
-     * Allow
-     * Proxy-Require
-     * Session-Expires
-     * Min-SE
-     * Require
-     * RSeq
-
-   If you wish some other headers to be passed also you should
-   define them by setting this parameter.
-
-   Default value is NULL.
-
-   Example 1.5. Set parameter
-...
-modparam("b2b_logic", "custom_headers", "User-Agent;Date")
-...
-
-1.3.6. use_init_sdp (int)
-
-   This parameter modifies the behaviour of the B2BUA when
-   bridging and a provisional media uri is set. For playing media
-   while the callee answers (that is connecting the caller to a
-   media server), the bridging with the callee must start by
-   sending an Invite to it. The correct way is to send an Invite
-   without a body in this case, but it has been observed that not
-   many gateways support this. So, the solution is to use the sdp
-   received in the first Invite from the caller and put it as the
-   body for this invite. By setting this parameter, this behavior
-   is enabled. You can also set use_init_sdp per scenario and
-   overwrite this global value.
-
-   Default value is 0.
-
-   Example 1.6. Set parameter
-...
-modparam("b2b_logic", "use_init_sdp", 1)
-...
-
-1.3.7. db_url (str)
-
-   Database URL.
-
-   Example 1.7. Set db_url parameter
-...
-modparam("b2b_logic", "db_url", "mysql://opensips:opensipsrw@127.0.0.1/o
-pensips")
-...
-
-1.3.8. update_period (int)
-
-   The time interval at which to update the info in database.
-
-   Default value is 100.
-
-   Example 1.8. Set update_period parameter
-...
-modparam("b2b_logic", "update_period", 60)
-...
-
-1.3.9. max_duration (int)
-
-   The maximum duration of a call.
-
-   Default value is 12 * 3600 (12 hours).
-
-   If you set it to 0, there will be no limitation.
-
-   Example 1.9. Set max_duration parameter
-...
-modparam("b2b_logic", "max_duration", 7200)
-...
-
-1.3.10. b2bl_key_avp (string)
-
-   The name of the Attribute-Value-Pair (AVP) used to store the
-   b2b_logic entity key. The avp will be set after calling
-   b2b_init_request. The avp will be visible in b2b_entities
-   request/reply routes
-
-Note
-
-   The avp is not visible in local_route.
-
-   Default value is NULL (disabled).
-
-   Example 1.10. Set b2bl_key_avp parameter
-...
-modparam("b2b_logic", "b2bl_key_avp", "$avp(99)")
-...
-
-1.3.11. b2bl_from_spec_param (string)
-
-   The name of the pseudo variable for storing the new From
-   header. The PV must be set before calling b2b_init_request.
-
-   Default value is NULL (disabled).
-
-   Example 1.11. Set b2bl_from_spec_param parameter
-...
-modparam("b2b_logic", "b2bl_from_spec_param", "$var(b2bl_from)")
-...
-route{
-        ...
-        # setting the From header
-        $var(b2bl_from) = "\"Call ID\" <sip:user@opensips.org>";
-        ...
-        b2b_init_request("top hiding");
-        ...
-}
-
-1.3.12. server_address (str)
-
-   The IP address of the machine that will be used as Contact in
-   the generated messages. This is compulsory only when using
-   external scenarios. For the script scenarios, if it is not set,
-   it is constructed dynamically from the socket where the
-   initiating request was received. This socket will be used to
-   send all the requests, replies for that scenario instantiation.
-
-   Example 1.12. Set server_address parameter
-...
-modparam("b2b_logic", "server_address", "sip:sa@10.10.10.10:5060")
-...
-
-1.3.13. init_callid_hdr (str)
-
-   The module offers the possibility to insert the original callid
-   in a header in the generated Invites. If you want this, set
-   this parameter to the name of the header in which to insert the
-   original callid.
-
-   Example 1.13. Set init_callid_hdr parameter
-...
-modparam("b2b_logic", "init_callid_hdr", "Init-CallID")
-...
-
-1.3.14. db_mode (int)
-
-   The B2B modules have support for the 3 type of database storage
-
-     * NO DB STORAGE - set this parameter to 0
-     * WRITE THROUGH (synchronous write in database) - set this
-       parameter to 1
-     * WRITE BACK (update in db from time to time) - set this
-       parameter to 2
-
-   Default value is 2 (WRITE BACK).
-
-   Example 1.14. Set db_mode parameter
-...
-modparam("b2b_logic", "db_mode", 1)
-...
-
-1.4. Exported Functions
-
-1.4.1.  b2b_init_request
-
-   This is the function that must be called by the script writer
-   on an initial INVITE for which a B2B scenario must be
-   instantiated. It is up to the script writer to decide which are
-   the criteria to decide for which messages certain scenarios
-   must be instantiated.
-
-   The first parameter is the identifier for the scenario. This is
-   defined in the XML document as an attribute of the root node.
-
-   Then it can take at most 4 other parameters that represent the
-   parameters for the xml scenario. The expected number of
-   parameters is also specified as an attribute in the root node
-   of the XML scenario.
-
-Note
-
-   Do not call t_newtran() from the script on this request. It
-   will be called internally by the function. Calling t_newtran()
-   from the script will result in the transaction remaining in
-   memory for ever.
-
-   Example 1.15. b2b_init_request usage
-...
-if(is_method("INVITE") && !has_totag() && prepaid_user())
-   b2b_init_request("prepaid", "sip:320@opensips.org:5070",
-      "sip:321@opensips.org:5070"));
-...
-
-1.4.2.  b2b_bridge_request(b2bl_key,entity_no)
-
-   This function will bridge an initial INVITE with one of the
-   particapnts from an existing b2b dialog.
-
-   Parameters:
-     * b2bl_key - a pseudo-variable that contains the b2b_logic
-       key
-     * entity_no - a pseudo-variable that holds the entity of the
-       particapnt to bridge.
-
-   Example 1.16. b2b_bridge_request usage
-...
-modparam("b2b_logic", "b2bl_key_avp", "$avp(99)")
-...
-route(X)
-{
-   # handling b2b calls here
-   ...
-   b2b_init_request("top hiding");
-   xlog("L_INFO","[$mi] got b2bl_key='$avp(99)'\n");
-   # saving the b2b key into the local cache
-   cache_store("local","some_b2bl_key_identifier","$avp(99)");
-   ...
-}
-
-route(Y)
-{
-   # handling calls to bridge to existing b2b calls
-   ...
-   # retrieving the key of a b2b call
-   cache_fetch("local","some_b2bl_key_identifier", $avp(98) );
-   $var(entity) = 1;
-   b2b_bridge_request("$avp(98)","$var(entity)");
-   ...
-}
-...
-
-1.5. Exported MI Functions
-
-1.5.1.  b2b_trigger_scenario
-
-   This command instantiated a B2B scenario.
-
-   Name: b2b_trigger_scenario
-
-   Parameters:
-     * senario_id : the id of the scenario to be instantiated.
-     * scenario parameters - it can take 4 more parameters that
-       are scenario parameters
-
-   MI FIFO Command Format:
-        :b2b_trigger_scenario:fifo_reply
-        marketing
-        sip:bob@opensips.org
-        sip:322@opensips.org:5070
-        sip:alice@opensips.org
-        _empty_line_
-
-1.5.2.  b2b_bridge
-
-   This command can be used by an external application to tell
-   B2BUA to bridge a call party from an on going dialog to another
-   destination. By default the caller is bridged to the new uri
-   and BYE is set to the callee. You can instead bridge the callee
-   if you send 1 as the third parameter.
-
-   Name: b2b_bridge
-
-   Parameters:
-     * dialog-id : the id of the dialog. If you set the module
-       parameter dialog-id the server will include the dialogid in
-       the generated Invites as the content of a header with name
-       'Dialog-ID'.
-     * new uri - the uri of the new destination
-     * flag to specify that the callee must be bridged to the new
-       destination. It is optional. If not present the caller will
-       be bridged.
-
-   MI FIFO Command Format:
-        :b2b_bridge:fifo_reply
-        1020.30
-        sip:alice@opensips.org
-        _empty_line_
-
-   opensipsctl Command Format:
-        opensipsctl b2b_bridge 1020.30 sip:alice@opensips.org
-
-1.5.3.  b2b_list
-
-   This command can be used to list the internals of b2b_logic
-   entities.
-
-   Name: b2b_list
-
-   Parameters: none
-
-   MI FIFO Command Format:
-        :b2b_list:_reply_fifo_file_
-        _empty_line_
-
-   opensipsctl Command Format:
-        opensipsctl fifo b2b_list
-
-Chapter 2. Developer Guide
-
-   The module provides an API that can be used from other OpenSIPS
-   modules. The API offers the functions for instantiating b2b
-   scenarios from other modules (this comes as an addition to the
-   other two means of instantiating b2b scenarios - from script
-   and with an MI command). Also the instantiations can be
-   dynamically controlled, by commanding the bridging of an entity
-   involved in a call to another entity or the termination of the
-   call or even bridging two existing calls.
-
-2.1.  b2b_logic_bind(b2bl_api_t* api)
-
-   This function binds the b2b_entities modules and fills the
-   structure the exported functions that will be described in
-   detail.
-
-   Example 2.1. b2bl_api_t structure
-...
-typedef struct b2bl_api
-{
-        b2bl_init_f init;
-        b2bl_bridge_f bridge;
-        b2bl_bridge_extern_f bridge_extern;
-        b2bl_bridge_2calls_t bridge_2calls;
-        b2bl_terminate_call_t terminate_call;
-        b2bl_set_state_f set_state;
-        b2bl_bridge_msg_t bridge_msg;
-}b2bl_api_t;
-...
-
-2.2.  init
-
-   Field type:
-...
-typedef str* (*b2bl_init_f)(struct sip_msg* msg, str* name, str* args[5]
-,
-                b2bl_cback_f, void* param);
-...
-
-   Initializing a b2b scenario. The last two parameters are the
-   callback function and the parameter to be called in 3
-   situations that will be listed below. The callback function has
-   the following definition:
-...
-typedef int (*b2b_notify_t)(struct sip_msg* msg, str* id, int type, void
-* param);
-...
-
-   The first argument is the callback given in the init function.
-
-   The second argument is a structure with some statistics about
-   the call -start time, setup time, call time.
-
-   The third argument is the current state of the scenario
-   instantiation.
-
-   The last argument is the event that triggered the callback.
-   There are 3 events when the callback is called:
-     * when a BYE is received from either side- event parameter
-       will also show from which side the BYE is received, so it
-       can be B2B_BYE_E1 or B2B_BYE_E2
-     * If while bridging, a negative reply is received from the
-       second entity - the event is B2B_REJECT_E2.
-     * When the b2b logic entity is deleted- the evnet is
-       B2B_DESTROY
-
-   The return code controls what will happen with the
-   request/reply that caused the event (except for the last event,
-   when the return code does not matter)
-     * -1 - error
-     * 0 - drop the BYE or reply
-     * 1 - send the BYE or reply on the other side
-     * 2 - do what the scenario tells, if no rule defined send the
-       BYE or reply on the other side
-
-2.3.  bridge
-
-   Field type:
-...
-typedef int (*b2bl_bridge_f)(str* key, str* new_uri, str* new_from_dname
-,int entity_type);
-...
-
-   This function allows bridging an entity that is in a call
-   handled by b2b_logic to another entity.
-
-2.4.  bridge_extern
-
-   Field type:
-...
-typedef str* (*b2bl_bridge_extern_f)(str* scenario_name, str* args[5],
-                b2bl_cback_f cbf, void* cb_param);
-...
-
-   This function allows initiating an extern scenario, when the
-   B2BUA starts a call from the middle.
-
-2.5.  bridge_2calls
-
-   Field type:
-...
-typedef int (*b2bl_bridge_2calls_t)(str* key1, str* key2);
-...
-
-   With this function it is possible to bridge two existing calls.
-   The first entity from the two calls will be connected and BYE
-   will be sent to their peers.
-
-2.6.  terminate_call
-
-   Field type:
-...
-typedef int (*b2bl_terminate_call_t)(str* key);
-...
-
-   Terminate a call.
-
-2.7.  set_state
-
-   Field type:
-...
-typedef int (*b2bl_set_state_f)(str* key, int state);
-...
-
-   Set the scenario state.
-
-2.8.  bridge_msg
-
-   Field type:
-...
-typedef int (*b2bl_bridge_msg_t)(struct sip_msg* msg, str* key, int enti
-ty_no);
-...
-
-   This function allows bridging an incoming call to an entity
-   from an existing call.
-
-   The first argument is the INVITE message of the current
-   incoming call.
-
-   The second argument is the b2bl_key of an existing call.
-
-   The third argument is the entity identifier.
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/records.c ./b2b_logic/records.c
--- ./trunk/src/opensips_1_7/modules/b2b_logic/records.c	2012-10-31 10:33:43.044947332 +0000
+++ ./b2b_logic/records.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,813 +0,0 @@
-/*
- * $Id: records.c 9097 2012-06-14 09:08:55Z bogdan_iancu $
- *
- * back-to-back logic module
- *
- * Copyright (C) 2009 Free Software Fundation
- *
- * This file is part of opensips, a free SIP server.
- *
- * opensips is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version
- *
- * opensips is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License 
- * along with this program; if not, write to the Free Software 
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * History:
- * --------
- *  2009-08-03  initial version (Anca Vamanu)
- */
-
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
-
-#include "../../mem/shm_mem.h"
-#include "../../ut.h"
-#include "../presence/hash.h"
-#include "../presence/utils_func.h"
-#include "records.h"
-
-static void _print_entity(int index, b2bl_entity_id_t* e, int log_level)
-{
-	b2bl_entity_id_t* c = e;
-
-	while (c)
-	{
-		LM_GEN1(log_level, ".type=[%d] index=[%d] [%p]->[%.*s] state=%d no=%d"
-			" dlginfo=[%p] peer=[%p] prev:next=[%p][%p]\n",
-			c->type, index, c, c->key.len, c->key.s, c->state, c->no,
-			c->dlginfo, c->peer, c->prev, c->next);
-		if (c->dlginfo)
-			LM_GEN1(log_level, "..........dlginfo=[%p]->[%.*s][%.*s][%.*s]\n",
-				c->dlginfo, c->dlginfo->callid.len, c->dlginfo->callid.s,
-				c->dlginfo->fromtag.len, c->dlginfo->fromtag.s,
-				c->dlginfo->totag.len, c->dlginfo->totag.s);
-		c = c->next;
-	}
-}
-
-void b2bl_print_tuple(b2bl_tuple_t* tuple, int log_level)
-{
-	int index;
-	b2bl_entity_id_t* e;
-
-	if(tuple)
-	{
-		LM_GEN1(log_level, "[%p]->[%.*s] to_del=[%d] lifetime=[%d]"
-			" bridge_entities[%p][%p][%p]\n",
-			tuple, tuple->key->len, tuple->key->s,
-			tuple->to_del, tuple->lifetime,
-			tuple->bridge_entities[0], tuple->bridge_entities[1],
-			tuple->bridge_entities[2]);
-		for (index = 0; index < MAX_B2BL_ENT; index++)
-		{
-			e = tuple->servers[index];
-			if (e) _print_entity(index, e, log_level);
-		}
-		for (index = 0; index < MAX_B2BL_ENT; index++)
-		{
-			e = tuple->clients[index];
-			if (e) _print_entity(index, e, log_level);
-		}
-		for (index = 0; index < MAX_BRIDGE_ENT; index++)
-		{
-			e = tuple->bridge_entities[index];
-			if (e)
-				LM_GEN1(log_level, ".type=[%d] index=[%d] [%p]"
-					" peer=[%p] prev:next=[%p][%p]\n",
-					e->type, index, e, e->peer, e->prev, e->next);
-		}
-	}
-}
-
-/* Function that inserts a new b2b_logic record - the lock remains taken */
-b2bl_tuple_t* b2bl_insert_new(struct sip_msg* msg,
-		unsigned int hash_index, b2b_scenario_t* scenario,
-		str* args[], str* body, str* custom_hdrs, int local_index,
-		str** b2bl_key_s, int db_flag)
-{
-	b2bl_tuple_t *it, *prev_it;
-	b2bl_tuple_t* tuple;
-	str* b2bl_key;
-	int i;
-	static char buf[256];
-	int buf_len= 255;
-	int size;
-	str extra_headers={0, 0};
-	str local_contact= server_address;
-
-	if(msg)
-	{
-		if(get_local_contact(msg->rcv.bind_address, &local_contact)< 0)
-		{
-			LM_ERR("Failed to get received address\n");
-			local_contact= server_address;
-		}
-	}
-
-	size = sizeof(b2bl_tuple_t) + local_contact.len;
-	if(body && (use_init_sdp || (scenario && scenario->use_init_sdp)))
-	{
-		size+= body->len;
-	}
-
-	tuple = (b2bl_tuple_t*)shm_malloc(size);
-	if(tuple == NULL)
-	{
-		LM_ERR("No more shared memory\n");
-		goto error;
-	}
-	memset(tuple, 0, size);
-
-	size = sizeof(b2bl_tuple_t);
-	if(body && (use_init_sdp || (scenario && scenario->use_init_sdp)))
-	{
-		tuple->sdp.s = (char*)tuple + sizeof(b2bl_tuple_t);
-		memcpy(tuple->sdp.s, body->s, body->len);
-		tuple->sdp.len =  body->len;
-		size += body->len;
-	}
-
-	tuple->local_contact.s = (char*)tuple + size;
-	memcpy(tuple->local_contact.s, local_contact.s, local_contact.len);
-	tuple->local_contact.len = local_contact.len;
-
-	tuple->scenario = scenario;
-
-	if(msg)
-	{
-		if(b2b_extra_headers(msg, NULL, custom_hdrs, &extra_headers)< 0)
-		{
-			LM_ERR("Failed to create extra headers\n");
-			goto error;
-		}
-		if(extra_headers.s)
-		{
-			tuple->extra_headers = (str*)shm_malloc(sizeof(str) + extra_headers.len);
-			if(tuple->extra_headers == NULL)
-			{
-				LM_ERR("No more shared memory\n");
-				goto error;
-			}
-			tuple->extra_headers->s = (char*)tuple->extra_headers + sizeof(str);
-			memcpy(tuple->extra_headers->s, extra_headers.s, extra_headers.len);
-			tuple->extra_headers->len = extra_headers.len;
-			pkg_free(extra_headers.s);
-		}
-	}
-
-	/* copy the function parameters that customize the scenario */
-	memset(tuple->scenario_params, 0, MAX_SCENARIO_PARAMS* sizeof(str));
-	if(scenario && args)
-	{
-		for(i = 0; i< scenario->param_no; i++)
-		{
-			if(args[i]==NULL)
-			{
-				LM_DBG("Fewer parameters, expected [%d] received [%d]\n",
-						scenario->param_no, i);
-				break;
-			}
-			/* must print the value of the argument */
-			if(msg && b2bl_caller != CALLER_MODULE)
-			{
-				buf_len= 255;
-				if(pv_printf(msg, (pv_elem_t*)args[i], buf, &buf_len)<0)
-				{
-					LM_ERR("cannot print the format\n");
-					goto error;
-				}
-
-				tuple->scenario_params[i].s = (char*)shm_malloc(buf_len);
-				if(tuple->scenario_params[i].s == NULL)
-				{
-					LM_ERR("No more shared memory\n");
-					goto error;
-				}
-				memcpy(tuple->scenario_params[i].s, buf, buf_len);
-				tuple->scenario_params[i].len = buf_len;
-				LM_DBG("Printed parameter [%.*s]\n", buf_len, buf);
-			}
-			else
-			{
-				if(args[i]->s==NULL || args[i]->len==0)
-				{
-					LM_DBG("Fewer parameters, expected [%d] received [%d]\n",
-							scenario->param_no, i);
-					break;
-				}
-
-				tuple->scenario_params[i].s = (char*)shm_malloc(args[i]->len);
-				if(tuple->scenario_params[i].s == NULL)
-				{
-					LM_ERR("No more shared memory\n");
-					goto error;
-				}
-				memcpy(tuple->scenario_params[i].s, args[i]->s, args[i]->len);
-				tuple->scenario_params[i].len = args[i]->len;
-			}
-		}
-	}
-	tuple->scenario_state = B2B_NOTDEF_STATE;
-
-	lock_get(&b2bl_htable[hash_index].lock);
-
-	if(local_index>= 0) /* a local index specified */ 
-	{
-		tuple->id = local_index;
-		if(b2bl_htable[hash_index].first == NULL)
-		{
-			b2bl_htable[hash_index].first = tuple;
-			tuple->prev = tuple->next = NULL;
-		}
-		else
-		{
-			prev_it = 0;
-			/*insert it in the proper place  */
-			for(it = b2bl_htable[hash_index].first; it && it->id<local_index; it=it->next)
-			{
-				prev_it = it;	
-			}
-			if(!prev_it)
-			{
-				b2bl_htable[hash_index].first = tuple;
-				tuple->prev = 0;
-				tuple->next = it;
-				it->prev = tuple;
-			}
-			else
-			{
-				tuple->prev = prev_it; 
-				prev_it->next = tuple;
-				tuple->next = it;
-				if(it)
-					it->prev = tuple;
-			}
-		}		
-	}
-	else
-	{
-
-		it = b2bl_htable[hash_index].first;
-		if(it == NULL)
-		{
-			b2bl_htable[hash_index].first = tuple;
-			tuple->prev = tuple->next = NULL;
-			tuple->id = 0;
-		}
-		else
-		{
-			while(it)
-			{
-				prev_it = it;
-				it = it->next;
-			}
-			prev_it->next = tuple;
-			tuple->prev = prev_it;
-			tuple->id = prev_it->id +1;
-		}
-	}
-	LM_DBG("hash index [%d]:\n", hash_index);
-	for(it = b2bl_htable[hash_index].first; it; it=it->next)
-	{
-		LM_DBG("id [%d]", it->id);	
-	}
-
-	b2bl_key = b2bl_generate_key(hash_index, tuple->id);
-	if(b2bl_key == NULL)
-	{
-		LM_ERR("failed to generate b2b logic key\n");
-		lock_release(&b2bl_htable[hash_index].lock);
-		return NULL;
-	}
-	tuple->key = b2bl_key;
-
-	*b2bl_key_s = b2bl_key;
-	tuple->db_flag = db_flag;
-
-	LM_DBG("new tuple [%p]->[%.*s]\n", tuple, b2bl_key->len, b2bl_key->s);
-
-	return tuple;
-error:
-	lock_release(&b2bl_htable[hash_index].lock);
-	return 0;
-}
-
-
-void unchain_ent(b2bl_entity_id_t *ent, b2bl_entity_id_t **first_ent)
-{
-	if(*first_ent == ent)
-	{
-		*first_ent = ent->next;
-		if(ent->next)
-			ent->next->prev = NULL;
-	}
-	else
-	{
-		if(ent->prev)
-			ent->prev->next = ent->next;
-		if(ent->next)
-			ent->next->prev = ent->prev;
-	}
-	ent->prev = NULL;
-	ent->next = NULL;
-}
-
-
-int b2bl_drop_entity(b2bl_entity_id_t* entity, b2bl_tuple_t* tuple)
-{
-	b2bl_entity_id_t* e;
-	unsigned int index;
-	int found = 0;
-
-	for (index = 0; index < MAX_B2BL_ENT; index++)
-	{
-		e = tuple->servers[index];
-		if (e == entity)
-		{
-			found = 1;
-			switch(index)
-			{
-				case 0:
-					tuple->servers[0] = tuple->servers[1];
-					tuple->servers[1] = NULL;
-					break;
-				case 1:
-					tuple->servers[1] = NULL;
-					if (tuple->servers[0] == NULL)
-						LM_ERR("inconsistent tuple [%p]->[%.*s]\n",
-							tuple, tuple->key->len, tuple->key->s);
-					break;
-				default:
-					LM_CRIT("we should never end up here\n");
-			}
-			break;
-		}
-		e = tuple->clients[index];
-		if (e == entity)
-		{
-			found = 1;
-			switch(index)
-			{
-				case 0:
-					tuple->clients[0] = tuple->clients[1];
-					tuple->clients[1] = NULL;
-					break;
-				case 1:
-					tuple->clients[1] = NULL;
-					if (tuple->clients[0] == NULL)
-						LM_ERR("inconsistent tuple [%p]->[%.*s]\n",
-							tuple, tuple->key->len, tuple->key->s);
-					break;
-				default:
-					LM_CRIT("we should never end up here\n");
-			}
-			break;
-		}
-	}
-	return found;
-}
-
-void b2bl_remove_single_entity(b2bl_entity_id_t *entity, b2bl_entity_id_t **head)
-{
-	unchain_ent(entity, head);
-	b2b_api.entity_delete(entity->type, &entity->key, entity->dlginfo, 0);
-	LM_DBG("destroying dlginfo=[%p]\n", entity->dlginfo);
-	if(entity->dlginfo)
-		shm_free(entity->dlginfo);
-	shm_free(entity);
-
-	return;
-}
-
-void b2bl_delete_entity(b2bl_entity_id_t* entity, b2bl_tuple_t* tuple)
-{
-	unsigned int i;
-	int found = 0;
-
-	if (entity->next || entity->prev)
-	{
-		LM_ERR("Inconsistent entity [%p]\n", entity);
-		b2bl_print_tuple(tuple, L_CRIT);
-		return;
-	}
-
-	found = b2bl_drop_entity(entity, tuple);
-
-	if(found)
-	{
-		LM_DBG("delete entity [%p]->[%.*s] from tuple [%.*s]\n",
-			entity, entity->key.len, entity->key.s, tuple->key->len, tuple->key->s);
-		b2b_api.entity_delete(entity->type, &entity->key, entity->dlginfo, 1);
-	}
-	else
-	{
-		LM_WARN("entity [%p]->[%.*s] not found for tuple [%.*s]\n",
-			entity, entity->key.len, entity->key.s, tuple->key->len, tuple->key->s);
-	}
-
-	if(entity->dlginfo)
-		shm_free(entity->dlginfo);
-
-	for(i = 0; i< MAX_BRIDGE_ENT; i++)
-		if(tuple->bridge_entities[i] == entity)
-			tuple->bridge_entities[i] = NULL;
-
-/*	if(entity->peer && entity->peer->peer==entity)
-		entity->peer->peer = NULL;
-*/
-
-	for(i = 0; i< MAX_B2BL_ENT; i++)
-	{
-		if(tuple->servers[i] && tuple->servers[i]->peer==entity)
-			tuple->servers[i]->peer= NULL;
-		if(tuple->clients[i] && tuple->clients[i]->peer==entity)
-			tuple->clients[i]->peer= NULL;
-	}
-
-	LM_INFO("delete tuple [%.*s], entity [%.*s]\n",
-			tuple->key->len, tuple->key->s, entity->key.len, entity->key.s);
-	shm_free(entity);
-
-	/* for debuging */
-	b2bl_print_tuple(tuple, L_DBG);
-}
-
-
-int b2bl_add_client(b2bl_tuple_t* tuple, b2bl_entity_id_t* entity)
-{
-	LM_INFO("adding entity [%p]->[%.*s] to tuple [%p]->[%.*s]\n",
-		entity, entity->key.len, entity->key.s,
-		tuple, tuple->key->len, tuple->key->s);
-
-	if (tuple->clients[0] == NULL)
-	{
-		if (tuple->clients[1])
-		{
-			LM_ERR("inconsistent clients state for tuple [%p]->[%.*s]\n",
-				tuple, tuple->key->len, tuple->key->s);
-			return -1;
-		}
-		tuple->clients[0] = entity;
-	}
-	else if (tuple->clients[1] == NULL)
-		tuple->clients[1] = entity;
-	else
-	{
-		LM_ERR("unable to add entity [%p]->[%.*s] to tuple [%p]->[%.*s], all spots taken\n",
-			entity, entity->key.len, entity->key.s,
-			tuple, tuple->key->len, tuple->key->s);
-		return -1;
-	}
-		
-	b2bl_print_tuple(tuple, L_DBG);
-	return 0;
-}
-
-
-int b2bl_add_server(b2bl_tuple_t* tuple, b2bl_entity_id_t* entity)
-{
-	LM_INFO("adding entity [%p]->[%.*s] to tuple [%p]->[%.*s]\n",
-		entity, entity->key.len, entity->key.s,
-		tuple, tuple->key->len, tuple->key->s);
-
-	if (tuple->servers[0] == NULL)
-	{
-		if (tuple->servers[1])
-		{
-			LM_ERR("inconsistent servers state for tuple [%p]->[%.*s]\n",
-				tuple, tuple->key->len, tuple->key->s);
-			return -1;
-		}
-		tuple->servers[0] = entity;
-	}
-	else if (tuple->servers[1] == NULL)
-		tuple->servers[1] = entity;
-	else
-	{
-		LM_ERR("unable to add entity [%p]->[%.*s] to tuple [%p]->[%.*s], all spots taken\n",
-			entity, entity->key.len, entity->key.s,
-			tuple, tuple->key->len, tuple->key->s);
-		return -1;
-	}
-		
-	b2bl_print_tuple(tuple, L_DBG);
-	return 0;
-}
-
-
-void b2bl_delete(b2bl_tuple_t* tuple, unsigned int hash_index,
-		int not_del_b2be)
-{
-	b2bl_entity_id_t *e;
-	int i;
-	int index;
-	b2bl_cb_params_t cb_params;
-
-	LM_DBG("Delete record [%p]->[%.*s], hash_index=[%d], local_index=[%d]\n",
-			tuple, tuple->key->len, tuple->key->s, hash_index, tuple->id);
-
-	if(tuple->cbf && tuple->cb_mask&B2B_DESTROY_CB)
-	{
-		memset(&cb_params, 0, sizeof(b2bl_cb_params_t));
-		cb_params.param = tuple->cb_param;
-		cb_params.stat = NULL;
-		cb_params.msg = NULL;
-		/* setting it to 0 but it has no meaning in this callback type */
-		cb_params.entity = 0;
-		tuple->cbf(&cb_params, B2B_DESTROY_CB);
-	}
-	if(!not_del_b2be)
-		b2bl_db_delete(tuple);
-	if(b2bl_htable[hash_index].first == tuple)
-	{
-		b2bl_htable[hash_index].first = tuple->next;
-		if(tuple->next)
-			tuple->next->prev = NULL;
-	}
-	else
-	{
-		if(tuple->prev)
-			tuple->prev->next = tuple->next;
-		if(tuple->next)
-			tuple->next->prev = tuple->prev;
-	}
-
-	for (index = 0; index < MAX_B2BL_ENT; index++)
-	{
-		e = tuple->servers[index];
-		if (e)
-		{
-			if (e->key.s && e->key.len && !not_del_b2be)
-				b2b_api.entity_delete(e->type, &e->key, e->dlginfo, 0);
-			if(e->dlginfo)
-				shm_free(e->dlginfo);
-			shm_free(e);
-		}
-		e = tuple->clients[index];
-		if (e)
-		{
-			if (e->key.s && e->key.len && !not_del_b2be)
-				b2b_api.entity_delete(e->type, &e->key, e->dlginfo, 0);
-			if(e->dlginfo)
-				shm_free(e->dlginfo);
-			shm_free(e);
-		}
-	}
-	/* clean up all entities in b2b_entities from db */
-	if(!not_del_b2be)
-		b2b_api.entities_db_delete(*tuple->key);
-
-//	if(tuple->bridge_entities[1] && tuple->bridge_entities[1]->key.s != NULL)
-//		shm_free(tuple->bridge_entities[1]->key.s);
-
-	for(i = 0; i< MAX_SCENARIO_PARAMS; i++)
-	{
-		if(tuple->scenario_params[i].s)
-			shm_free(tuple->scenario_params[i].s);
-	}
-
-	if(tuple->key)
-		shm_free(tuple->key);
-
-	if(tuple->extra_headers)
-		shm_free(tuple->extra_headers);
-
-	if(tuple->b1_sdp.s)
-		shm_free(tuple->b1_sdp.s);
-
-	shm_free(tuple);
-}
-
-/* key format : hash_index.local *
- */
-
-int b2bl_parse_key(str* key, unsigned int* hash_index,
-		unsigned int* local_index)
-{
-	char* p;
-	int hi_len;
-	str s;
-
-	if(!key || !key->s || !key->len)
-		return -1;
-
-	p= strchr(key->s, '.');
-	if(p == NULL)
-	{
-		LM_ERR("Wrong b2b logic key\n");
-		return -1;
-	}
-
-	hi_len = p - key->s;
-	s.s = key->s;
-	s.len = hi_len;
-	if(str2int(&s, hash_index)< 0)
-		return -1;
-	
-	s.s = p+1;
-	s.len = key->s + key->len - s.s;
-	if(str2int(&s, local_index)< 0)
-		return -1;
-
-	LM_DBG("hash_index = [%d]  - local_index= [%d]\n", *hash_index, *local_index);
-	return 0;
-}
-
-
-str* b2bl_generate_key(unsigned int hash_index, unsigned int local_index)
-{
-	char buf[15];
-	str* b2b_key;
-	int len;
-
-	len = sprintf(buf, "%d.%d", hash_index, local_index);
-
-	b2b_key = (str*)shm_malloc(sizeof(str)+ len);
-	if(b2b_key== NULL)
-	{
-		LM_ERR("no more shared memory\n");
-		return NULL;
-	}
-	b2b_key->s = (char*)b2b_key + sizeof(str);
-	memcpy(b2b_key->s, buf, len);
-	b2b_key->len = len;
-
-	return b2b_key;
-}
-
-b2bl_tuple_t* b2bl_search_tuple_safe(unsigned int hash_index, unsigned int local_index)
-{
-	b2bl_tuple_t* tuple;
-
-
-	tuple = b2bl_htable[hash_index].first;
-	while(tuple && tuple->id != local_index)
-	{
-		tuple = tuple->next;
-	}
-
-	return tuple;
-}
-
-int init_b2bl_htable(void)
-{
-	int i;
-	b2bl_htable = (b2bl_table_t)shm_malloc(b2bl_hsize* sizeof(b2bl_entry_t));
-	if(!b2bl_htable)
-		ERR_MEM(SHARE_MEM);
-	
-	memset(b2bl_htable, 0, b2bl_hsize* sizeof(b2bl_entry_t));
-	for(i= 0; i< b2bl_hsize; i++)
-	{
-		lock_init(&b2bl_htable[i].lock);
-		b2bl_htable[i].first = NULL;
-	}
-
-	return 0;
-error:
-	return -1;
-}
-
-void destroy_b2bl_htable(void)
-{
-	int i;
-	b2bl_tuple_t* tuple;
-
-	if(!b2bl_htable)
-		return;
-
-	for(i= 0; i< b2bl_hsize; i++)
-	{
-		lock_destroy(&b2bl_htable[i].lock);
-		tuple = b2bl_htable[i].first;
-
-		while(tuple)
-		{
-			b2bl_delete(tuple, i, 1);
-			tuple = b2bl_htable[i].first;
-		}
-	}
-	shm_free(b2bl_htable);
-}
-
-/* Take headers to pass on the other side:
- *	Content-Type: 
- *	Allow: 
- *	Supported:
- *	Require
- *	RSeq
- *	Session-Expires
- *	Min-SE
-*/
-int b2b_extra_headers(struct sip_msg* msg, str* b2bl_key, str* custom_hdrs, str* extra_headers)
-{
-	char* p;
-	struct hdr_field* require_hdr;
-	struct hdr_field* rseq_hdr;
-	struct hdr_field* subscription_state_hdr;
-	struct hdr_field* hdr;
-	struct hdr_field* hdrs[HDR_LST_LEN + HDR_DEFAULT_LEN];
-	int hdrs_no = 0;
-	int len = 0;
-	int i;
-	int custom_hdrs_len = 0;
-
-	if(msg->content_type)
-		hdrs[hdrs_no++] = msg->content_type;
-	if(msg->supported)
-		hdrs[hdrs_no++] = msg->supported;
-	if(msg->allow)
-		hdrs[hdrs_no++] = msg->allow;
-	if(msg->proxy_require)
-		hdrs[hdrs_no++] = msg->proxy_require;
-	if(msg->session_expires)
-		hdrs[hdrs_no++] = msg->session_expires;
-	if(msg->min_se)
-		hdrs[hdrs_no++] = msg->min_se;
-	if(msg->event)
-		hdrs[hdrs_no++] = msg->event;
-	
-
-	require_hdr = get_header_by_static_name( msg, "Require");
-	if(require_hdr)
-		hdrs[hdrs_no++] = require_hdr;
-
-	rseq_hdr = get_header_by_static_name( msg, "RSeq");
-	if(rseq_hdr)
-		hdrs[hdrs_no++] = rseq_hdr;
-
-	subscription_state_hdr = get_header_by_static_name( msg, "Subscription-state");
-	if(subscription_state_hdr)
-		hdrs[hdrs_no++] = subscription_state_hdr;
-
-	/* add also the custom headers */
-	for(i = 0; i< custom_headers_lst_len; i++)
-	{
-		hdr = get_header_by_name( msg, custom_headers_lst[i].s,
-				custom_headers_lst[i].len);
-		if(hdr)
-		{
-			hdrs[hdrs_no++] = hdr;
-		}
-	}
-
-	/* calculate the length*/
-	for(i = 0; i< hdrs_no; i++)
-		len += hdrs[i]->len;
-
-	if(init_callid_hdr.len && msg && msg->callid)
-		len+= init_callid_hdr.len + msg->callid->len;
-
-	if(custom_hdrs && custom_hdrs->s && custom_hdrs->len)
-	{
-		custom_hdrs_len = custom_hdrs->len;
-		len += custom_hdrs_len;
-	}
-
-	if(len == 0) return 0;
-
-	extra_headers->s = (char*)pkg_malloc(len);
-	if(extra_headers->s == NULL)
-	{
-		LM_ERR("No more memory\n");
-		return -1;
-	}
-
-	p = extra_headers->s;
-
-	/* construct the headers string */
-	for(i = 0; i< hdrs_no; i++)
-	{
-		memcpy(p, hdrs[i]->name.s, hdrs[i]->len);
-		p += hdrs[i]->len;
-	}
-	if(custom_hdrs_len)
-	{
-		memcpy(p, custom_hdrs->s, custom_hdrs_len);
-		p += custom_hdrs_len;
-	}
-
-	if(init_callid_hdr.s && msg && msg->callid)
-	{
-		memcpy(p, init_callid_hdr.s, init_callid_hdr.len);
-		p += init_callid_hdr.len;
-		len = sprintf(p, ": %.*s",
-			(int)(msg->callid->name.s +msg->callid->len -msg->callid->body.s),
-			msg->callid->body.s);
-		p += len;
-	}
-
-	extra_headers->len = p - extra_headers->s;
-
-	return 0;
-}
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/records.h ./b2b_logic/records.h
--- ./trunk/src/opensips_1_7/modules/b2b_logic/records.h	2012-10-31 10:33:43.052947337 +0000
+++ ./b2b_logic/records.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,155 +0,0 @@
-/*
- * $Id: records.h 8626 2011-12-16 01:17:38Z osas $
- *
- * back-to-back logic module
- *
- * Copyright (C) 2009 Free Software Fundation
- *
- * This file is part of opensips, a free SIP server.
- *
- * opensips is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version
- *
- * opensips is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License 
- * along with this program; if not, write to the Free Software 
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * History:
- * --------
- *  2009-08-03  initial version (Anca Vamanu)
- */
-
-#ifndef _B2BL_RECORDS_H
-#define _B2BL_RECORDS_H
-
-#include <libxml/parser.h>
-#include <stdlib.h>
-#include "../../str.h"
-#include "../../lock_ops.h"
-#include "b2b_logic.h"
-#include "b2b_load.h"
-
-typedef struct b2bl_entity_id
-{
-	str scenario_id;
-	str key;
-	str to_uri;
-	str from_uri;
-	str from_dname;
-	b2b_dlginfo_t* dlginfo;
-	int disconnected;
-	int state;
-	int no;
-	enum b2b_entity_type type;
-	b2bl_dlg_stat_t stats;
-	struct b2bl_entity_id* peer;
-	struct b2bl_entity_id* prev;
-	struct b2bl_entity_id* next;
-}b2bl_entity_id_t;
-
-#define NO_UPDATEDB_FLAG    0
-#define UPDATEDB_FLAG       1
-#define INSERTDB_FLAG       2
-
-#define MAX_B2BL_ENT		2
-#define MAX_BRIDGE_ENT		3
-#define MAX_SCENARIO_PARAMS	5
-
-typedef struct b2bl_tuple
-{
-	unsigned int id;
-	str* key;
-	b2b_scenario_t* scenario;  /* if scenario is NULL it means that the simple Topology Hiding Scenary must be applied*/
-	str scenario_params[MAX_SCENARIO_PARAMS];
-	int scenario_state;
-	int next_scenario_state;
-	b2bl_entity_id_t* servers[MAX_B2BL_ENT];
-	b2bl_entity_id_t* clients[MAX_B2BL_ENT];
-	b2bl_entity_id_t* bridge_entities[MAX_BRIDGE_ENT];
-	int to_del;
-	str* extra_headers;
-	struct b2bl_tuple* next;
-	struct b2bl_tuple* prev;
-	unsigned int lifetime;
-	str local_contact;
-	str sdp;
-	str b1_sdp; /* used for multiple attempts to bridge the first entity */
-	int db_flag;
-	b2bl_cback_f cbf;
-	unsigned int cb_mask;
-	void* cb_param;
-}b2bl_tuple_t;
-
-typedef struct b2bl_entry
-{
-	b2bl_tuple_t* first;
-	gen_lock_t lock;
-}b2bl_entry_t;
-
-typedef b2bl_entry_t* b2bl_table_t;
-
-
-#define PREP_REQ_DATA(entity) do{		\
-	req_data.et =(entity)->type;		\
-	req_data.b2b_key =&(entity)->key;	\
-	req_data.dlginfo =(entity)->dlginfo;	\
-}while(0)
-
-#define PREP_RPL_DATA(entity) do{		\
-	rpl_data.et =(entity)->type;		\
-	rpl_data.b2b_key =&(entity)->key;	\
-	rpl_data.dlginfo =(entity)->dlginfo;	\
-}while(0)
-
-
-void b2bl_print_tuple(b2bl_tuple_t* tuple, int log_level);
-
-b2bl_tuple_t* b2bl_insert_new(struct sip_msg* msg,
-		unsigned int hash_index, b2b_scenario_t* scenario,
-		str* args[], str* body, str* custom_hdrs, int local_index,
-		str** b2bl_key_s, int db_flag);
-
-str* b2bl_generate_key(unsigned int hash_index, unsigned int local_index);
-
-int b2bl_parse_key(str* key, unsigned int* hash_index,
-		unsigned int* local_index);
-
-b2bl_tuple_t* b2bl_search_tuple_safe(unsigned int hash_index,
-		unsigned int local_index);
-
-void b2bl_delete(b2bl_tuple_t* tuple, unsigned int hash_index,
-		int not_del_b2be);
-
-int init_b2bl_htable(void);
-
-extern b2bl_table_t b2bl_htable;
-extern unsigned int b2bl_hsize;
-
-int process_bridge_action(struct sip_msg* msg, b2bl_entity_id_t* curr_entity,
-		b2bl_tuple_t* tuple, xmlNodePtr bridge_node);
-
-void destroy_b2bl_htable(void);
-
-b2bl_entity_id_t* b2bl_create_new_entity(enum b2b_entity_type type, str* entity_id,
-		str* to_uri,str* from_uri,str* from_dname,str* ssid,struct sip_msg* msg);
-
-void unchain_ent(b2bl_entity_id_t *ent, b2bl_entity_id_t **head);
-void b2bl_remove_single_entity(b2bl_entity_id_t *entity, b2bl_entity_id_t **head);
-int b2bl_drop_entity(b2bl_entity_id_t* entity, b2bl_tuple_t* tuple);
-void b2bl_delete_entity(b2bl_entity_id_t* entity, b2bl_tuple_t* tuple);
-
-int b2b_extra_headers(struct sip_msg* msg, str* b2bl_key, str* custom_hdrs, str* extra_headers);
-
-int b2bl_add_client(b2bl_tuple_t* tuple, b2bl_entity_id_t* entity);
-int b2bl_add_server(b2bl_tuple_t* tuple, b2bl_entity_id_t* entity);
-
-void b2bl_db_delete(b2bl_tuple_t* tuple);
-
-#endif
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/all-wcprops ./b2b_logic/.svn/all-wcprops
--- ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/all-wcprops	2012-10-31 10:33:43.008947317 +0000
+++ ./b2b_logic/.svn/all-wcprops	1970-01-01 01:00:00.000000000 +0100
@@ -1,77 +0,0 @@
-K 25
-svn:wc:ra_dav:version-url
-V 62
-/svnroot/opensips/!svn/ver/9327/branches/1.7/modules/b2b_logic
-END
-records.c
-K 25
-svn:wc:ra_dav:version-url
-V 72
-/svnroot/opensips/!svn/ver/9097/branches/1.7/modules/b2b_logic/records.c
-END
-b2b_logic.c
-K 25
-svn:wc:ra_dav:version-url
-V 74
-/svnroot/opensips/!svn/ver/8863/branches/1.7/modules/b2b_logic/b2b_logic.c
-END
-pidf.c
-K 25
-svn:wc:ra_dav:version-url
-V 69
-/svnroot/opensips/!svn/ver/8371/branches/1.7/modules/b2b_logic/pidf.c
-END
-b2bl_db.c
-K 25
-svn:wc:ra_dav:version-url
-V 72
-/svnroot/opensips/!svn/ver/9327/branches/1.7/modules/b2b_logic/b2bl_db.c
-END
-records.h
-K 25
-svn:wc:ra_dav:version-url
-V 72
-/svnroot/opensips/!svn/ver/8626/branches/1.7/modules/b2b_logic/records.h
-END
-b2b_logic.h
-K 25
-svn:wc:ra_dav:version-url
-V 74
-/svnroot/opensips/!svn/ver/8863/branches/1.7/modules/b2b_logic/b2b_logic.h
-END
-pidf.h
-K 25
-svn:wc:ra_dav:version-url
-V 69
-/svnroot/opensips/!svn/ver/8371/branches/1.7/modules/b2b_logic/pidf.h
-END
-b2b_load.h
-K 25
-svn:wc:ra_dav:version-url
-V 73
-/svnroot/opensips/!svn/ver/8371/branches/1.7/modules/b2b_logic/b2b_load.h
-END
-b2bl_db.h
-K 25
-svn:wc:ra_dav:version-url
-V 72
-/svnroot/opensips/!svn/ver/8371/branches/1.7/modules/b2b_logic/b2bl_db.h
-END
-Makefile
-K 25
-svn:wc:ra_dav:version-url
-V 71
-/svnroot/opensips/!svn/ver/8164/branches/1.7/modules/b2b_logic/Makefile
-END
-README
-K 25
-svn:wc:ra_dav:version-url
-V 69
-/svnroot/opensips/!svn/ver/8164/branches/1.7/modules/b2b_logic/README
-END
-logic.c
-K 25
-svn:wc:ra_dav:version-url
-V 70
-/svnroot/opensips/!svn/ver/9053/branches/1.7/modules/b2b_logic/logic.c
-END
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/dir-prop-base ./b2b_logic/.svn/dir-prop-base
--- ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/dir-prop-base	2012-10-31 10:33:43.004947266 +0000
+++ ./b2b_logic/.svn/dir-prop-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,8 +0,0 @@
-K 10
-svn:ignore
-V 13
-*.o
-*.d
-*.so
-
-END
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/entries ./b2b_logic/.svn/entries
--- ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/entries	2012-10-31 10:33:43.004947266 +0000
+++ ./b2b_logic/.svn/entries	1970-01-01 01:00:00.000000000 +0100
@@ -1,439 +0,0 @@
-10
-
-dir
-9400
-https://opensips.svn.sourceforge.net/svnroot/opensips/branches/1.7/modules/b2b_logic
-https://opensips.svn.sourceforge.net/svnroot/opensips
-
-
-
-2012-10-15T13:07:57.542611Z
-9327
-osas
-has-props
-
-
-
-
-
-
-
-
-
-
-
-
-
-689a6050-402a-0410-94f2-e92a70836424
-
-records.c
-file
-
-
-
-
-2012-10-30T18:03:15.000000Z
-77fb7a124f6230f11fdb2d07514c1ddd
-2012-06-14T09:08:55.155707Z
-9097
-bogdan_iancu
-has-props
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-18687
-
-b2b_logic.c
-file
-
-
-
-
-2012-10-30T18:03:15.000000Z
-0a01365c164c7082cdcf6aad4cd2cb72
-2012-03-27T08:04:29.725685Z
-8863
-vladut-paiu
-has-props
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-38660
-
-pidf.c
-file
-
-
-
-
-2012-10-30T18:03:15.000000Z
-fbd7c3f632ab9f1c95bf5b203a6a06be
-2011-09-13T22:31:47.081012Z
-8371
-osas
-has-props
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-2564
-
-doc
-dir
-
-b2bl_db.c
-file
-
-
-
-
-2012-10-30T18:03:15.000000Z
-4ca784938041866126fa484a62c455f8
-2012-10-15T13:07:57.542611Z
-9327
-osas
-has-props
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-19567
-
-records.h
-file
-
-
-
-
-2012-10-30T18:03:15.000000Z
-eef3853a041affcca457d578f4756341
-2011-12-16T01:17:38.411909Z
-8626
-osas
-has-props
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-4408
-
-b2b_logic.h
-file
-
-
-
-
-2012-10-30T18:03:15.000000Z
-de9f5fa646ba14f3b83f798a72d331ec
-2012-03-27T08:04:29.725685Z
-8863
-vladut-paiu
-has-props
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-3921
-
-pidf.h
-file
-
-
-
-
-2012-10-30T18:03:15.000000Z
-44959ca136a679f545a4a62e633ea566
-2011-09-13T22:31:47.081012Z
-8371
-osas
-has-props
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-1348
-
-b2b_load.h
-file
-
-
-
-
-2012-10-30T18:03:15.000000Z
-dff2221c6c666c6242fb79558c72211e
-2011-09-13T22:31:47.081012Z
-8371
-osas
-has-props
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-4045
-
-b2bl_db.h
-file
-
-
-
-
-2012-10-30T18:03:15.000000Z
-af3678b26a09e3ccff05bc09466a909b
-2011-09-13T22:31:47.081012Z
-8371
-osas
-has-props
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-1192
-
-Makefile
-file
-
-
-
-
-2012-10-30T18:03:15.000000Z
-220cfa7c56916ac61394938a22778f8b
-2009-10-12T19:00:53.200804Z
-6253
-bogdan_iancu
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-386
-
-README
-file
-
-
-
-
-2012-10-30T18:03:15.000000Z
-911ef36dd47f2030dd32d8c9b2d22dfd
-2011-07-12T15:54:30.021557Z
-8160
-bogdan_iancu
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-17339
-
-logic.c
-file
-
-
-
-
-2012-10-30T18:03:15.000000Z
-63f95901a13a40b07f7e8e814fb9f8c5
-2012-05-25T18:43:05.246537Z
-9053
-anca_vamanu
-has-props
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-103710
-
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/prop-base/b2bl_db.c.svn-base ./b2b_logic/.svn/prop-base/b2bl_db.c.svn-base
--- ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/prop-base/b2bl_db.c.svn-base	2012-10-31 10:33:42.897197254 +0000
+++ ./b2b_logic/.svn/prop-base/b2bl_db.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-K 12
-svn:keywords
-V 16
-Id Revision Date
-END
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/prop-base/b2bl_db.h.svn-base ./b2b_logic/.svn/prop-base/b2bl_db.h.svn-base
--- ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/prop-base/b2bl_db.h.svn-base	2012-10-31 10:33:42.941197138 +0000
+++ ./b2b_logic/.svn/prop-base/b2bl_db.h.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-K 12
-svn:keywords
-V 16
-Id Revision Date
-END
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/prop-base/b2b_load.h.svn-base ./b2b_logic/.svn/prop-base/b2b_load.h.svn-base
--- ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/prop-base/b2b_load.h.svn-base	2012-10-31 10:33:42.913197256 +0000
+++ ./b2b_logic/.svn/prop-base/b2b_load.h.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-K 12
-svn:keywords
-V 16
-Id Revision Date
-END
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/prop-base/b2b_logic.c.svn-base ./b2b_logic/.svn/prop-base/b2b_logic.c.svn-base
--- ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/prop-base/b2b_logic.c.svn-base	2012-10-31 10:33:42.897197254 +0000
+++ ./b2b_logic/.svn/prop-base/b2b_logic.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-K 12
-svn:keywords
-V 16
-Id Revision Date
-END
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/prop-base/b2b_logic.h.svn-base ./b2b_logic/.svn/prop-base/b2b_logic.h.svn-base
--- ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/prop-base/b2b_logic.h.svn-base	2012-10-31 10:33:42.909197135 +0000
+++ ./b2b_logic/.svn/prop-base/b2b_logic.h.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-K 12
-svn:keywords
-V 16
-Id Revision Date
-END
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/prop-base/logic.c.svn-base ./b2b_logic/.svn/prop-base/logic.c.svn-base
--- ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/prop-base/logic.c.svn-base	2012-10-31 10:33:42.996947339 +0000
+++ ./b2b_logic/.svn/prop-base/logic.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-K 12
-svn:keywords
-V 16
-Id Revision Date
-END
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/prop-base/pidf.c.svn-base ./b2b_logic/.svn/prop-base/pidf.c.svn-base
--- ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/prop-base/pidf.c.svn-base	2012-10-31 10:33:42.897197254 +0000
+++ ./b2b_logic/.svn/prop-base/pidf.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-K 12
-svn:keywords
-V 16
-Id Revision Date
-END
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/prop-base/pidf.h.svn-base ./b2b_logic/.svn/prop-base/pidf.h.svn-base
--- ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/prop-base/pidf.h.svn-base	2012-10-31 10:33:42.913197256 +0000
+++ ./b2b_logic/.svn/prop-base/pidf.h.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-K 12
-svn:keywords
-V 16
-Id Revision Date
-END
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/prop-base/records.c.svn-base ./b2b_logic/.svn/prop-base/records.c.svn-base
--- ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/prop-base/records.c.svn-base	2012-10-31 10:33:42.893197290 +0000
+++ ./b2b_logic/.svn/prop-base/records.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-K 12
-svn:keywords
-V 16
-Id Revision Date
-END
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/prop-base/records.h.svn-base ./b2b_logic/.svn/prop-base/records.h.svn-base
--- ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/prop-base/records.h.svn-base	2012-10-31 10:33:42.901210679 +0000
+++ ./b2b_logic/.svn/prop-base/records.h.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-K 12
-svn:keywords
-V 16
-Id Revision Date
-END
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/text-base/b2bl_db.c.svn-base ./b2b_logic/.svn/text-base/b2bl_db.c.svn-base
--- ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/text-base/b2bl_db.c.svn-base	2012-10-31 10:33:42.869204703 +0000
+++ ./b2b_logic/.svn/text-base/b2bl_db.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,647 +0,0 @@
-/*
- * $Id$
- *
- * back-to-back logic module
- *
- * Copyright (C) 2011 Free Software Fundation
- *
- * This file is part of opensips, a free SIP server.
- *
- * opensips is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version
- *
- * opensips is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License 
- * along with this program; if not, write to the Free Software 
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * History:
- * --------
- *  2011-04-04  initial version (Anca Vamanu)
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-
-#include "../../db/db.h"
-#include "b2b_logic.h"
-#include "b2bl_db.h"
-
-#define B2BL_FETCH_SIZE  128
-static str str_key_col         = str_init("si_key");
-static str str_scenario_col    = str_init("scenario");
-static str str_sparam0_col     = str_init("sparam0");
-static str str_sparam1_col     = str_init("sparam1");
-static str str_sparam2_col     = str_init("sparam2");
-static str str_sparam3_col     = str_init("sparam3");
-static str str_sparam4_col     = str_init("sparam4");
-static str str_sdp_col         = str_init("sdp");
-static str str_sstate_col      = str_init("sstate");
-static str str_next_sstate_col = str_init("next_sstate");
-static str str_lifetime_col    = str_init("lifetime");
-static str str_e1_type_col     = str_init("e1_type");
-static str str_e1_sid_col      = str_init("e1_sid");
-static str str_e1_to_col       = str_init("e1_to");
-static str str_e1_from_col     = str_init("e1_from");
-static str str_e1_key_col      = str_init("e1_key");
-static str str_e2_type_col     = str_init("e2_type");
-static str str_e2_sid_col      = str_init("e2_sid");
-static str str_e2_to_col       = str_init("e2_to");
-static str str_e2_from_col     = str_init("e2_from");
-static str str_e2_key_col      = str_init("e2_key");
-static str str_e3_type_col     = str_init("e3_type");
-static str str_e3_sid_col      = str_init("e3_sid");
-static str str_e3_to_col       = str_init("e3_to");
-static str str_e3_from_col     = str_init("e3_from");
-static str str_e3_key_col      = str_init("e3_key");
-
-#define DB_COLS_NO  26
-static db_key_t qcols[DB_COLS_NO];
-static db_val_t qvals[DB_COLS_NO];
-static int n_query_update;
-
-/* initialize the column names and vals type -> take care always to keep this order */
-void b2bl_db_init(void)
-{
-	memset(qvals, 0, DB_COLS_NO* sizeof(db_val_t));
-
-	qcols[0]      = &str_key_col;
-	qvals[0].type = DB_STR;
-	qcols[1]      = &str_scenario_col;
-	qvals[1].type = DB_STR;
-	qcols[2]      = &str_sparam0_col;
-	qvals[2].type = DB_STR;
-	qcols[3]      = &str_sparam1_col;
-	qvals[3].type = DB_STR;
-	qcols[4]      = &str_sparam2_col;
-	qvals[4].type = DB_STR;
-	qcols[5]      = &str_sparam3_col;
-	qvals[5].type = DB_STR;
-	qcols[6]      = &str_sparam4_col;
-	qvals[6].type = DB_STR;
-	qcols[7]      = &str_sdp_col;
-	qvals[7].type = DB_STR;
-	n_query_update= 8;
-	qcols[8]      = &str_sstate_col;
-	qvals[8].type = DB_INT;
-	qcols[9]      = &str_next_sstate_col;
-	qvals[9].type = DB_INT;
-	qcols[10]     = &str_lifetime_col;
-	qvals[10].type= DB_INT;
-	qcols[11]     = &str_e1_type_col;
-	qvals[11].type= DB_INT;
-	qcols[12]     = &str_e1_sid_col;
-	qvals[12].type= DB_STR;
-	qcols[13]     = &str_e1_to_col;
-	qvals[13].type= DB_STR;
-	qcols[14]     = &str_e1_from_col;
-	qvals[14].type= DB_STR;
-	qcols[15]     = &str_e1_key_col;
-	qvals[15].type= DB_STR;
-	qcols[16]     = &str_e2_type_col;
-	qvals[16].type= DB_INT;
-	qcols[17]     = &str_e2_sid_col;
-	qvals[17].type= DB_STR;
-	qcols[18]     = &str_e2_to_col;
-	qvals[18].type= DB_STR;
-	qcols[19]     = &str_e2_from_col;
-	qvals[19].type= DB_STR;
-	qcols[20]     = &str_e2_key_col;
-	qvals[20].type= DB_STR;
-	qcols[21]     = &str_e3_type_col;
-	qvals[21].type= DB_INT;
-	qcols[22]     = &str_e3_sid_col;
-	qvals[22].type= DB_STR;
-	qcols[23]     = &str_e3_to_col;
-	qvals[23].type= DB_STR;
-	qcols[24]     = &str_e3_from_col;
-	qvals[24].type= DB_STR;
-	qcols[25]     = &str_e3_key_col;
-	qvals[25].type= DB_STR;
-}
-
-void b2bl_db_delete(b2bl_tuple_t* tuple)
-{
-	if(!tuple || !tuple->key || b2bl_db_mode==NO_DB ||
-		(b2bl_db_mode==WRITE_BACK && tuple->db_flag==INSERTDB_FLAG))
-		return;
-
-	LM_DBG("Delete key = %.*s\n", tuple->key->len, tuple->key->s);
-
-	if(b2bl_dbf.use_table(b2bl_db, &b2bl_dbtable)< 0)
-	{
-		LM_ERR("sql use table failed\n");
-		return;
-	}
-
-	qvals[0].val.str_val = *tuple->key;
-
-	if(b2bl_dbf.delete(b2bl_db, qcols, 0, qvals, 1) < 0)
-	{
-		LM_ERR("Failed to delete from database table [%.*s]\n",
-				tuple->key->len, tuple->key->s);
-	}
-}
-
-void b2b_logic_dump(int no_lock)
-{
-	b2bl_tuple_t* tuple;
-	int i;
-	int n_insert_cols;
-
-	if(b2bl_dbf.use_table(b2bl_db, &b2bl_dbtable)< 0)
-	{
-		LM_ERR("sql use table failed\n");
-		return;
-	}
-
-	for(i = 0; i< b2bl_hsize; i++)
-	{
-		if(!no_lock)
-			lock_get(&b2bl_htable[i].lock);
-		tuple = b2bl_htable[i].first;
-		while(tuple)
-		{
-			/* check the state of the scenario instantiation */
-			if(tuple->db_flag == NO_UPDATEDB_FLAG)
-				goto next;
-
-			if(tuple->key == NULL)
-			{
-				LM_ERR("No key stored\n");
-				goto next;
-			}
-			if(tuple->bridge_entities[0]==NULL || tuple->bridge_entities[1]== NULL)
-			{
-				LM_ERR("Bridge entities is NULL\n");
-				if(tuple->bridge_entities[0]==NULL)
-					LM_DBG("0 NULL\n");
-				else
-					LM_DBG("1 NULL\n");
-				goto next;
-			}
-
-			qvals[0].val.str_val = *tuple->key;
-			if(tuple->db_flag == INSERTDB_FLAG)
-			{
-				if(tuple->scenario)
-					qvals[1].val.str_val = tuple->scenario->id;
-				else{
-					qvals[1].val.str_val.len = 0;
-					qvals[1].val.str_val.s = "";
-				}
-
-				qvals[2].val.str_val = tuple->scenario_params[0];
-				qvals[3].val.str_val = tuple->scenario_params[1];
-				qvals[4].val.str_val = tuple->scenario_params[2];
-				qvals[5].val.str_val = tuple->scenario_params[3];
-				qvals[6].val.str_val = tuple->scenario_params[4];
-				qvals[7].val.str_val = tuple->sdp;
-			}
-
-
-			qvals[8].val.int_val  = tuple->scenario_state;
-			qvals[9].val.int_val  = tuple->next_scenario_state;
-			qvals[10].val.int_val = tuple->lifetime - get_ticks() + (int)time(NULL);
-			qvals[11].val.int_val = tuple->bridge_entities[0]->type;
-			qvals[12].val.str_val = tuple->bridge_entities[0]->scenario_id;
-			qvals[13].val.str_val = tuple->bridge_entities[0]->to_uri;
-			qvals[14].val.str_val = tuple->bridge_entities[0]->from_uri;
-			qvals[15].val.str_val = tuple->bridge_entities[0]->key;
-			qvals[16].val.int_val = tuple->bridge_entities[1]->type;
-			qvals[17].val.str_val = tuple->bridge_entities[1]->scenario_id;
-			qvals[18].val.str_val = tuple->bridge_entities[1]->to_uri;
-			qvals[19].val.str_val = tuple->bridge_entities[1]->from_uri;
-			qvals[20].val.str_val = tuple->bridge_entities[1]->key;
-
-			n_insert_cols = 21;
-
-			if(tuple->bridge_entities[2])
-			{
-				qvals[21].val.int_val = tuple->bridge_entities[2]->type;
-				qvals[22].val.str_val = tuple->bridge_entities[2]->scenario_id;
-				qvals[23].val.str_val = tuple->bridge_entities[2]->to_uri;
-				qvals[24].val.str_val = tuple->bridge_entities[2]->from_uri;
-				qvals[25].val.str_val = tuple->bridge_entities[2]->key;
-			}
-			n_insert_cols = DB_COLS_NO;
-
-			/* insert into database */
-			if(tuple->db_flag == INSERTDB_FLAG)
-			{
-				if(b2bl_dbf.insert(b2bl_db, qcols, qvals, n_insert_cols)< 0)
-				{
-					LM_ERR("Sql insert failed\n");
-					if(!no_lock)
-						lock_release(&b2bl_htable[i].lock);
-					return;
-				}
-			}
-			else
-			{
-				/*do update */
-				if(b2bl_dbf.update(b2bl_db, qcols, 0, qvals, qcols+n_query_update,
-					qvals+n_query_update, 1, DB_COLS_NO - n_query_update)< 0)
-				{
-					LM_ERR("Sql update failed\n");
-					if(!no_lock)
-						lock_release(&b2bl_htable[i].lock);
-					return;
-				}
-			}
-			tuple->db_flag = NO_UPDATEDB_FLAG;
-next:
-			tuple = tuple->next;
-		}
-		if(!no_lock)
-			lock_release(&b2bl_htable[i].lock);
-	}
-}
-
-static int b2bl_add_tuple(b2bl_tuple_t* tuple, str* params[])
-{
-	b2bl_tuple_t* shm_tuple= NULL;
-	unsigned int hash_index, local_index;
-	str* b2bl_key;
-	b2bl_entity_id_t* entity;
-	int i;
-	b2b_notify_t cback;
-	str* client_id = NULL;
-	unsigned int logic_restored = 0;
-
-	LM_DBG("Add tuple key [%.*s]\n", tuple->key->len, tuple->key->s);
-	if(b2bl_parse_key(tuple->key, &hash_index, &local_index)< 0)
-	{
-		LM_ERR("Wrong formatted b2b logic key\n");
-		return -1;
-	}
-	shm_tuple = b2bl_insert_new(NULL, hash_index, tuple->scenario, params,
-			(tuple->sdp.s?&tuple->sdp:NULL), NULL, local_index,
-			&b2bl_key, UPDATEDB_FLAG);
-	if(shm_tuple == NULL)
-	{
-		LM_ERR("Failed to insert new tuple\n");
-		return -1;
-	}
-	shm_tuple->lifetime = tuple->lifetime;
-	lock_release(&b2bl_htable[hash_index].lock);
-	shm_tuple->scenario_state= tuple->scenario_state;
-	shm_tuple->next_scenario_state= tuple->next_scenario_state;
-
-	/* add entities */
-	for(i=0; i< MAX_BRIDGE_ENT; i++)
-	{
-		if(!tuple->bridge_entities[i]->to_uri.len)
-			continue;
-		LM_DBG("Restore logic info for tuple:entity [%.*s][%d]\n",
-				b2bl_key->len, b2bl_key->s, i);
-
-		if(tuple->bridge_entities[i]->type == B2B_SERVER)
-			cback = b2b_server_notify;
-		else
-			cback = b2b_client_notify;
-
-		/* restore to the entities from b2b_entities module
-		 * the parameter and callback function */
-		if(b2b_api.restore_logic_info(tuple->bridge_entities[i]->type,
-			&tuple->bridge_entities[i]->key, cback)< 0)
-			LM_WARN("Failed to restore logic info for tuple:entity [%.*s][%d]\n",
-				b2bl_key->len, b2bl_key->s, i);
-		else
-			logic_restored = 1;
-
-		entity= b2bl_create_new_entity(tuple->bridge_entities[i]->type,
-			&tuple->bridge_entities[i]->key,&tuple->bridge_entities[i]->to_uri,
-			&tuple->bridge_entities[i]->from_uri, 0, &tuple->bridge_entities[i]->scenario_id, 0);
-		if(client_id)
-			pkg_free(client_id);
-		if(entity == NULL)
-		{
-			LM_ERR("Failed to create entity %d\n", i);
-			goto error;
-		}
-		shm_tuple->bridge_entities[i]= entity;
-		/* put the pointer in clients or servers array */
-		// FIXME: check if the restore logic is ok
-		if(tuple->bridge_entities[i]->type == B2B_SERVER)
-		{
-			if (shm_tuple->servers[0])
-				shm_tuple->servers[1] = entity;
-			else
-				shm_tuple->servers[0] = entity;
-		}
-		else
-		{
-			if (shm_tuple->clients[0])
-				shm_tuple->clients[1] = entity;
-			else
-				shm_tuple->clients[0] = entity;
-		}
-	}
-	if(shm_tuple->bridge_entities[1])
-		shm_tuple->bridge_entities[1]->peer = shm_tuple->bridge_entities[0];
-	if(shm_tuple->bridge_entities[0])
-		shm_tuple->bridge_entities[0]->peer = shm_tuple->bridge_entities[1];
-
-	/* Mark tuple without entities as expired */
-	if(logic_restored==0)
-		shm_tuple->lifetime = 1;
-
-	return 0;
-error:
-	shm_free(shm_tuple);
-	return -1;
-}
-
-int b2b_logic_restore(void)
-{
-	int i;
-	int nr_rows;
-	int _time;
-	db_res_t *result= NULL;
-	db_row_t *rows = NULL;
-	db_val_t *row_vals= NULL;
-	b2bl_tuple_t tuple;
-	str b2bl_key;
-	str scenario_id;
-	b2bl_entity_id_t bridge_entities[3];
-	str* params[MAX_SCENARIO_PARAMS];
-
-	if(b2bl_db == NULL)
-	{
-		LM_DBG("NULL database connection\n");
-		return 0;
-	}
-	if(b2bl_dbf.use_table(b2bl_db, &b2bl_dbtable)< 0)
-	{
-		LM_ERR("sql use table failed\n");
-		return -1;
-	}
-
-	if (DB_CAPABILITY(b2bl_dbf, DB_CAP_FETCH))
-	{
-		if(b2bl_dbf.query(b2bl_db, 0, 0, 0, qcols, 0,
-			DB_COLS_NO, 0, 0) < 0)
-		{
-			LM_ERR("Error while querying (fetch) database\n");
-			return -1;
-		}
-		if(b2bl_dbf.fetch_result(b2bl_db,&result,B2BL_FETCH_SIZE)<0)
-		{
-			LM_ERR("fetching rows failed\n");
-			return -1;
-		}
-	}
-	else
-	{
-		if (b2bl_dbf.query(b2bl_db, 0, 0, 0, qcols, 0,
-				DB_COLS_NO, 0, &result) < 0)
-		{
-			LM_ERR("querying presentity\n");
-			return -1;
-		}
-	}
-
-	nr_rows = RES_ROW_N(result);
-
-	do {
-		LM_DBG("loading [%i] records from db\n", nr_rows);
-
-		rows = RES_ROWS(result);
-
-		/* for every row */
-		for(i=0; i<nr_rows; i++)
-		{
-			row_vals = ROW_VALUES(rows +i);
-			memset(&tuple, 0, sizeof(b2bl_tuple_t));
-
-			b2bl_key.s = (char*)row_vals[0].val.string_val;
-			b2bl_key.len = b2bl_key.s?strlen(b2bl_key.s):0;
-
-			tuple.key = &b2bl_key;
-			if(row_vals[1].val.string_val)
-			{
-				scenario_id.s = (char*)row_vals[1].val.string_val;
-				scenario_id.len = strlen(scenario_id.s);
-				tuple.scenario = get_scenario_id(&scenario_id);
-			}
-			memset(bridge_entities, 0, 3*sizeof(b2bl_entity_id_t));
-			memset(params, 0, MAX_SCENARIO_PARAMS* sizeof(str*));
-			if(row_vals[2].val.string_val)
-			{
-				tuple.scenario_params[0].s =(char*)row_vals[2].val.string_val;
-				tuple.scenario_params[0].len = strlen(tuple.scenario_params[0].s);
-				params[0] = &tuple.scenario_params[0];
-			}
-			if(row_vals[3].val.string_val)
-			{
-				tuple.scenario_params[1].s =(char*)row_vals[3].val.string_val;
-				tuple.scenario_params[1].len = strlen(tuple.scenario_params[1].s);
-				params[1] = &tuple.scenario_params[1];
-			}
-			if(row_vals[4].val.string_val)
-			{
-				tuple.scenario_params[2].s =(char*)row_vals[4].val.string_val;
-				tuple.scenario_params[2].len = strlen(tuple.scenario_params[2].s);
-				params[2] = &tuple.scenario_params[2];
-			}
-			if(row_vals[5].val.string_val)
-			{
-				tuple.scenario_params[3].s =(char*)row_vals[5].val.string_val;
-				tuple.scenario_params[3].len = strlen(tuple.scenario_params[3].s);
-				params[3] = &tuple.scenario_params[3];
-			}
-			if(row_vals[6].val.string_val)
-			{
-				tuple.scenario_params[4].s =(char*)row_vals[6].val.string_val;
-				tuple.scenario_params[4].len = strlen(tuple.scenario_params[4].s);
-				params[4] = &tuple.scenario_params[4];
-			}
-			if(row_vals[7].val.string_val)
-			{
-				tuple.sdp.s =(char*)row_vals[7].val.string_val;
-				tuple.sdp.len = strlen(tuple.sdp.s);
-			}
-			tuple.scenario_state     =row_vals[8].val.int_val;
-			tuple.next_scenario_state=row_vals[9].val.int_val;
-			_time = (int)time(NULL);
-			if (row_vals[10].val.int_val <= _time)
-				tuple.lifetime = 1;
-			else
-				tuple.lifetime=row_vals[10].val.int_val - _time + get_ticks();
-
-			bridge_entities[0].type  = row_vals[11].val.int_val;
-			bridge_entities[0].scenario_id.s =(char*)row_vals[12].val.string_val;
-			bridge_entities[0].scenario_id.len=
-				bridge_entities[0].scenario_id.s?strlen(bridge_entities[0].scenario_id.s):0;
-			bridge_entities[0].to_uri.s  =(char*)row_vals[13].val.string_val;
-			bridge_entities[0].to_uri.len=
-				bridge_entities[0].to_uri.s?strlen(bridge_entities[0].to_uri.s):0;
-			bridge_entities[0].from_uri.s=(char*)row_vals[14].val.string_val;
-			bridge_entities[0].from_uri.len=
-				bridge_entities[0].from_uri.s?strlen(bridge_entities[0].from_uri.s):0;
-			bridge_entities[0].key.s  =(char*)row_vals[15].val.string_val;
-			bridge_entities[0].key.len=
-				bridge_entities[0].key.s?strlen(bridge_entities[0].key.s):0;
-
-			bridge_entities[1].type = row_vals[16].val.int_val;
-			bridge_entities[1].scenario_id.s  = (char*)row_vals[17].val.string_val;
-			bridge_entities[1].scenario_id.len=
-				bridge_entities[1].scenario_id.s?strlen(bridge_entities[1].scenario_id.s):0;
-			bridge_entities[1].to_uri.s  = (char*)row_vals[18].val.string_val;
-			bridge_entities[1].to_uri.len=
-				bridge_entities[1].to_uri.s?strlen(bridge_entities[1].to_uri.s):0;
-			bridge_entities[1].from_uri.s  = (char*)row_vals[19].val.string_val;
-			bridge_entities[1].from_uri.len=
-				bridge_entities[1].from_uri.s?strlen(bridge_entities[1].from_uri.s):0;
-			bridge_entities[1].key.s  = (char*)row_vals[20].val.string_val;
-			bridge_entities[1].key.len=
-				bridge_entities[1].key.s?strlen(bridge_entities[1].key.s):0;
-
-			if(row_vals[21].val.string_val)
-			{
-				bridge_entities[2].type = row_vals[21].val.int_val;
-				bridge_entities[2].scenario_id.s  = (char*)row_vals[22].val.string_val;
-				bridge_entities[2].scenario_id.len=
-					bridge_entities[2].scenario_id.s?strlen(bridge_entities[2].scenario_id.s):0;
-				bridge_entities[2].to_uri.s  = (char*)row_vals[23].val.string_val;
-				bridge_entities[2].to_uri.len=
-					bridge_entities[2].to_uri.s?strlen(bridge_entities[2].to_uri.s):0;
-				bridge_entities[2].from_uri.s  = (char*)row_vals[24].val.string_val;
-				bridge_entities[2].from_uri.len=
-					bridge_entities[2].from_uri.s?strlen(bridge_entities[2].from_uri.s):0;
-				bridge_entities[2].key.s  = (char*)row_vals[25].val.string_val;
-				bridge_entities[2].key.len=
-					bridge_entities[2].key.s?strlen(bridge_entities[2].key.s):0;
-			}
-
-			tuple.bridge_entities[0] = &bridge_entities[0];
-			tuple.bridge_entities[1] = &bridge_entities[1];
-			tuple.bridge_entities[2] = &bridge_entities[2];
-
-			if(b2bl_add_tuple(&tuple, params) < 0)
-			{
-				LM_ERR("Failed to add new tuple\n");
-				goto error;
-			}
-		}
-		/* any more data to be fetched ?*/
-		if (DB_CAPABILITY(b2bl_dbf, DB_CAP_FETCH)) {
-			if (b2bl_dbf.fetch_result( b2bl_db, &result,
-				B2BL_FETCH_SIZE ) < 0) 
-			{
-				LM_ERR("fetching more rows failed\n");
-				goto error;
-			}
-			nr_rows = RES_ROW_N(result);
-		} else {
-			nr_rows = 0;
-		}
-	}while (nr_rows>0);
-
-	b2bl_dbf.free_result(b2bl_db, result);
-	LM_DBG("Finished\n");
-
-	return 0;
-error:
-	if(result)
-		b2bl_dbf.free_result(b2bl_db, result);
-	return -1;
-}
-
-void b2bl_db_insert(b2bl_tuple_t* tuple)
-{
-	int ci;
-	int i;
-
-	qvals[0].val.str_val = *tuple->key;
-	if(tuple->scenario)
-		qvals[1].val.str_val = tuple->scenario->id;
-	else{
-		qvals[1].val.str_val.len = 0;
-		qvals[1].val.str_val.s = "";
-	}
-
-	qvals[2].val.str_val = tuple->scenario_params[0];
-	qvals[3].val.str_val = tuple->scenario_params[1];
-	qvals[4].val.str_val = tuple->scenario_params[2];
-	qvals[5].val.str_val = tuple->scenario_params[3];
-	qvals[6].val.str_val = tuple->scenario_params[4];
-	qvals[7].val.str_val = tuple->sdp;
-	qvals[8].val.int_val = tuple->scenario_state;
-	qvals[9].val.int_val = tuple->next_scenario_state;
-	qvals[10].val.int_val= tuple->lifetime - get_ticks() + (int)time(NULL);
-	ci = 11;
-
-	for(i = 0; i< 3; i++)
-	{
-		if(!tuple->bridge_entities[i])
-			break;
-		qvals[ci++].val.int_val = tuple->bridge_entities[i]->type;
-		qvals[ci++].val.str_val = tuple->bridge_entities[i]->scenario_id;
-		qvals[ci++].val.str_val = tuple->bridge_entities[i]->to_uri;
-		qvals[ci++].val.str_val = tuple->bridge_entities[i]->from_uri;
-		qvals[ci++].val.str_val = tuple->bridge_entities[i]->key;
-	}
-
-	if(b2bl_dbf.use_table(b2bl_db, &b2bl_dbtable)< 0)
-	{
-		LM_ERR("sql use table failed\n");
-		return;
-	}
-
-	if(b2bl_dbf.insert(b2bl_db, qcols, qvals, ci)< 0)
-	{
-		LM_ERR("Sql insert failed\n");
-	}
-}
-
-void b2bl_db_update(b2bl_tuple_t* tuple)
-{
-	int ci;
-	int i;
-
-	if(!tuple->key) {
-		LM_ERR("No key found\n");
-		return;
-	}
-	LM_DBG("key= %.*s\n", tuple->key->len, tuple->key->s);
-
-	qvals[0].val.str_val = *tuple->key;
-
-	qvals[8].val.int_val  = tuple->scenario_state;
-	qvals[9].val.int_val  = tuple->next_scenario_state;
-	qvals[10].val.int_val = tuple->lifetime -get_ticks() + (int)time(NULL);
-	ci = 11;
-
-	for(i = 0; i< 3; i++)
-	{
-		if(!tuple->bridge_entities[i])
-			break;
-		qvals[ci++].val.int_val = tuple->bridge_entities[i]->type;
-		qvals[ci++].val.str_val = tuple->bridge_entities[i]->scenario_id;
-		qvals[ci++].val.str_val = tuple->bridge_entities[i]->to_uri;
-		qvals[ci++].val.str_val = tuple->bridge_entities[i]->from_uri;
-		qvals[ci++].val.str_val = tuple->bridge_entities[i]->key;
-		LM_DBG("UPDATE %.*s\n", qvals[ci-1].val.str_val.len, qvals[ci-1].val.str_val.s);
-	}
-
-	if(b2bl_dbf.use_table(b2bl_db, &b2bl_dbtable)< 0)
-	{
-		LM_ERR("sql use table failed\n");
-		return;
-	}
-
-	if(b2bl_dbf.update(b2bl_db, qcols, 0, qvals, qcols+n_query_update,
-		qvals+n_query_update, 1, ci - n_query_update)< 0)
-	{
-		LM_ERR("Sql update failed\n");
-	}
-}
-
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/text-base/b2bl_db.h.svn-base ./b2b_logic/.svn/text-base/b2bl_db.h.svn-base
--- ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/text-base/b2bl_db.h.svn-base	2012-10-31 10:33:42.881197359 +0000
+++ ./b2b_logic/.svn/text-base/b2bl_db.h.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,39 +0,0 @@
-/*
- * $Id$
- *
- * back-to-back logic module
- *
- * Copyright (C) 2011 Free Software Fundation
- *
- * This file is part of opensips, a free SIP server.
- *
- * opensips is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version
- *
- * opensips is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License 
- * along with this program; if not, write to the Free Software 
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * History:
- * --------
- *  2011-04-04  initial version (Anca Vamanu)
- */
-
-#ifndef B2BL_DB_H
-#define B2BL_DB_H
-
-#include "records.h"
-
-void b2b_logic_dump(int no_lock);
-int b2b_logic_restore(void);
-void b2bl_db_insert(b2bl_tuple_t* tuple);
-void b2bl_db_update(b2bl_tuple_t* tuple);
-
-#endif
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/text-base/b2b_load.h.svn-base ./b2b_logic/.svn/text-base/b2b_load.h.svn-base
--- ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/text-base/b2b_load.h.svn-base	2012-10-31 10:33:42.877197307 +0000
+++ ./b2b_logic/.svn/text-base/b2b_load.h.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,125 +0,0 @@
-
-#ifndef B2BUA_LOGIC_LOAD_
-#define B2BUA_LOGIC_LOAD_
-
-#include "../../sr_module.h"
-#include "../b2b_entities/b2b_common.h"
-#include "../b2b_entities/dlg.h"
-
-#define B2B_BYE_CB        (1<<0)
-#define B2B_REJECT_CB     (1<<1)
-#define B2B_DESTROY_CB    (1<<2)
-#define B2B_RE_INVITE_CB  (1<<3)
-#define B2B_CONFIRMED_CB  (1<<4)
-
-#define B2B_ERROR_CB_RET          -1
-#define B2B_DROP_MSG_CB_RET        0
-#define B2B_SEND_MSG_CB_RET        1
-#define B2B_FOLLOW_SCENARIO_CB_RET 2
-
-typedef struct b2bl_dlg_stat
-{
-	str key;
-	int start_time;
-	int setup_time;
-	int call_time;
-}b2bl_dlg_stat_t;
-
-typedef struct b2bl_cb_params
-{
-	void *param;            /* parameter passed at callback registration */
-	b2bl_dlg_stat_t *stat;  /* b2bl_dlg statistics */
-	struct sip_msg* msg;    /* the message being processed */
-	unsigned int entity;    /* the entity for which the callback is invoked */
-} b2bl_cb_params_t;
-
-typedef int (*b2bl_cback_f)(b2bl_cb_params_t *params, unsigned int b2b_event);
-/*
- * event    - B2B_BYE_CB,       bye received from an entity
- *            B2B_REJECT_CB,    negative reply for invite when bridging
- *            B2B_DESTROY_CB,   destroy the tuple
- *            B2B_RE_INVITE_CB, re-invite received from an entity
- * Return:
- *     B2B_ERROR_CB_RET           - error
- *     B2B_DROP_MSG_CB_RET        - drop the request
- *     B2B_SEND_MSG_CB_RET        - send the request on the other side 
- *     B2B_FOLLOW_SCENARIO_CB_RET - do what the scenario tells,
- *               if no rule defined send the request on the other side
- **/
-
-
-typedef str* (*b2bl_init_f)(struct sip_msg* msg, str* name, str* args[5],
-		b2bl_cback_f, void* param, unsigned int cb_mask, str* custom_hdrs);
-
-typedef int (*b2bl_bridge_f)(str* key, str* new_uri, str* new_from_dname,int entity_type);
-/* key - the string returned by b2bl_init_f 
- * entity_type - 0, the server entity
- *               1, the client entity
- */
-typedef int (*b2bl_set_state_f)(str* key, int state);
-
-typedef str* (*b2bl_bridge_extern_f)(str* scenario_name, str* args[5],
-		b2bl_cback_f cbf, void* cb_param);
-
-int b2bl_terminate_call(str* key);
-typedef int (*b2bl_terminate_call_t)(str* key);
-
-int b2bl_bridge(str* key,str* new_uri,str* new_from_dname,int entity_no);
-int b2bl_set_state(str* key, int state);
-
-int b2bl_bridge_2calls(str* key1, str* key2);
-typedef int (*b2bl_bridge_2calls_t)(str* key1, str* key2);
-
-int b2bl_bridge_msg(struct sip_msg* msg, str* key, int entity_no);
-typedef int (*b2bl_bridge_msg_t)(struct sip_msg* msg, str* key, int entity_no);
-
-int b2bl_get_stats(str* key, b2bl_dlg_stat_t* stat);
-typedef int (*b2bl_get_stats_f)(str* key, b2bl_dlg_stat_t* stat);
-
-int b2bl_register_cb(str* key, b2bl_cback_f, void* param, unsigned int cb_mask);
-typedef int (*b2bl_register_cb_f)(str* key, b2bl_cback_f, void* param, unsigned int cb_mask);
-
-int b2bl_restore_upper_info(str* b2bl_key, b2bl_cback_f, void* param);
-typedef int (*b2bl_restore_upper_info_f)(str* b2bl_key, b2bl_cback_f, void* param);
-
-typedef struct b2bl_api
-{
-	b2bl_init_f init;
-	b2bl_bridge_f bridge;
-	b2bl_bridge_extern_f bridge_extern;
-	b2bl_bridge_2calls_t bridge_2calls;
-	b2bl_terminate_call_t terminate_call;
-	b2bl_set_state_f set_state;
-	b2bl_bridge_msg_t bridge_msg;
-	b2bl_get_stats_f get_stats;
-	b2bl_register_cb_f register_cb;
-	b2bl_restore_upper_info_f restore_upper_info;
-}b2bl_api_t;
-
-str* internal_init_scenario(struct sip_msg* msg, str* name, str* args[5],
-		b2bl_cback_f, void* param, unsigned int cb_mask, str* custom_hdrs);
-
-typedef int(*load_b2bl_f)( b2bl_api_t *api );
-int b2b_logic_bind(b2bl_api_t* api);
-
-str* b2bl_bridge_extern(str* scenario_name, str* args[5], b2bl_cback_f cbf, void* cb_param);
-
-static inline int load_b2b_logic_api( b2bl_api_t *api)
-{
-	load_b2bl_f load_b2b;
-
-	/* import the b2b logic auto-loading function */
-	if ( !(load_b2b=(load_b2bl_f)find_export("b2b_logic_bind", 1, 0))) {
-		LM_ERR("failed to import b2b_logic_bind\n");
-		return -1;
-	}
-	/* let the auto-loading function load all B2B stuff */
-	if (load_b2b( api )==-1)
-		return -1;
-
-	return 0;
-}
-
-
-#endif
-
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/text-base/b2b_logic.c.svn-base ./b2b_logic/.svn/text-base/b2b_logic.c.svn-base
--- ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/text-base/b2b_logic.c.svn-base	2012-10-31 10:33:42.865202604 +0000
+++ ./b2b_logic/.svn/text-base/b2b_logic.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,1518 +0,0 @@
-/*
- * $Id$
- *
- * back-to-back logic module
- *
- * Copyright (C) 2009 Free Software Fundation
- *
- * This file is part of opensips, a free SIP server.
- *
- * opensips is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version
- *
- * opensips is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License 
- * along with this program; if not, write to the Free Software 
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * History:
- * --------
- *  2009-08-03  initial version (Anca Vamanu)
- *  2010-11-02  new mi function: mi_b2b_list (Ovidiu Sas)
- *  2010-11-12  new cmd: b2b_bridge_request (Ovidiu Sas)
- */
-
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
-#include <libxml/parser.h>
-
-#include "../../db/db.h"
-#include "../../sr_module.h"
-#include "../../dprint.h"
-#include "../../error.h"
-#include "../../parser/parse_from.h"
-#include "../../parser/parse_content.h"
-#include "../../ut.h"
-#include "../../trim.h"
-#include "../../mem/mem.h"
-#include "../../mod_fix.h"
-
-#include "records.h"
-#include "pidf.h"
-#include "b2b_logic.h"
-#include "b2b_load.h"
-#include "b2bl_db.h"
-
-#define TABLE_VERSION 2
-
-/** Functions declarations */
-static int mod_init(void);
-static void mod_destroy(void);
-static int child_init(int rank);
-static int load_script_scenario(modparam_t type, void* val);
-static int load_extern_scenario(modparam_t type, void* val);
-static int fixup_b2b_logic(void** param, int param_no);
-static struct mi_root* mi_trigger_scenario(struct mi_root* cmd, void* param);
-static struct mi_root* mi_b2b_bridge(struct mi_root* cmd, void* param);
-static struct mi_root* mi_b2b_list(struct mi_root* cmd, void* param);
-static struct mi_root* mi_b2b_terminate_call(struct mi_root* cmd, void* param);
-static void b2bl_clean(unsigned int ticks, void* param);
-static void b2bl_db_timer_update(unsigned int ticks, void* param);
-int  b2b_init_request(struct sip_msg* msg, str* arg1, str* arg2, str* arg3,
-		str* arg4, str* arg5, str* arg6);
-int  b2b_bridge_request(struct sip_msg* msg, str* arg1, str* arg2);
-
-void b2b_mark_todel( b2bl_tuple_t* tuple);
-
-/** Global variables */
-b2b_api_t b2b_api;
-b2bl_table_t b2bl_htable;
-unsigned int b2bl_hsize = 10;
-b2b_scenario_t* script_scenarios = NULL;
-b2b_scenario_t* extern_scenarios = NULL;
-unsigned int b2b_clean_period = 100;
-unsigned int b2b_update_period = 100;
-str custom_headers = {0, 0};
-str custom_headers_lst[HDR_LST_LEN];
-int custom_headers_lst_len =0;
-/* The list of the headers that are passed on the other side by default */
-static str default_headers[HDR_DEFAULT_LEN]=
-{
-   {"Content-Type",12},
-   {"Supported", 9},
-   {"Allow", 5},
-   {"Proxy-Require", 13},
-   {"Session-Expires", 15},
-   {"Min-SE", 6},
-   {"Require", 7},
-   {"RSeq", 4},
-};
-int use_init_sdp = 0;
-enum b2bl_caller_type b2bl_caller;
-unsigned int max_duration = 12*3600;
-
-int b2bl_key_avp_name;
-unsigned short b2bl_key_avp_type;
-static str b2bl_key_avp_param = {NULL, 0};
-
-static str b2bl_from_spec_param = {NULL, 0};
-static pv_spec_t b2bl_from_spec;
-static pv_value_t b2bl_from_tok;
-static struct to_body b2bl_from;
-
-#define B2BL_FROM_BUF_LEN    255
-static char b2bl_from_buf[B2BL_FROM_BUF_LEN + 1];
-
-str db_url= {0, 0};
-db_con_t *b2bl_db = NULL;
-db_func_t b2bl_dbf;
-str b2bl_dbtable= str_init("b2b_logic");
-str init_callid_hdr={0, 0};
-
-str server_address = {0, 0};
-int b2bl_db_mode = WRITE_BACK;
-
-/** Exported functions */
-static cmd_export_t cmds[]=
-{
-	{"b2b_init_request", (cmd_function)b2b_init_request, 5 , fixup_b2b_logic , 0 , REQUEST_ROUTE},
-	{"b2b_init_request", (cmd_function)b2b_init_request, 4 , fixup_b2b_logic , 0 , REQUEST_ROUTE},
-	{"b2b_init_request", (cmd_function)b2b_init_request, 3 , fixup_b2b_logic , 0 , REQUEST_ROUTE},
-	{"b2b_init_request", (cmd_function)b2b_init_request, 2 , fixup_b2b_logic , 0 , REQUEST_ROUTE},
-	{"b2b_init_request", (cmd_function)b2b_init_request, 1 , fixup_b2b_logic , 0 , REQUEST_ROUTE},
-	{"b2b_init_request", (cmd_function)b2b_init_request, 0 , 0               , 0 , REQUEST_ROUTE},
-	{"b2b_bridge_request",(cmd_function)b2b_bridge_request,2,fixup_pvar_pvar , 0 , REQUEST_ROUTE},
-	{"b2b_logic_bind",   (cmd_function)b2b_logic_bind,   1 , 0,  0,  0},
-	{ 0,                 0,                              0 , 0 , 0,  0}
-};
-
-/** Exported parameters */
-static param_export_t params[]=
-{
-	{"hash_size",       INT_PARAM,                &b2bl_hsize                },
-	{"cleanup_period",  INT_PARAM,                &b2b_clean_period          },
-	{"update_period",   INT_PARAM,                &b2b_update_period         },
-	{"script_scenario", STR_PARAM|USE_FUNC_PARAM, (void*)load_script_scenario},
-	{"extern_scenario", STR_PARAM|USE_FUNC_PARAM, (void*)load_extern_scenario},
-	{"custom_headers",  STR_PARAM,                &custom_headers.s          },
-	{"use_init_sdp",    INT_PARAM,                &use_init_sdp              },
-	{"db_url",          STR_PARAM,                &db_url.s                  },
-	{"dbtable",         STR_PARAM,                &b2bl_dbtable.s            },
-	{"max_duration",    INT_PARAM,                &max_duration              },
-	{"b2bl_key_avp",    STR_PARAM,                &b2bl_key_avp_param.s      },
-	{"b2bl_from_spec_param",STR_PARAM,            &b2bl_from_spec_param.s    },
-	{"server_address",  STR_PARAM,                &server_address.s          },
-	{"init_callid_hdr", STR_PARAM,                &init_callid_hdr.s         },
-	{"db_mode",         INT_PARAM,                &b2bl_db_mode              },
-	{0,                    0,                          0                     }
-};
-
-/** MI commands */
-static mi_export_t mi_cmds[] = {
-	{ "b2b_trigger_scenario", mi_trigger_scenario,   0,  0,  0},
-	{ "b2b_bridge",           mi_b2b_bridge,         0,  0,  0},
-	{ "b2b_list",             mi_b2b_list,           0,  0,  0},
-	{ "b2b_terminate_call",   mi_b2b_terminate_call, 0,  0,  0},
-	{  0,                  0,                        0,  0,  0}
-};
-
-/** Module interface */
-struct module_exports exports= {
-	"b2b_logic",                    /* module name */
-	MODULE_VERSION,                 /* module version */
-	DEFAULT_DLFLAGS,                /* dlopen flags */
-	cmds,                           /* exported functions */
-	params,                         /* exported parameters */
-	0,                              /* exported statistics */
-	mi_cmds,                        /* exported MI functions */
-	0,                              /* exported pseudo-variables */
-	0,                              /* extra processes */
-	mod_init,                       /* module initialization function */
-	(response_function) 0,          /* response handling function */
-	(destroy_function) mod_destroy, /* destroy function */
-	child_init                      /* per-child init function */
-};
-
-/** Module init function */
-static int mod_init(void)
-{
-	char* p = NULL;
-	int i = 0, j;
-	pv_spec_t avp_spec;
-
-	LM_DBG("start\n");
-
-	/* load b2b_entities api */
-	if(load_b2b_api(&b2b_api)< 0)
-	{
-		LM_ERR("Failed to load b2b api\n");
-		return -1;
-	}
-
-	if(b2bl_hsize< 1 || b2bl_hsize> 20)
-	{
-		LM_ERR("Wrong hash size. Needs to be greater than 1"
-				" and smaller than 20. Be aware that you should set the log 2"
-				" value of the real size\n");
-		return -1;
-	}
-	b2bl_hsize = 1<<b2bl_hsize;
-
-	if(server_address.s == NULL)
-	{
-		if(extern_scenarios)
-		{
-			LM_ERR("'server_address' parameter not set. This parameter is"
-				" compulsory if you want to use extern scenarios. It must"
-				" be set to the IP address of the machine\n");
-			return -1;
-		}
-	}
-	else
-		server_address.len = strlen(server_address.s);
-
-	if(init_b2bl_htable() < 0)
-	{
-		LM_ERR("Failed to initialize b2b logic hash table\n");
-		return -1;
-	}
-
-	if(b2b_clean_period < 0)
-	{
-		LM_ERR("Wrong parameter - b2b_clean_period [%d]\n", b2b_clean_period);
-		return -1;
-	}
-	if(b2b_update_period < 0)
-	{
-		LM_ERR("Wrong parameter - b2b_update_period [%d]\n", b2b_update_period);
-		return -1;
-	}
-
-	if(b2bl_db_mode && db_url.s)
-	{
-		db_url.len = strlen(db_url.s);
-		/* binding to database module  */
-		if (db_bind_mod(&db_url, &b2bl_dbf))
-		{
-			LM_ERR("Database module not found\n");
-			return -1;
-		}
-
-		if (!DB_CAPABILITY(b2bl_dbf, DB_CAP_ALL))
-		{
-			LM_ERR("Database module does not implement all functions"
-					" needed by b2b_entities module\n");
-			return -1;
-		}
-		b2bl_db = b2bl_dbf.init(&db_url);
-		if(!b2bl_db)
-		{
-			LM_ERR("connecting to database failed\n");
-			return -1;
-		}
-
-		/*verify table versions */
-		if(db_check_table_version(&b2bl_dbf, b2bl_db, &b2bl_dbtable, TABLE_VERSION) < 0)
-		{
-			LM_ERR("error during table version check\n");
-			return -1;
-		}
-
-		b2bl_db_init();
-
-		/* reload data */
-		if(b2b_logic_restore() < 0)
-		{
-			LM_ERR("Failed to restore data from database\n");
-			return -1;
-		}
-
-		if(b2bl_db)
-			b2bl_dbf.close(b2bl_db);
-		b2bl_db = NULL;
-	}
-	else
-		b2bl_db_mode = 0;
-
-	if (b2bl_key_avp_param.s)
-		b2bl_key_avp_param.len = strlen(b2bl_key_avp_param.s);
-
-	if (b2bl_key_avp_param.s && b2bl_key_avp_param.len > 0)
-	{
-		if (pv_parse_spec(&b2bl_key_avp_param, &avp_spec)==0 || avp_spec.type!=PVT_AVP) {
-			LM_ERR("malformed or non AVP %.*s AVP definition\n",
-				b2bl_key_avp_param.len, b2bl_key_avp_param.s);
-			return -1;
-		}
-		if (pv_get_avp_name(0, &(avp_spec.pvp), &b2bl_key_avp_name, &b2bl_key_avp_type)!=0){
-			LM_ERR("[%.*s]- invalid AVP definition\n", b2bl_key_avp_param.len,
-					b2bl_key_avp_param.s);
-			return -1;
-		}
-	} else {
-		b2bl_key_avp_name = -1;
-		b2bl_key_avp_type = 0;
-	}
-
-	if(b2bl_from_spec_param.s)
-	{
-		b2bl_from_spec_param.len = strlen(b2bl_from_spec_param.s);
-		if(pv_parse_spec(&b2bl_from_spec_param, &b2bl_from_spec)==NULL)
-		{
-			LM_ERR("failed to parse b2bl_from spec\n");
-			return E_CFG;
-		}
-		switch(b2bl_from_spec.type) {
-			case PVT_NONE:
-			case PVT_EMPTY:
-			case PVT_NULL:
-			case PVT_MARKER:
-			case PVT_COLOR:
-				LM_ERR("invalid b2bl_from spec\n");
-				return -1;
-			default: ;
-		}
-	}
-
-	/* parse extra headers */
-	if(custom_headers.s)
-		custom_headers.len = strlen(custom_headers.s);
-
-	memset(custom_headers_lst, 0, HDR_LST_LEN*sizeof(str));
-	custom_headers_lst[i].s = custom_headers.s;
-	if(custom_headers.s)
-	{
-		p = strchr(custom_headers.s, ';');
-		while(p)
-		{
-			custom_headers_lst[i].len = p - custom_headers_lst[i].s;
-			/* check if this is among the default headers */
-			for(j = 0; j< HDR_DEFAULT_LEN; j++)
-			{
-				if(custom_headers_lst[i].len == default_headers[j].len &&
-						strncmp(custom_headers_lst[i].s, default_headers[j].s,
-							default_headers[j].len)== 0)
-					goto next_hdr;
-			}
-			/* check if defined twice */
-			for(j = 0; j< i; j++)
-			{
-				if(custom_headers_lst[i].len == custom_headers_lst[j].len &&
-						strncmp(custom_headers_lst[i].s, custom_headers_lst[j].s,
-							custom_headers_lst[j].len)== 0)
-					goto next_hdr;
-			}
-			i++;
-			if(i == HDR_LST_LEN)
-			{
-				LM_ERR("Too many extra headers defined."
-						" The maximum value is %d\n.", HDR_LST_LEN);
-				return -1;
-			}
-next_hdr:
-			p++;
-			if(p-custom_headers.s >= custom_headers.len)
-				break;
-			custom_headers_lst[i].s = p;
-			p = strchr(p, ';');
-		}
-	}
-
-	if(p == NULL)
-	{
-		custom_headers_lst[i].len = custom_headers.s + custom_headers.len
-			- custom_headers_lst[i].s;
-		if(custom_headers_lst[i].len == 0)
-			i--;
-	}
-	custom_headers_lst_len = i +1;
-
-	if(init_callid_hdr.s)
-		init_callid_hdr.len = strlen(init_callid_hdr.s);
-
-	register_timer(b2bl_clean, 0, b2b_clean_period);
-	if(b2bl_db_mode == WRITE_BACK)
-		register_timer(b2bl_db_timer_update, 0, b2b_update_period);
-
-	return 0;
-}
-
-void b2bl_db_timer_update(unsigned int ticks, void* param)
-{
-	b2b_logic_dump(0);
-}
-
-void b2bl_clean(unsigned int ticks, void* param)
-{
-	int i;
-	b2bl_tuple_t* tuple, *tuple_next;
-	unsigned int now;
-	str bye = {BYE, BYE_LEN};
-	b2b_req_data_t req_data;
-
-	now = get_ticks();
-
-	for(i = 0; i< b2bl_hsize; i++)
-	{
-		lock_get(&b2bl_htable[i].lock);
-		tuple = b2bl_htable[i].first;
-		while(tuple)
-		{
-			tuple_next = tuple->next;
-			if(tuple->lifetime > 0 && tuple->lifetime < now)
-			{
-				LM_INFO("Found expired tuple [%.*s]: delete and send BYEs\n",
-					tuple->key->len, tuple->key->s);
-				if(tuple->bridge_entities[0] && tuple->bridge_entities[1] && !tuple->to_del)
-				{
-					if(!tuple->bridge_entities[0]->disconnected)
-					{
-						memset(&req_data, 0, sizeof(b2b_req_data_t));
-						PREP_REQ_DATA(tuple->bridge_entities[0]);
-						req_data.method =&bye;
-						b2b_api.send_request(&req_data);
-					}
-					if(!tuple->bridge_entities[1]->disconnected)
-					{
-						memset(&req_data, 0, sizeof(b2b_req_data_t));
-						PREP_REQ_DATA(tuple->bridge_entities[1]);
-						req_data.method =&bye;
-						b2b_api.send_request(&req_data);
-					}
-				}
-				b2bl_delete(tuple, i, 0);
-			}
-			tuple = tuple_next;
-		}
-		lock_release(&b2bl_htable[i].lock);
-	}
-}
-
-static int load_scenario(b2b_scenario_t** scenario_list,char* filename)
-{
-	xmlDocPtr doc;
-	xmlNodePtr node;
-	b2b_scenario_t* scenario = NULL;
-	str attr;
-	xmlNodePtr rules_node, rule_node, request_node;
-	int request_id = 0;
-	b2b_rule_t* rule_struct = NULL;
-
-	doc = xmlParseFile(filename);
-	if(doc == NULL)
-	{
-		LM_ERR("Failed to parse xml file\n");
-		return -1;
-	}
-
-	scenario = (b2b_scenario_t*)pkg_malloc(sizeof(b2b_scenario_t));
-	if(scenario == NULL)
-	{
-		LM_ERR("No more private memory\n");
-		xmlFreeDoc(doc);
-		return -1;
-	}
-	memset(scenario, 0, sizeof(b2b_scenario_t));
-
-	/* analyze the scenario document and descompose so that
-	 * applying it will be more efficient */
-
-	/* extract scenario_id and param no */
-
-	scenario->id.s = (char*)xmlNodeGetAttrContentByName(doc->children, "id");
-	if(scenario->id.s == NULL)
-	{
-		LM_ERR("XML scenario document not well formed. No id attribute found"
-				" for root node\n");
-		pkg_free(scenario);
-		return -1;
-	}
-	scenario->id.len = strlen(scenario->id.s);
-	LM_DBG("Loaded scenario with id = [%.*s]\n", scenario->id.len, scenario->id.s);
-
-	attr.s = (char*)xmlNodeGetAttrContentByName(doc->children, "param");
-	if(attr.s == NULL)
-	{
-		LM_ERR("XML scenario document not well formed. No id attribute found"
-				" for root node\n");
-		return -1;
-	}
-	attr.len = strlen(attr.s);
-
-	if( str2int(&attr, &scenario->param_no) < 0)
-	{
-		LM_ERR("Failed to parse id attribute for scenario node. It must be an integer.\n");
-		xmlFree(attr.s);
-		pkg_free(scenario);
-		return -1;
-	}
-	xmlFree(attr.s);
-
-	/* extract init node */
-	scenario->init_node =  xmlDocGetNodeByName(doc, "init", NULL);
-	if(scenario->init_node == NULL)
-	{
-		LM_ERR("Wrong formatted xml doc. Didn't find an init node\n");
-		goto error;
-	}
-
-	node = xmlNodeGetChildByName(scenario->init_node, "use_init_sdp");
-	if(node)
-	{
-		scenario->use_init_sdp = 1;
-	}
-
-	/* go through the rules */
-	node = xmlDocGetNodeByName(doc, "rules", NULL);
-	if(node == NULL)
-	{
-		LM_DBG("No rules defined\n");
-		goto done;
-	}
-
-	rules_node = xmlNodeGetChildByName(node, "request");
-	if(rules_node == NULL)
-	{
-		LM_DBG("No request rules defined\n");
-		goto after_req_rules;
-	}
-	for(request_node= rules_node->children; request_node; request_node = request_node->next)
-	{
-		if(xmlStrcasecmp(request_node->name, (unsigned char*)"text") == 0)
-			continue;
-		attr.s =  (char*)request_node->name;
-		attr.len = strlen(attr.s);
-
-		request_id = b2b_get_request_id(&attr);
-		if(request_id < 0)
-		{
-			LM_ERR("Bad scenario document. A rule defined for a not supported"
-					" request type [%s]\n", request_node->name);
-			goto error;
-		}
-
-		for(rule_node= request_node->children; rule_node; rule_node = rule_node->next)
-		{
-			if(xmlStrcasecmp(rule_node->name, (unsigned char*)"rule")!= 0)
-				continue;
-
-			rule_struct = (b2b_rule_t*)pkg_malloc(sizeof(b2b_rule_t));
-			if(rule_struct == NULL)
-			{
-				LM_ERR("No more memory\n");
-				goto error;
-			}
-			memset(rule_struct, 0, sizeof(b2b_rule_t));
-			rule_struct->next =  scenario->request_rules[request_id];
-			scenario->request_rules[request_id] = rule_struct;
-			
-			attr.s = (char*)xmlNodeGetAttrContentByName(rule_node, "id");
-			if(attr.s == NULL)
-			{
-				LM_ERR("Bad scenario document. No id attribute for 'rule' node\n");
-				goto error;
-			}
-
-			attr.len = strlen(attr.s);
-			if(str2int(&attr, &rule_struct->id)< 0)
-			{
-				LM_ERR("Bad scenario document. rules_no subschild for request rule not an integer\n");
-				xmlFree(attr.s);
-				goto error;
-			}
-			xmlFree(attr.s);
-
-			rule_struct->cond_state = -1;
-
-			/* extract conditional state if present */
-			rule_struct->cond_node = xmlNodeGetChildByName(rule_node, "condition");
-			if(rule_struct->cond_node)
-			{
-				/* extract the condition state if any */
-				attr.s = (char*)xmlNodeGetNodeContentByName(rule_struct->cond_node, "state", NULL);
-				if(attr.s)
-				{
-					attr.len = strlen(attr.s);
-					if(str2int(&attr, (unsigned int*)&rule_struct->cond_state)< 0)
-					{
-						LM_ERR("Bad scenario. Cond state must be an integer [%s]\n",attr.s);
-						xmlFree(attr.s);
-						goto error;
-					}
-					xmlFree(attr.s);
-				}
-			}
-			node = xmlNodeGetChildByName(rule_node, "action");
-			if(node == NULL)
-			{
-				LM_ERR("Bad scenario document. A rule needs an action node\n");
-				goto error;
-			}
-
-			rule_struct->action_node = node;
-		}
-	}
-after_req_rules:
-	/* TODO - Analyze if there are actions for replies */
-	LM_DBG("scenario_id = %.*s\n", scenario->id.len, scenario->id.s);
-done:
-	scenario->doc  = doc;
-	scenario->next = *scenario_list;
-	*scenario_list  = scenario;
-
-	return 0;
-
-error:
-	if(doc)
-		xmlFree(doc);
-	if(scenario)
-	{
-		int i;
-		b2b_rule_t* prev;
-		for(i = 0; i< B2B_METHODS_NO; i++)
-		{
-			rule_struct = scenario->request_rules[i];
-			while(rule_struct)
-			{
-				prev = rule_struct;
-				rule_struct = rule_struct->next;
-				pkg_free(prev);
-			}
-		}
-
-		rule_struct = scenario->reply_rules;
-		while(rule_struct)
-		{
-			prev = rule_struct;
-			rule_struct = rule_struct->next;
-			pkg_free(prev);
-		}
-		if(scenario->id.s)
-			xmlFree(scenario->id.s);
-		pkg_free(scenario);
-	}
-	
-	return -1;
-}
-
-static int load_script_scenario(modparam_t type, void* val)
-{
-	return load_scenario(&script_scenarios, (char*)val);
-}
-
-static int load_extern_scenario(modparam_t type, void* val)
-{
-	return load_scenario(&extern_scenarios, (char*)val);
-}
-
-
-static void mod_destroy(void)
-{
-	int i;
-	b2b_rule_t* rule_struct = NULL;
-
-	b2b_scenario_t* scenario, *next;
-
-	if(b2bl_db)
-	{
-		if(b2bl_db_mode==WRITE_BACK)
-			b2b_logic_dump(1);
-		b2bl_dbf.close(b2bl_db);
-	}
-
-	scenario = extern_scenarios;
-	while(scenario)
-	{
-		next = scenario->next;
-
-		xmlFree(scenario->id.s);
-		xmlFreeDoc(scenario->doc);
-		pkg_free(scenario);
-		scenario = next;
-	}
-
-	scenario = script_scenarios;
-	while(scenario)
-	{
-		next = scenario->next;
-
-		xmlFreeDoc(scenario->doc);
-		b2b_rule_t* prev;
-		for(i = 0; i< B2B_METHODS_NO; i++)
-		{
-			rule_struct = scenario->request_rules[i];
-			while(rule_struct)
-			{
-				prev = rule_struct;
-				rule_struct = rule_struct->next;
-				pkg_free(prev);
-			}
-		}
-
-		rule_struct = scenario->reply_rules;
-		while(rule_struct)
-		{
-			prev = rule_struct;
-			rule_struct = rule_struct->next;
-			pkg_free(prev);
-		}
-		if(scenario->id.s)
-			xmlFree(scenario->id.s);
-		pkg_free(scenario);
-		scenario = next;
-	}
-
-	destroy_b2bl_htable();
-}
-
-static int child_init(int rank)
-{
-	if (b2bl_db_mode==0)
-		return 0;
-
-	if (b2bl_dbf.init==0)
-	{
-		LM_CRIT("child_init: database not bound\n");
-		return -1;
-	}
-
-	b2bl_db = b2bl_dbf.init(&db_url);
-	if(!b2bl_db)
-	{
-		LM_ERR("connecting to database failed\n");
-		return -1;
-	}
-	LM_DBG("child %d: Database connection opened successfully\n", rank);
-
-	return 0;
-}
-
-b2b_scenario_t* get_scenario_id_list(str* sid, b2b_scenario_t* list)
-{
-	b2b_scenario_t* scenario;
-
-	/*search first in script_scenarios */
-	scenario = list;
-	while(scenario)
-	{
-		LM_DBG("scenario id = %.*s\n", scenario->id.len, scenario->id.s);
-		if(scenario->id.len == sid->len &&
-				strncmp(scenario->id.s, sid->s, sid->len) == 0)
-		{
-			return scenario;
-		}
-		scenario = scenario->next;
-	}
-	return 0;
-}
-
-b2b_scenario_t* get_scenario_id(str* sid)
-{
-	b2b_scenario_t* scenario;
-
-	if(sid->s== 0 || sid->len== 0)
-		return 0;
-
-	if(sid->len == B2B_TOP_HIDING_SCENARY_LEN &&
-		strncmp(sid->s,B2B_TOP_HIDING_SCENARY,B2B_TOP_HIDING_SCENARY_LEN)==0)
-	{
-		return 0;
-	}
-	scenario = get_scenario_id_list(sid, script_scenarios);
-	if(scenario)
-		return scenario;
-
-	return get_scenario_id_list(sid, extern_scenarios);
-}
-
-static int fixup_b2b_logic(void** param, int param_no)
-{
-	pv_elem_t *model;
-	str s;
-
-	if(param_no== 0)
-		return 0;
-
-	if(*param)
-	{
-		s.s = (char*)(*param); 
-		s.len = strlen(s.s);
-
-		if(pv_parse_format(&s, &model)<0)
-		{
-			LM_ERR( "wrong format[%s]\n",(char*)(*param));
-			return E_UNSPEC;
-		}
-
-		/* the first parameter must be the scenario id and must be a string */
-		if(param_no == 1)
-		{
-			if(model->spec.type != PVT_NONE )
-			{
-				LM_ERR("The first parameter is not a string\n");
-				return -1;
-			}
-			if(s.len == B2B_TOP_HIDING_SCENARY_LEN &&
-				strncmp(s.s,B2B_TOP_HIDING_SCENARY,B2B_TOP_HIDING_SCENARY_LEN)==0)
-			{
-				*param = NULL;
-				return 0;
-			}
-			*param = get_scenario_id_list(&s, script_scenarios);
-			if(*param)
-				return 0;
-			LM_ERR("Wrong Scenary ID. No scenario with this ID [%.*s]\n", s.len, s.s);
-			return E_UNSPEC;
-		}
-
-		*param = (void*)model;
-		return 0;
-	}
-	LM_ERR( "null format\n");
-	return E_UNSPEC;
-}
-
-
-struct to_body* get_b2bl_from(struct sip_msg* msg)
-{
-	int len = 0;
-
-	if(b2bl_from_spec_param.s)
-	{
-		memset(&b2bl_from_tok, 0, sizeof(pv_value_t));
-		if(pv_get_spec_value(msg, &b2bl_from_spec, &b2bl_from_tok) < 0)
-		{
-			LM_ERR("Failed to get b2bl_from value\n");
-			return NULL;
-		}
-		//LM_DBG("got b2bl_from_spec_param flags [%d]\n", b2bl_from_tok.flags);
-		if(b2bl_from_tok.flags&PV_VAL_INT)
-		{
-			/* the PV might be empty */
-			return NULL;
-		}
-		if(b2bl_from_tok.flags&PV_VAL_STR)
-		{
-			//LM_DBG("got PV_SPEC b2bl_from [%.*s]\n",
-			//	b2bl_from_tok.rs.len, b2bl_from_tok.rs.s);
-			if(b2bl_from_tok.rs.len+CRLF_LEN > B2BL_FROM_BUF_LEN) {
-				LM_ERR("Buffer overflow");
-				return NULL;
-			}
-			trim(&b2bl_from_tok.rs);
-			memcpy(b2bl_from_buf, b2bl_from_tok.rs.s,
-				b2bl_from_tok.rs.len);
-			len = b2bl_from_tok.rs.len;
-			if(strncmp(b2bl_from_tok.rs.s + len - CRLF_LEN, CRLF, CRLF_LEN)) {
-				memcpy(b2bl_from_buf + len, CRLF, CRLF_LEN);
-				len+= CRLF_LEN;
-			}
-
-			parse_to(b2bl_from_buf, b2bl_from_buf+len,
-				&b2bl_from);
-			if (b2bl_from.error != PARSE_OK) {
-				LM_ERR("Failed to parse PV_SPEC b2bl_from [%.*s]\n",
-					len, b2bl_from_buf);
-				return NULL;
-			}
-			if (parse_uri(b2bl_from.uri.s, b2bl_from.uri.len,
-					&b2bl_from.parsed_uri)<0) {
-				LM_ERR("failed to parse PV_SPEC b2bl_from uri [%.*s]\n",
-					b2bl_from.uri.len, b2bl_from.uri.s);
-				return NULL;
-			}
-			
-			/* side effect of parsing - nobody should need them later on,
-			 * so free them right now */
-			free_to_params(&b2bl_from);
-			return &b2bl_from;
-		}
-	}
-
-	return NULL;
-}
-
-
-str* b2bl_bridge_extern(str* scenario_name, str* args[],
-		b2bl_cback_f cbf, void* cb_param)
-{
-	b2b_scenario_t* scenario_struct;
-	unsigned int hash_index;
-	b2bl_tuple_t* tuple= NULL;
-	str* b2bl_key;
-	unsigned int state = 0;
-	xmlNodePtr xml_node;
-	str attr;
-
-	if(scenario_name== NULL || args[0] == NULL || args[1]== NULL)
-	{
-		LM_ERR("Wrong arguments\n");
-		return 0;
-	}
-	hash_index = core_hash(args[0], args[1], b2bl_hsize);
-
-	LM_DBG("start: bridge [%.*s] with [%.*s]\n", args[0]->len, args[0]->s, 
-			 args[1]->len, args[1]->s);
-	/* find the scenario with the corresponding id */
-	scenario_struct = extern_scenarios;
-	while(scenario_struct)
-	{
-		if(scenario_struct->id.len == scenario_name->len && 
-				strncmp(scenario_struct->id.s, scenario_name->s, scenario_name->len) == 0)
-		{
-			break;
-		}
-		scenario_struct = scenario_struct->next;
-	}
-	if(scenario_struct == NULL)
-	{
-		LM_ERR("No scenario found with the specified id\n");
-		return 0;
-	}
-	
-	/* apply the init part of the scenario */
-	tuple = b2bl_insert_new(NULL, hash_index, scenario_struct, args,
-				NULL, NULL, -1, &b2bl_key, INSERTDB_FLAG);
-	if(tuple== NULL)
-	{
-		LM_ERR("Failed to insert new scenario instance record\n");
-		return 0;
-	}
-	tuple->cbf = cbf;
-	tuple->cb_param = cb_param;
-	tuple->lifetime = 60 + get_ticks();
-
-	/* need to get the next action */
-	xml_node = xmlNodeGetChildByName(scenario_struct->init_node, "state");
-	if(xml_node)
-	{
-		attr.s = (char*)xmlNodeGetContent(xml_node);
-		if(attr.s == NULL)
-		{
-			LM_ERR("No state node content found\n");
-			goto error;
-		}
-		attr.len = strlen(attr.s);
-
-		if(str2int(&attr, &state)< 0)
-		{
-			LM_ERR("Bad scenario. Scenary state not an integer\n");
-			xmlFree(attr.s);
-			goto error;
-		}
-		LM_DBG("Next scenario state is [%d]\n", state);
-		xmlFree(attr.s);
-	}
-	tuple->next_scenario_state = state;
-
-	xml_node =  xmlNodeGetChildByName(scenario_struct->init_node, "bridge");
-	if(xml_node == NULL)
-	{
-		LM_ERR("No bridge node found\n");
-		goto error;
-	}
-
-	if(process_bridge_action(0, 0, tuple, xml_node) < 0)
-	{
-		LM_ERR("Failed to process bridge node");
-		goto error;
-	}
-	lock_release(&b2bl_htable[hash_index].lock);
-	return b2bl_key;
-
-error:
-	if(tuple)
-		lock_release(&b2bl_htable[hash_index].lock);
-	return 0;
-}
-
-static struct mi_root* mi_trigger_scenario(struct mi_root* cmd, void* param)
-{
-	struct mi_node* node= NULL;
-	str* args[B2B_INIT_MAX_PARAMNO];
-	int i = 0;
-	str scenario_name;
-
-	node = cmd->node.kids;
-	if(node == NULL)
-		return 0;
-
-	b2bl_caller = CALLER_MI;
-	/* Get scenario ID */
-	scenario_name = node->value;
-	if(scenario_name.s == NULL || scenario_name.len== 0)
-	{
-		LM_ERR("Empty scenario name parameter\n");
-		return init_mi_tree(404, "Empty scenario ID", 16);
-	}
-	node = node->next;
-
-	memset(args, 0, B2B_INIT_MAX_PARAMNO* sizeof(str*));
-	/* get the other parameters */
-	while(i < B2B_INIT_MAX_PARAMNO && node)
-	{
-		if(node->value.s == NULL || node->value.len== 0)
-			break;
-
-		args[i++] = &node->value;
-
-		node = node->next;
-	}
-
-	if(b2bl_bridge_extern(&scenario_name, args, 0, 0) == 0)
-	{
-		LM_ERR("Failed to initialize scenario\n");
-		return 0;
-	}
-	return init_mi_tree(200, "OK", 2);
-}
-
-
-int  b2b_bridge_request(struct sip_msg* msg, str* p1, str* p2)
-{
-	pv_value_t pv_val;
-	str key = {NULL, 0};
-	int entity_no;
-
-	if (p1 && (pv_get_spec_value(msg, (pv_spec_t *)p1, &pv_val) == 0))
-	{
-		if (pv_val.flags & PV_VAL_STR)
-		{
-			LM_DBG("got key:'%.*s'\n", pv_val.rs.len, pv_val.rs.s);
-			key = pv_val.rs;
-		} else {
-			LM_ERR("Unable to get key from PV that is not a string\n");
-			return -1;
-		}
-	} else {
-		LM_ERR("Unable to get key from pv:%p\n", p1);
-		return -1;
-	}
-
-	if (p2 && (pv_get_spec_value(msg, (pv_spec_t *)p2, &pv_val) == 0))
-	{
-		if (pv_val.flags & PV_VAL_INT)
-		{
-			entity_no = pv_val.ri;
-			LM_DBG("got entity_no %d\n", entity_no);
-		}
-		else
-		if (pv_val.flags & PV_VAL_STR) {
-			if(str2int(&(pv_val.rs), (unsigned int*)&entity_no) != 0) {
-				LM_ERR("Unable to get entity_no from pv '%.*s'i\n",
-				pv_val.rs.len, pv_val.rs.s);
-				return -1;
-			}
-		} else {
-			LM_ERR("second pv not a str or int type\n");
-			return -1;
-		}
-	} else {
-		LM_ERR("Unable to get entity from pv:%p\n", p1);
-		return -1;
-	}
-	return b2bl_bridge_msg(msg, &key, entity_no);
-}
-
-static struct mi_root* mi_b2b_terminate_call(struct mi_root* cmd, void* param)
-{
-	struct mi_node* node= NULL;
-	str key;
-
-	node = cmd->node.kids;
-	if(node == NULL)
-		return 0;
-
-	/* b2bl_key */
-	key = node->value;
-	if(key.s == NULL || key.len== 0)
-	{
-		LM_ERR("Wrong b2b_logic key parameter\n");
-		return init_mi_tree(404, "Empty b2bl key", 14);
-	}
-
-	b2bl_terminate_call(&key);
-
-	return init_mi_tree(200, "OK", 2);
-}
-
-/*
- * arguments: b2bl_key, new_dest, entity (1 - client)
- * */
-static struct mi_root* mi_b2b_bridge(struct mi_root* cmd, void* param)
-{
-	struct mi_node* node= NULL;
-	str key;
-	b2bl_tuple_t* tuple;
-	str new_dest;
-	unsigned int entity_no = 0;
-	b2bl_entity_id_t* entity, *old_entity, *bridging_entity;
-	struct sip_uri uri;
-	str meth_inv = {INVITE, INVITE_LEN};
-	str meth_bye = {BYE, BYE_LEN};
-	unsigned int hash_index, local_index;
-	str ok= str_init("ok");
-	b2b_req_data_t req_data;
-	b2b_rpl_data_t rpl_data;
-
-	node = cmd->node.kids;
-	if(node == NULL)
-		return 0;
-
-	/* b2bl_key */
-	key = node->value;
-	if(key.s == NULL || key.len== 0)
-	{
-		LM_ERR("Wrong b2b_logic key parameter\n");
-		return init_mi_tree(404, "Empty b2bl key", 14);
-	}
-
-	/* new destination- must be a valid SIP URI */
-	node = node->next;
-	if(node == NULL)
-		return 0;
-	
-	new_dest = node->value;
-	if(new_dest.s == NULL || new_dest.len == 0)
-	{
-		LM_ERR("Empty new dest parameter\n");
-		return init_mi_tree(404, "Empty parameter", 15);
-	}
-
-	if(parse_uri(new_dest.s, new_dest.len, &uri)< 0)
-	{
-		LM_ERR("Bad argument. Not a valid uri [%.*s]\n", new_dest.len, new_dest.s);
-		return init_mi_tree(404, "Bad parameter", 13);
-	}
-
-	/* the last parameter is optional, if present and 1 - >
-	 * means that destination from the current call must be
-	 * bridged to the new destination */
-	node = node->next;
-	if(node)
-	{
-		if (node->value.len==1)
-		{
-			if(strncmp(node->value.s, "0", 1)==0)
-				entity_no = 0;
-			else if(strncmp(node->value.s, "1", 1)==0)
-				entity_no = 1;
-			else
-				return init_mi_tree(404, "Invalid entity no parameter", 27);
-		}
-		else
-		{
-			return init_mi_tree(404, "Invalid entity no parameter", 27);
-		}
-	}
-	else
-	{
-		return init_mi_tree(404, "Invalid entity no parameter", 27);
-	}
-
-	if(b2bl_parse_key(&key, &hash_index, &local_index) < 0)
-	{
-		LM_ERR("Failed to parse key '%.*s'\n", key.len, key.s);
-		return 0;
-	}
-
-	entity = b2bl_create_new_entity(B2B_CLIENT, 0, &new_dest, 0, 0, 0, 0);
-	if(entity == NULL)
-	{
-		LM_ERR("Failed to create new b2b entity\n");
-		return 0;
-	}
-
-	lock_get(&b2bl_htable[hash_index].lock);
-
-	tuple = b2bl_search_tuple_safe(hash_index, local_index);
-	if(tuple == NULL)
-	{
-		LM_ERR("No entity found\n");
-		goto error;
-	}
-
-	bridging_entity = tuple->bridge_entities[entity_no];
-	old_entity = tuple->bridge_entities[(entity_no?0:1)];
-
-	if(old_entity == NULL || bridging_entity == NULL)
-	{
-		LM_ERR("Wrong dialog id\n");
-		goto error;
-	}
-
-	if(old_entity->next || old_entity->prev)
-	{
-		LM_ERR("Can not disconnect entity [%p]\n", old_entity);
-		b2bl_print_tuple(tuple, L_ERR);
-		goto error;
-	}
-
-	/* send BYE to old client */
-	if(old_entity->disconnected)
-	{
-		memset(&rpl_data, 0, sizeof(b2b_rpl_data_t));
-		PREP_RPL_DATA(old_entity);
-		rpl_data.method =METHOD_BYE;
-		rpl_data.code =200;
-		rpl_data.text =&ok;
-		b2b_api.send_reply(&rpl_data);
-	}
-	else
-	{
-		old_entity->disconnected = 1;
-		memset(&req_data, 0, sizeof(b2b_req_data_t));
-		PREP_REQ_DATA(old_entity);
-		req_data.method =&meth_bye;
-		b2b_api.send_request(&req_data);
-	}
-
-	if (0 == b2bl_drop_entity(old_entity, tuple))
-	{
-		LM_ERR("Inconsistent tuple [%p]\n", tuple);
-		b2bl_print_tuple(tuple, L_ERR);
-		goto error;
-	}
-
-	if (old_entity->peer->peer == old_entity)
-		old_entity->peer->peer = NULL;
-	else
-	{
-		LM_ERR("Unexpected chain: old_entity=[%p] and old_entity->peer->peer=[%p]\n",
-			old_entity, old_entity->peer->peer);
-		goto error;
-	}
-	old_entity->peer = NULL;
-
-	tuple->bridge_entities[0]= bridging_entity;
-	tuple->bridge_entities[1]= entity;
-
-	bridging_entity->peer = entity;
-	entity->peer = bridging_entity;
-
-	tuple->scenario_state = B2B_BRIDGING_STATE;
-
-	memset(&req_data, 0, sizeof(b2b_req_data_t));
-	PREP_REQ_DATA(bridging_entity);
-	req_data.method =&meth_inv;
-	b2b_api.send_request(&req_data);
-
-	lock_release(&b2bl_htable[hash_index].lock);
-
-	return init_mi_tree(200, "OK", 2);
-
-error:
-	if(tuple)
-		b2b_mark_todel(tuple);
-	lock_release(&b2bl_htable[hash_index].lock);
-	return 0;
-}
-
-static inline int internal_mi_print_b2bl_entity_id(struct mi_node *node1, b2bl_entity_id_t *c)
-{
-	int len;
-	char* p;
-	struct mi_node *node2=NULL;
-	struct mi_attr* attr;
-
-	if (c->scenario_id.s && c->scenario_id.len != 0)
-	{
-		attr = add_mi_attr(node1, MI_DUP_VALUE, "scenario_id", 11,
-				c->scenario_id.s, c->scenario_id.len);
-		if(attr == NULL) goto error;
-	}
-	if (c->key.s && c->key.len != 0)
-	{
-		attr = add_mi_attr(node1, MI_DUP_VALUE, "key", 3,
-					c->key.s, c->key.len);
-		if(attr == NULL) goto error;
-	}
-	p = int2str((unsigned long)(c->disconnected), &len);
-	attr = add_mi_attr(node1, MI_DUP_VALUE, "disconnected", 12, p, len);
-	if(attr == NULL) goto error;
-	p = int2str((unsigned long)(c->state), &len);
-	attr = add_mi_attr(node1, MI_DUP_VALUE, "state", 5, p, len);
-	if(attr == NULL) goto error;
-	p = int2str((unsigned long)(c->no), &len);
-	attr = add_mi_attr(node1, MI_DUP_VALUE, "no", 2, p, len);
-	if(attr == NULL) goto error;
-	p = int2str((unsigned long)(c->type), &len);
-	attr = add_mi_attr(node1, MI_DUP_VALUE, "type", 4, p, len);
-	if(attr == NULL) goto error;
-
-	if (c->peer)
-	{
-		if (c->peer->key.s && c->peer->key.len != 0)
-		{
-			attr = add_mi_attr(node1, MI_DUP_VALUE, "peer", 4,
-				c->peer->key.s, c->peer->key.len);
-			if(attr == NULL) goto error;
-		}
-	}
-
-	if (c->to_uri.s && c->to_uri.len != 0)
-	{
-		node2 = add_mi_node_child(node1, MI_DUP_VALUE, "to_uri", 6,
-						c->to_uri.s, c->to_uri.len);
-		if(node2 == NULL) goto error;
-	}
-	if (c->from_uri.s && c->from_uri.len != 0)
-	{
-		node2 = add_mi_node_child(node1, MI_DUP_VALUE, "from_uri", 8,
-						c->from_uri.s, c->from_uri.len);
-		if(node2 == NULL) goto error;
-	}
-	if (c->from_dname.s && c->from_dname.len != 0)
-	{
-		node2 = add_mi_node_child(node1, MI_DUP_VALUE, "from_dname", 10,
-						c->from_dname.s, c->from_dname.len);
-		if(node2 == NULL) goto error;
-	}
-
-	return 0;
-error:
-	LM_ERR("failed to add node\n");
-	return -1;
-}
-
-static struct mi_root* mi_b2b_list(struct mi_root* cmd, void* param)
-{
-	int i, len, index;
-	char* p;
-	b2bl_tuple_t* tuple;
-	struct mi_root *rpl_tree;
-	struct mi_node *node=NULL, *node1=NULL, *rpl=NULL;
-	struct mi_attr* attr;
-
-	rpl_tree = init_mi_tree( 200, MI_OK_S, MI_OK_LEN);
-	if (rpl_tree==NULL) return NULL;
-	rpl = &rpl_tree->node;
-
-	for(i = 0; i< b2bl_hsize; i++)
-	{
-		lock_get(&b2bl_htable[i].lock);
-		tuple = b2bl_htable[i].first;
-		while(tuple)
-		{
-			p = int2str((unsigned long)(tuple->id), &len);
-			node = add_mi_node_child(rpl, MI_DUP_VALUE, "tuple", 5, p, len);
-			if(node == NULL) goto error;
-			attr = add_mi_attr(node, MI_DUP_VALUE, "key", 3,
-					tuple->key->s, tuple->key->len);
-			if(attr == NULL) goto error;
-			p = int2str((unsigned long)(tuple->scenario_state), &len);
-			attr = add_mi_attr(node, MI_DUP_VALUE, "scenario_state", 14, p, len);
-			if(attr == NULL) goto error;
-			p = int2str((unsigned long)(tuple->lifetime), &len);
-			attr = add_mi_attr(node, MI_DUP_VALUE, "lifetime", 8, p, len);
-			if(attr == NULL) goto error;
-			p = int2str((unsigned long)(tuple->db_flag), &len);
-			attr = add_mi_attr(node, MI_DUP_VALUE, "db_flag", 7, p, len);
-			if(attr == NULL) goto error;
-
-			if (tuple->scenario)
-			{
-				attr = add_mi_attr(node, MI_DUP_VALUE, "scenario", 8,
-						tuple->scenario->id.s, tuple->scenario->id.len);
-				if(attr == NULL) goto error;
-				p = int2str((unsigned long)(tuple->next_scenario_state), &len);
-				attr = add_mi_attr(node, MI_DUP_VALUE, "next_scenario_state", 19,
-						p, len);
-				if(attr == NULL) goto error;
-			}
-
-			for (index = 0; index < MAX_B2BL_ENT; index++)
-			{
-				if (tuple->servers[index] != NULL)
-				{
-					p = int2str((unsigned long)(index), &len);
-					node1 = add_mi_node_child(node, MI_DUP_VALUE,
-						"servers", 7, p, len);
-					if(node1 == NULL) goto error;
-					if (internal_mi_print_b2bl_entity_id(node1,
-							tuple->servers[index])!=0)
-						goto error;
-				}
-			}
-			for (index = 0; index < MAX_B2BL_ENT; index++)
-			{
-				if (tuple->clients[index] != NULL)
-				{
-					p = int2str((unsigned long)(index), &len);
-					node1 = add_mi_node_child(node, MI_DUP_VALUE,
-						"clients", 7, p, len);
-					if(node1 == NULL) goto error;
-					if (internal_mi_print_b2bl_entity_id(node1,
-							tuple->clients[index])!=0)
-						goto error;
-				}
-			}
-			for (index = 0; index < MAX_BRIDGE_ENT; index++)
-			{
-				if (tuple->bridge_entities[index] != NULL)
-				{
-					p = int2str((unsigned long)(index), &len);
-					node1 = add_mi_node_child(node, MI_DUP_VALUE,
-							"bridge_entities", 15, p, len);
-					if(node1 == NULL) goto error;
-					if (internal_mi_print_b2bl_entity_id(node1,
-							tuple->bridge_entities[index])!=0)
-						goto error;
-				}
-			}
-			tuple = tuple->next;
-		}
-		lock_release(&b2bl_htable[i].lock);
-	}
-	return rpl_tree;
-error:
-	lock_release(&b2bl_htable[i].lock);
-	LM_ERR("Unable to create reply\n");
-	free_mi_tree(rpl_tree);
-	return NULL;
-}
-
-
-int b2bl_register_cb(str* key, b2bl_cback_f cbf, void* cb_param, unsigned int cb_mask)
-{
-	b2bl_tuple_t* tuple;
-	unsigned int hash_index, local_index;
-
-	if(!key)
-	{
-		LM_ERR("null key\n");
-		return -1;
-	}
-	if(b2bl_parse_key(key, &hash_index, &local_index) < 0)
-	{
-		LM_ERR("Failed to parse key [%.*s]\n", key->len, key->s);
-		return -1;
-	}
-
-	lock_get(&b2bl_htable[hash_index].lock);
-
-	tuple = b2bl_search_tuple_safe(hash_index, local_index);
-	if(tuple == NULL)
-	{
-		LM_ERR("No tuple found\n");
-		goto error;
-	}
-	if(tuple->cbf || tuple->cb_param || tuple->cb_mask)
-	{
-		LM_ERR("callback already registered\n");
-		goto error;
-	}
-
-	tuple->cbf = cbf;
-	tuple->cb_mask = cb_mask;
-	tuple->cb_param = cb_param;
-
-	lock_release(&b2bl_htable[hash_index].lock);
-
-	return 0;
-error:
-	lock_release(&b2bl_htable[hash_index].lock);
-	return -1;
-}
-
-
-int b2b_logic_bind(b2bl_api_t* api)
-{
-	if (!api)
-	{
-		LM_ERR("Invalid parameter value\n");
-		return -1;
-	}
-	api->init          = internal_init_scenario;
-	api->bridge        = b2bl_bridge;
-	api->bridge_extern = b2bl_bridge_extern;
-	api->set_state     = b2bl_set_state;
-	api->bridge_2calls = b2bl_bridge_2calls;
-	api->bridge_msg    = b2bl_bridge_msg;
-	api->terminate_call= b2bl_terminate_call;
-	api->get_stats     = b2bl_get_stats;
-	api->register_cb   = b2bl_register_cb;
-	api->restore_upper_info = b2bl_restore_upper_info;
-
-	return 0;
-}
-
-int b2bl_restore_upper_info(str* b2bl_key, b2bl_cback_f cbf, void* param)
-{
-	b2bl_tuple_t* tuple;
-	unsigned int local_index, hash_index;
-
-	if(b2bl_key == NULL)
-	{
-		LM_ERR("'param' argument NULL\n");
-		return -1;
-	}
-	if(b2bl_parse_key(b2bl_key, &hash_index, &local_index)< 0)
-	{
-		LM_ERR("Failed to parse b2b logic key [%.*s]\n", b2bl_key->len, b2bl_key->s);
-		return -1;
-	}
-	LM_DBG("hi= %d, li=%d\n", hash_index, local_index);
-
-	lock_get(&b2bl_htable[hash_index].lock);
-	tuple = b2bl_search_tuple_safe(hash_index, local_index);
-	if(tuple == NULL)
-	{
-		LM_ERR("B2B logic record not found\n");
-		lock_release(&b2bl_htable[hash_index].lock);
-		return -1;
-	}
-	tuple->cbf = cbf;
-	tuple->cb_param = param;
-	lock_release(&b2bl_htable[hash_index].lock);
-
-	return 0;
-}
-
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/text-base/b2b_logic.h.svn-base ./b2b_logic/.svn/text-base/b2b_logic.h.svn-base
--- ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/text-base/b2b_logic.h.svn-base	2012-10-31 10:33:42.873197479 +0000
+++ ./b2b_logic/.svn/text-base/b2b_logic.h.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,152 +0,0 @@
-/*
- * $Id$
- *
- * back-to-back logic module
- *
- * Copyright (C) 2009 Free Software Fundation
- *
- * This file is part of opensips, a free SIP server.
- *
- * opensips is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version
- *
- * opensips is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License 
- * along with this program; if not, write to the Free Software 
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * History:
- * --------
- *  2009-08-03  initial version (Anca Vamanu)
- */
-
-#ifndef _B2B_LOGIC_H_
-#define _B2B_LOGIC_H_
-
-#include <libxml/parser.h>
-#include "../../str.h"
-#include "../b2b_entities/b2b_entities.h"
-
-#define B2B_INIT_MAX_PARAMNO     5
-#define B2B_BRIDGING_STATE      -1
-#define B2B_CANCEL_STATE        -2
-#define B2B_NOTDEF_STATE        -3
-
-#define B2B_TOP_HIDING_SCENARY "top hiding"
-#define B2B_TOP_HIDING_SCENARY_LEN  strlen("top hiding")
-
-
-#define B2BL_ENT_NEW		0
-#define B2BL_ENT_CONFIRMED	1
-
-
-#define b2b_peer(type) ((type+1)%2)
-
-#define HDR_LST_LEN       32
-#define HDR_DEFAULT_LEN   8
-
-extern b2b_api_t b2b_api;
-
-enum b2bl_caller_type {
-	CALLER_MODULE,
-	CALLER_SCRIPT,
-	CALLER_MI
-};
-extern enum b2bl_caller_type b2bl_caller;
-
-typedef struct b2b_rule
-{
-	unsigned int id;
-	int cond_state;
-	xmlNodePtr cond_node;
-	xmlNodePtr action_node;
-	struct b2b_rule* next;
-}b2b_rule_t;
-
-enum {
-	B2B_INVITE,
-	B2B_ACK,
-	B2B_BYE,
-	B2B_MESSAGE,
-	B2B_SUBSCRIBE,
-	B2B_NOTIFY,
-	B2B_REFER,
-	B2B_CANCEL,
-	B2B_METHODS_NO
-};
-
-
-typedef struct b2b_scenario
-{
-	str id;
-	unsigned int param_no;
-	char use_init_sdp;
-	xmlDocPtr doc;
-	xmlNodePtr init_node;
-	b2b_rule_t* request_rules[B2B_METHODS_NO];
-	b2b_rule_t* reply_rules;
-
-	struct b2b_scenario* next;
-}b2b_scenario_t;
-
-extern b2b_scenario_t* script_scenaries;
-extern b2b_scenario_t* extern_scenaries;
-
-extern str custom_headers_lst[HDR_LST_LEN];
-int custom_headers_lst_len;
-extern int use_init_sdp;
-extern str server_address;
-extern unsigned int max_duration;
-extern str init_callid_hdr;
-extern str db_url;
-extern db_con_t *b2bl_db ;
-extern db_func_t b2bl_dbf;
-extern str b2bl_dbtable;
-extern char* b2bl_db_buf;
-extern int b2bl_db_mode;
-
-static inline int b2b_get_request_id(str* request)
-{
-	if(request->len ==INVITE_LEN&&strncasecmp(request->s,INVITE,INVITE_LEN)==0)
-		return B2B_INVITE;
-
-	if(request->len ==ACK_LEN && strncasecmp(request->s,ACK,ACK_LEN)==0)
-		return B2B_ACK;
-
-	if(request->len ==BYE_LEN && strncasecmp(request->s,BYE,BYE_LEN)==0)
-		return B2B_BYE;
-
-	if(request->len==REFER_LEN &&strncasecmp(request->s, REFER, REFER_LEN)==0)
-		return B2B_REFER;
-
-	if(request->len==CANCEL_LEN &&strncasecmp(request->s, CANCEL, CANCEL_LEN)==0)
-		return B2B_CANCEL;
-
-	if(request->len==SUBSCRIBE_LEN &&strncasecmp(request->s, SUBSCRIBE, SUBSCRIBE_LEN)==0)
-		return B2B_SUBSCRIBE;
-
-	if(request->len==NOTIFY_LEN &&strncasecmp(request->s, NOTIFY, NOTIFY_LEN)==0)
-		return B2B_NOTIFY;
-
-	if(request->len==MESSAGE_LEN &&strncasecmp(request->s, MESSAGE, MESSAGE_LEN)==0)
-		return B2B_MESSAGE;
-
-	return -1;
-}
-
-b2b_scenario_t* b2b_find_scenario(b2b_scenario_t* scenario,
-		unsigned int scenario_id);
-int b2b_add_dlginfo(str* key, str* entity_key,int src, b2b_dlginfo_t* info);
-int b2b_server_notify(struct sip_msg* msg, str* key, int type, void* param);
-int b2b_client_notify(struct sip_msg* msg, str* key, int type, void* param);
-b2b_scenario_t* get_scenario_id_list(str* sid, b2b_scenario_t* list);
-b2b_scenario_t* get_scenario_id(str* sid);
-void b2bl_db_init(void);
-
-#endif
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/text-base/logic.c.svn-base ./b2b_logic/.svn/text-base/logic.c.svn-base
--- ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/text-base/logic.c.svn-base	2012-10-31 10:33:42.889197311 +0000
+++ ./b2b_logic/.svn/text-base/logic.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,4092 +0,0 @@
-/*
- * $Id$
- *
- * back-to-back logic module
- *
- * Copyright (C) 2009 Free Software Fundation
- *
- * This file is part of opensips, a free SIP server.
- *
- * opensips is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version
- *
- * opensips is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License 
- * along with this program; if not, write to the Free Software 
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * History:
- * --------
- *  2009-08-03  initial version (Anca Vamanu)
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <libxml/parser.h>
-#include "../../dprint.h"
-#include "../../dset.h"
-#include "../../error.h"
-#include "../../parser/parse_from.h"
-#include "../../parser/parse_to.h"
-#include "../../parser/parse_content.h"
-#include "../../parser/parse_methods.h"
-#include "../../parser/parse_hname2.h"
-#include "../../parser/parse_refer_to.h"
-#include "../../parser/parse_replaces.h"
-#include "../../strcommon.h"
-#include "../../ut.h"
-#include "../../trim.h"
-#include "../../mem/shm_mem.h"
-#include "../../mem/mem.h"
-#include "../../msg_translator.h"
-#include "../b2b_entities/dlg.h"
-#include "../presence/hash.h"
-#include "../presence/utils_func.h"
-
-#include "records.h"
-#include "pidf.h"
-#include "b2b_logic.h"
-#include "b2bl_db.h"
-
-#define BUF_LEN  128
-
-#define UPDATE_DBFLAG(dlg, flag) do{ \
-	if(dlg->db_flag==NO_UPDATEDB_FLAG) \
-		dlg->db_flag = UPDATEDB_FLAG; \
-}while(0)
-
-extern b2b_scenario_t* script_scenarios;
-extern int b2bl_key_avp_name;
-extern unsigned short b2bl_key_avp_type;
-
-struct to_body* get_b2bl_from(struct sip_msg* msg);
-
-int b2b_scenario_parse_uri(xmlNodePtr value_node, char* value_content,
-		b2bl_tuple_t* tuple, struct sip_msg* msg, str* client_to);
-
-int post_cb_sanity_check(b2bl_tuple_t **tuple, unsigned int hash_index, unsigned int local_index,
-			b2bl_entity_id_t **entity, int etype, str *ekey);
-b2bl_entity_id_t* b2bl_search_entity(b2bl_tuple_t* tuple, str* key, int src, b2bl_entity_id_t*** head);
-int udh_to_uri(str user, str host, str port, str* uri);
-static str method_invite= {INVITE, INVITE_LEN};
-static str method_ack   = {ACK, ACK_LEN};
-static str method_bye   = {BYE, BYE_LEN};
-static str method_cancel= {CANCEL, CANCEL_LEN};
-
-static str ok = str_init("OK");
-static str notAcceptable = str_init("Not Acceptable");
-
-int b2b_apply_body_lumps(struct sip_msg* msg, str* new_body)
-{
-	int len;
-	char* buf = 0;
-	unsigned int offset=0, s_offset;
-	str body;
-
-	body.s=get_body(msg);
-
-	if(!msg->body_lumps)
-		return 0;
-	len = lumps_len(msg, msg->body_lumps, 0)
-		+ get_content_length(msg);
-
-	LM_DBG("*** len = %d\n", len);
-
-	buf=(char*)pkg_malloc(len+1);
-	if (buf==0){
-		LM_ERR("out of pkg mem\n");
-		return -1;
-	}
-	buf[len]='\0';
-	s_offset=body.s - msg->buf;
-	process_lumps(msg, msg->body_lumps, buf, &offset, &s_offset, 0);
-
-	LM_DBG("offset = %d, s_offset=%d\n", offset, s_offset);
-	//memcpy(buf+offset, msg->buf+s_offset, len-s_offset);
-
-	new_body->s = buf;
-	new_body->len = len;
-
-	memcpy(buf+offset, msg->buf+s_offset, len - offset);
-
-	LM_DBG("new_body= [%.*s], len=%d\n", new_body->len, new_body->s, len);
-	LM_DBG("last chars %d - %d\n", buf[len-1], buf[len-2]);
-
-	return 0;
-}
-
-
-int entity_add_dlginfo(b2bl_entity_id_t* entity, b2b_dlginfo_t* dlginfo)
-{
-	b2b_dlginfo_t* new_dlginfo= NULL;
-	int size;
-
-	size = sizeof(b2b_dlginfo_t)+ dlginfo->callid.len;
-	if( dlginfo->totag.s)
-		size += dlginfo->totag.len;
-	if(dlginfo->fromtag.s)
-		size+= dlginfo->fromtag.len;
-	new_dlginfo = (b2b_dlginfo_t*)shm_malloc(size);
-	if(new_dlginfo == NULL)
-	{
-		LM_ERR("No more shared memory\n");
-		return -1;
-	}
-	memset(new_dlginfo, 0, size);
-	size = sizeof(b2b_dlginfo_t);
-
-	if( dlginfo->totag.s)
-		CONT_COPY(new_dlginfo, new_dlginfo->totag, dlginfo->totag);
-	if(dlginfo->fromtag.s)
-		CONT_COPY(new_dlginfo, new_dlginfo->fromtag, dlginfo->fromtag);
-	CONT_COPY(new_dlginfo, new_dlginfo->callid, dlginfo->callid);
-
-	entity->dlginfo = new_dlginfo;
-
-	return 0;
-}
-
-int b2b_add_dlginfo(str* key, str* entity_key, int src, b2b_dlginfo_t* dlginfo)
-{
-	b2bl_tuple_t* tuple;
-	b2bl_entity_id_t* entity = NULL;
-	b2bl_entity_id_t** ent_head = NULL;
-	unsigned int hash_index, local_index;
-
-	if(b2bl_parse_key(key, &hash_index, &local_index) < 0)
-	{
-		LM_ERR("Failed to parse key\n");
-		return -1;
-	}
-	lock_get(&b2bl_htable[hash_index].lock);
-
-	tuple = b2bl_search_tuple_safe(hash_index, local_index);
-	if(tuple == NULL)
-	{
-		LM_ERR("No entity found\n");
-		lock_release(&b2bl_htable[hash_index].lock);
-		return -1;
-	}
-	/* a connected call */
-	if(max_duration)
-		tuple->lifetime = get_ticks() + max_duration;
-	else
-		tuple->lifetime = 0;
-	entity = b2bl_search_entity(tuple, entity_key, src, &ent_head);
-	if(entity == NULL)
-	{
-		LM_ERR("No b2b_key match found\n");
-		lock_release(&b2bl_htable[hash_index].lock);
-		return -1;
-	}
-
-	if(entity->dlginfo)
-	{
-		shm_free(entity->dlginfo);
-		entity->dlginfo = NULL;
-	}
-	if(entity_add_dlginfo(entity, dlginfo) < 0)
-	{
-		LM_ERR("Failed to add dialoginfo\n");
-		lock_release(&b2bl_htable[hash_index].lock);
-		return -1;
-	}
-
-	/* log the dialog pair */
-	if(entity->peer && entity->peer->dlginfo)
-	{
-		LM_INFO("Dialog pair: [%.*s] - [%.*s]\n",
-				entity->peer->dlginfo->callid.len, entity->peer->dlginfo->callid.s,
-				dlginfo->callid.len, dlginfo->callid.s);
-	}
-
-	lock_release(&b2bl_htable[hash_index].lock);
-
-	return 0;
-}
-
-int msg_add_dlginfo(b2bl_entity_id_t* entity, struct sip_msg* msg, str* totag)
-{
-	str callid, fromtag;
-	b2b_dlginfo_t dlginfo;
-
-	if( msg->callid==NULL || msg->callid->body.s==NULL)
-	{
-		LM_ERR("failed to parse callid header\n");
-		return -1;
-	}
-	callid = msg->callid->body;
-
-	if (msg->from->parsed == NULL)
-	{
-		if ( parse_from_header( msg )<0 ) 
-		{
-			LM_ERR("cannot parse From header\n");
-			return -1;
-		}
-	}
-	fromtag = ((struct to_body*)msg->from->parsed)->tag_value;
-
-	dlginfo.totag  = *totag;
-	dlginfo.callid = callid;
-	dlginfo.fromtag= fromtag;
-	
-	if(entity_add_dlginfo(entity, &dlginfo) < 0)
-	{
-		LM_ERR("Failed to add dialoginfo\n");
-		return -1;
-	}
-
-	return 0;
-}
-
-int b2b_msg_get_to(struct sip_msg* msg, str* to_uri)
-{
-	if( parse_sip_msg_uri(msg)< 0)
-	{
-		LM_ERR("failed to parse R-URI\n");
-		return -1;
-	}
-
-	if(udh_to_uri(msg->parsed_uri.user, msg->parsed_uri.host,
-				msg->parsed_uri.port, to_uri)< 0)
-	{
-		LM_ERR("failed to construct uri from user and domain\n");
-		return -1;
-	}
-	return 0;
-}
-
-int b2b_msg_get_from(struct sip_msg* msg, str* from_uri, str* from_dname)
-{
-	struct to_body *pfrom;
-
-	pfrom = get_b2bl_from(msg);
-	if (pfrom)
-	{
-		*from_uri = pfrom->uri;
-		*from_dname = pfrom->display;
-		return 0;
-	}
-
-	/* examine the from header */
-	if (!msg->from || !msg->from->body.s)
-	{
-		LM_ERR("cannot find 'from' header!\n");
-		return -1;
-	}
-	if (msg->from->parsed == NULL)
-	{
-		if ( parse_from_header( msg )<0 ) 
-		{
-			LM_ERR("cannot parse From header\n");
-			return -1;
-		}
-	}
-	pfrom = (struct to_body*)msg->from->parsed;
-	*from_uri = pfrom->uri;
-	*from_dname = pfrom->display;
-
-	return 0;
-}
-
-
-b2bl_entity_id_t* b2bl_create_new_entity(enum b2b_entity_type type, str* entity_id,
-		str* to_uri,str* from_uri,str*from_dname, str* ssid, struct sip_msg* msg)
-{
-	unsigned int size;
-	b2bl_entity_id_t* entity;
-
-	size = sizeof(b2bl_entity_id_t) + ((ssid!=NULL)?ssid->len:0) +
-		((entity_id!=NULL)?entity_id->len:0)+ ((to_uri !=NULL)?to_uri->len:0)
-		+ ((from_uri!=NULL)?from_uri->len:0)+ ((from_dname!=NULL)?from_dname->len:0);
-
-	entity = (b2bl_entity_id_t*)shm_malloc(size);
-	if(entity == NULL)
-	{
-		LM_ERR("No more shared memory\n");
-		return NULL;
-	}
-	memset(entity, 0, size);
-
-	size = sizeof(b2bl_entity_id_t);
-	
-	if(entity_id)
-	{
-		entity->key.s= (char*)entity+ size;
-		memcpy(entity->key.s, entity_id->s, entity_id->len);
-		entity->key.len= entity_id->len;
-		size+= entity_id->len;
-	}
-	//CONT_COPY_P(entity, entity->key, entity_id);
-
-	if(ssid)
-	{
-		entity->scenario_id.s= (char*)entity+ size;
-		memcpy(entity->scenario_id.s, ssid->s, ssid->len);
-		entity->scenario_id.len= ssid->len;
-		size+= ssid->len;
-	}
-
-	//CONT_COPY_P(entity, entity->scenario_id, ssid);
-	if(to_uri)
-	{
-		entity->to_uri.s= (char*)entity+ size;
-		memcpy(entity->to_uri.s, to_uri->s, to_uri->len);
-		entity->to_uri.len= to_uri->len;
-		size+= to_uri->len;
-	}
-
-	//CONT_COPY_P(entity, entity->to_uri, to_uri);
-	if(from_uri)
-	{
-		entity->from_uri.s= (char*)entity+ size;
-		memcpy(entity->from_uri.s, from_uri->s, from_uri->len);
-		entity->from_uri.len= from_uri->len;
-		size+= from_uri->len;
-	}
-//		CONT_COPY_P(entity, entity->from_uri, from_uri);
-
-	if(from_dname)
-	{
-		entity->from_dname.s= (char*)entity+ size;
-		memcpy(entity->from_dname.s, from_dname->s, from_dname->len);
-		entity->from_dname.len= from_dname->len;
-		size+= from_dname->len;
-	}
-
-	entity->type = type;
-
-	if(type == B2B_SERVER && msg)
-	{
-		if( msg_add_dlginfo(entity, msg, entity_id)< 0 )
-		{
-			LM_ERR("Failed to add dialog information to b2b_logic entity\n");
-			shm_free(entity);
-			return NULL;
-		}
-	}
-	entity->stats.start_time = get_ticks();
-	entity->stats.call_time = 0;
-
-	LM_DBG("new entity type [%d] [%p]->[%.*s]\n",
-		entity->type, entity, entity->key.len, entity->key.s);
-
-	return entity;
-}
-
-static inline int bridge_get_entityno(b2bl_tuple_t* tuple, b2bl_entity_id_t* entity)
-{
-	int i;
-
-	/*check to which entity the reply belongs to */
-	for(i = 0; i< 3; i++)
-	{
-		if(tuple->bridge_entities[i]== entity)
-				return i;
-	}
-	return -1;
-}
-
-void b2b_end_dialog(b2bl_entity_id_t* bentity, b2bl_tuple_t* tuple)
-{
-	str *method;
-	b2b_req_data_t req_data;
-
-	if(!bentity)
-		return;
-
-	if (bentity->next || bentity->prev)
-	{
-		LM_ERR("Inconsistent state for entity [%p]\n", bentity);
-		b2bl_print_tuple(tuple, L_ERR);
-		return;
-	}
-	if(bentity->key.s)
-	{
-		if(!bentity->disconnected)
-		{
-			if(bentity->state == B2BL_ENT_CONFIRMED)
-			{
-				method = &method_bye;
-			}
-			else
-			{
-				method = &method_cancel;
-			}
-
-			memset(&req_data, 0, sizeof(b2b_req_data_t));
-			PREP_REQ_DATA(bentity);
-			req_data.method =method;
-			b2b_api.send_request(&req_data);
-
-			bentity->disconnected = 1;
-		}
-	}
-	else
-	{
-		LM_DBG("It is not connected yet - delete\n");
-		b2bl_delete_entity(bentity, tuple);
-	}
-
-}
-
-void b2b_mark_todel( b2bl_tuple_t* tuple)
-{
-	tuple->to_del = 1;
-	tuple->lifetime = 30 + get_ticks();
-	tuple->scenario_state = B2B_CANCEL_STATE;
-	LM_DBG("%p\n", tuple);
-}
-
-int process_bridge_dialog_end(b2bl_tuple_t* tuple, int entity_no,
-		b2bl_entity_id_t* bentity)
-{
-	if(entity_no == 0) /* if a negative reply received from the server */
-	{
-		/* send cancel or bye to the peers */
-		b2b_end_dialog(tuple->bridge_entities[1], tuple);
-		b2b_end_dialog(tuple->bridge_entities[2], tuple);
-		b2b_mark_todel(tuple);
-	}
-	else
-	if(entity_no == 1)
-	{
-		/* if the media server in 2 stage connecting did not reply */
-		if(tuple->bridge_entities[2])
-		{
-			/* media server did not reply with success */
-			b2bl_delete_entity(bentity, tuple);
-
-			tuple->bridge_entities[1] = tuple->bridge_entities[0];
-			tuple->bridge_entities[0] = tuple->bridge_entities[2];
-			tuple->bridge_entities[2] = NULL;
-
-			tuple->bridge_entities[1]->peer = tuple->bridge_entities[0];
-			tuple->bridge_entities[0]->peer = tuple->bridge_entities[1];
-		}
-		else
-		{
-			/* the entity to connect replied with negative reply */
-			b2b_end_dialog(tuple->bridge_entities[0], tuple);
-			b2b_mark_todel(tuple);
-		}
-	}
-	else
-	{
-		/* if the final destination replied with negative reply */
-		b2b_end_dialog(tuple->bridge_entities[0], tuple);
-		b2b_end_dialog(tuple->bridge_entities[1], tuple);
-		b2b_mark_todel(tuple);
-	}
-
-	return 0;
-}
-
-int process_bridge_bye(struct sip_msg* msg,  b2bl_tuple_t* tuple,
-		b2bl_entity_id_t* entity)
-{
-	int entity_no;
-	b2b_rpl_data_t rpl_data;
-
-	entity_no = bridge_get_entityno(tuple, entity);
-	if(entity_no < 0)
-	{
-		LM_ERR("No match found\n");
-		return -1;
-	}
-
-	memset(&rpl_data, 0, sizeof(b2b_rpl_data_t));
-	PREP_RPL_DATA(entity);
-	rpl_data.method =METHOD_BYE;
-	rpl_data.code =200;
-	rpl_data.text =&ok;
-	b2b_api.send_reply(&rpl_data);
-
-	return process_bridge_dialog_end(tuple, entity_no, entity);
-}
-
-
-int process_bridge_negreply(b2bl_tuple_t* tuple,
-		unsigned int hash_index, b2bl_entity_id_t* entity, struct sip_msg* msg)
-{
-	int entity_no;
-	int ret;
-	unsigned int local_index;
-	b2bl_cback_f cbf = NULL;
-	str ekey={NULL, 0};
-	b2bl_cb_params_t cb_params;
-	b2bl_dlg_stat_t stats;
-
-	entity_no = bridge_get_entityno(tuple, entity);
-	switch (entity_no)
-	{
-		case 0:
-			/* mark that the first step of the bridging failed */
-			tuple->scenario_state = B2B_NONE;
-			break;
-		case 1: break;
-		default:
-			LM_ERR("unexpected entity_no [%d] for tuple [%p]\n",
-				entity_no, tuple);
-			return -1;
-	}
-
-	/* call the callback for brigding failure  */
-	cbf = tuple->cbf;
-	if(cbf && (tuple->cb_mask&B2B_REJECT_CB))
-	{
-		memset(&cb_params, 0, sizeof(b2bl_cb_params_t));
-		cb_params.param = tuple->cb_param;
-		local_index = tuple->id;
-		stats.start_time =  entity->stats.start_time;
-		stats.setup_time = get_ticks() - entity->stats.start_time;
-		stats.key.s = NULL; stats.key.len = 0;
-		ekey.s = (char*)pkg_malloc(entity->key.len);
-		if(ekey.s == NULL)
-		{
-			LM_ERR("No more memory\n");
-			return -1;
-		}
-		memcpy(ekey.s, entity->key.s, entity->key.len);
-		ekey.len = entity->key.len;
-		cb_params.stat = &stats;
-		cb_params.msg = msg;
-		cb_params.entity = entity_no;
-
-		lock_release(&b2bl_htable[hash_index].lock);
-
-		ret = cbf(&cb_params, B2B_REJECT_CB);
-		LM_DBG("ret = %d\n", ret);
-		
-		lock_get(&b2bl_htable[hash_index].lock);
-		/* must search the tuple again
-		 * you can't know what might have happened with it */
-		if (0!=post_cb_sanity_check(&tuple, hash_index, local_index,
-					&entity, entity->type, &ekey))
-		{
-			pkg_free(ekey.s);
-			return 1;
-		}
-		pkg_free(ekey.s);
-
-		if(ret == B2B_DROP_MSG_CB_RET)
-		{
-			/* drop the negative reply */
-			if(entity_no == 1)
-				b2bl_delete_entity(entity, tuple);
-			return 1;
-		}
-	}
-	return process_bridge_dialog_end(tuple, entity_no, entity);
-}
-
-b2bl_entity_id_t* b2bl_new_client(str* to_uri, str* from_uri,
-		b2bl_tuple_t* tuple, str* ssid, struct sip_msg* msg)
-{
-	client_info_t ci;
-	str* client_id;
-	b2bl_entity_id_t* entity;
-
-	memset(&ci, 0, sizeof(client_info_t));
-	ci.method        = method_invite;
-	ci.to_uri        = *to_uri;
-	ci.from_uri      = *from_uri;
-	ci.extra_headers = tuple->extra_headers;
-	ci.body          = (tuple->sdp.s?&tuple->sdp:NULL);
-	ci.from_tag      = NULL;
-	ci.send_sock     = msg?(msg->force_send_socket?msg->force_send_socket:msg->rcv.bind_address):NULL;;
-	get_local_contact( ci.send_sock, &ci.local_contact);
-
-	if(msg)
-	{
-		if (str2int( &(get_cseq(msg)->number), &ci.cseq)!=0 )
-		{
-			LM_ERR("cannot parse cseq number\n");
-			return NULL;
-		}
-	}
-	LM_DBG("Send Invite without a body to a new client entity\n");
-	client_id = b2b_api.client_new(&ci, b2b_client_notify,
-			b2b_add_dlginfo, tuple->key);
-	if(client_id == NULL)
-	{
-		LM_ERR("Failed to create client id\n");
-		return NULL;
-	}
-	/* save the client_id in the structure */
-	entity = b2bl_create_new_entity(B2B_CLIENT, client_id, &ci.to_uri,
-			&ci.from_uri, 0, ssid, 0);
-	if(entity == NULL)
-	{
-		LM_ERR("failed to create new client entity\n");
-		pkg_free(client_id);
-		return NULL;
-	}
-	pkg_free(client_id);
-
-	return entity;
-}
-int process_bridge_200OK(struct sip_msg* msg, str* extra_headers,
-		str* body, b2bl_tuple_t* tuple, b2bl_entity_id_t* entity)
-{
-	str* client_id;
-	b2bl_entity_id_t* bentity0, *bentity1;
-	client_info_t ci;
-	int entity_no;
-	b2b_req_data_t req_data;
-
-	bentity0 = tuple->bridge_entities[0];
-	bentity1 = tuple->bridge_entities[1];
-	
-	if(bentity0 == NULL)
-	{
-		LM_ERR("Bridge entities 0 is NULL\n");
-		b2b_mark_todel(tuple);
-		return -1;
-	}
-
-	entity_no = bridge_get_entityno(tuple, entity);
-	if(entity_no < 0)
-	{
-		LM_ERR("No match found\n");
-		return -1;
-	}
-	LM_DBG("entity_no = %d, entity=%p, be[0]= %p\n", entity_no, entity, tuple->bridge_entities[0]);
-
-	if(entity_no == 0) /* the first reply -> must send INVITE on the other side  */
-	{
-		LM_DBG("Send invite to %.*s\n", bentity1->to_uri.len, bentity1->to_uri.s);
-		if(bentity1->key.s && bentity1->state < B2BL_ENT_CONFIRMED) /* already been in this step*/
-		{
-			LM_ERR("A retransmission of the reply from the first leg\n");
-			return -1;
-		}
-		if(bentity1->type == B2B_CLIENT && bentity1->state!=B2BL_ENT_CONFIRMED)
-		{
-			memset(&ci, 0, sizeof(client_info_t));
-			ci.method        = method_invite;
-			ci.to_uri        = bentity1->to_uri;
-
-			/* it matters if the entity is server or client */
-			if(bentity0->type == B2B_CLIENT)
-			{
-				ci.from_uri      = bentity0->to_uri;
-			}
-			else
-			if(bentity0->type == B2B_SERVER)
-			{
-				if(bentity1->from_uri.s)
-					ci.from_uri = bentity1->from_uri;
-				else
-					ci.from_uri      = bentity0->from_uri;
-				if(bentity1->from_dname.s)
-					ci.from_dname = bentity1->from_dname;
-				else
-					ci.from_dname    = bentity0->from_dname;
-				LM_DBG("From dname: %.*s\n", ci.from_dname.len, ci.from_dname.s);
-			}
-
-			ci.extra_headers = extra_headers;
-			ci.body          = body;
-			ci.from_tag      = NULL;
-			ci.send_sock     = msg->force_send_socket?msg->force_send_socket:msg->rcv.bind_address;;
-			get_local_contact( ci.send_sock, &ci.local_contact);
-
-			if (str2int( &(get_cseq(msg)->number), &ci.cseq)!=0 )
-			{
-				LM_ERR("cannot parse cseq number\n");
-				return -1;
-			}
-			bentity0->state = B2BL_ENT_CONFIRMED;
-			client_id = b2b_api.client_new(&ci, b2b_client_notify,
-					b2b_add_dlginfo, tuple->key);
-			if(client_id == NULL)
-			{
-				LM_ERR("Failed to create new client entity\n");
-				return -1;
-			}
-			/* save the client_id in the structure */
-			entity = b2bl_create_new_entity(B2B_CLIENT, client_id, &ci.to_uri,
-					&ci.from_uri, 0, &bentity1->scenario_id, 0);
-			if(entity == NULL)
-			{
-				LM_ERR("failed to create new client entity\n");
-				pkg_free(client_id);
-				return -1;
-			}
-			entity->no =1;
-			pkg_free(client_id);
-			b2bl_delete_entity(bentity1, tuple);
-
-			tuple->bridge_entities[1] = entity;
-			if (0 != b2bl_add_client(tuple, entity))
-				return -1;
-		}
-		else
-		{
-			/* send reInvite */
-			bentity1->stats.start_time = get_ticks();
-			bentity1->stats.call_time = 0;
-
-			memset(&req_data, 0, sizeof(b2b_req_data_t));
-			req_data.et =bentity1->type;
-			req_data.b2b_key =&bentity1->key;
-			req_data.method =&method_invite;
-			req_data.extra_headers =extra_headers;
-			req_data.body =body;
-			req_data.dlginfo =bentity1->dlginfo;
-			if(b2b_api.send_request(&req_data) < 0)
-			{
-				LM_ERR("Failed to send second ACK in bridging scenario\n");
-				return -1;
-			}
-			bentity1->state = B2BL_ENT_NEW;
-		}
-		tuple->bridge_entities[1]->peer = tuple->bridge_entities[0];
-		tuple->bridge_entities[0]->peer = tuple->bridge_entities[1];
-		/* store this sdp */
-		if(tuple->b1_sdp.s)
-			shm_free(tuple->b1_sdp.s);
-		tuple->b1_sdp.s = 0;
-		if(body)
-		{
-			tuple->b1_sdp.s	= (char*)shm_malloc(body->len);
-			if(tuple->b1_sdp.s == NULL)
-			{
-				LM_ERR("No more memory\n");
-				return -1;
-			}
-			memcpy(tuple->b1_sdp.s, body->s, body->len);
-			tuple->b1_sdp.len = body->len;
-		}
-	}
-	else
-	if(entity_no == 1) /* from provisional media server or from final destination */
-	{
-		str* ack_body= 0;
-		/* the second -> send ACK with body to the first entity
-		and ACK without a body to the second entity*/
-
-		bentity1->state = B2BL_ENT_CONFIRMED;
-
-		bentity1->stats.setup_time = get_ticks() - bentity1->stats.start_time;
-		bentity1->stats.start_time = get_ticks();
-		bentity0->stats.setup_time = get_ticks() - bentity0->stats.start_time;
-		bentity0->stats.start_time = get_ticks();
-
-		/* a complicated combination of conditions that tell us if we need 
-		 * to send body in ACK */
-		if(!(tuple->sdp.s && bentity0->type == B2B_CLIENT))
-		{
-			ack_body = body;
-		}
-		else
-			LM_DBG("Don't send body because the tuple already has a body - so it was used in invite\n");
-
-		memset(&req_data, 0, sizeof(b2b_req_data_t));
-		req_data.et =bentity0->type;
-		req_data.b2b_key =&bentity0->key;
-		req_data.method =&method_ack;
-		req_data.extra_headers =extra_headers;
-		req_data.body =ack_body;
-		req_data.dlginfo =bentity0->dlginfo;
-		if(b2b_api.send_request(&req_data) < 0)
-		{
-			LM_ERR("Failed to send first ACK in bridging scenario\n");
-			return -1;
-		}
-
-		/* send ACK without a body to the second entity */
-		memset(&req_data, 0, sizeof(b2b_req_data_t));
-		req_data.et =bentity1->type;
-		req_data.b2b_key =&bentity1->key;
-		req_data.method =&method_ack;
-		req_data.dlginfo =bentity1->dlginfo;
-		if(b2b_api.send_request(&req_data) < 0)
-		{
-			LM_ERR("Failed to send second ACK in bridging scenario\n");
-			return -1;
-		}
-
-		tuple->bridge_entities[1]->peer = tuple->bridge_entities[0];
-		tuple->bridge_entities[0]->peer = tuple->bridge_entities[1];
-		/* now I have finnished the BRIDGING scenario -> mark this in the record */
-		if(tuple->bridge_entities[2] == NULL)
-		{
-			if(tuple->next_scenario_state>= 0)
-			{
-				tuple->scenario_state = tuple->next_scenario_state;
-				tuple->next_scenario_state = 0;
-				LM_DBG("Updated tuple state = %d\n", tuple->scenario_state);
-			}
-			else
-				tuple->scenario_state = B2B_NOTDEF_STATE;
-/*			tuple->bridge_entities[0] = tuple->bridge_entities[1] = NULL; */
-			LM_DBG("Finished the bridging\n");
-		}
-		else
-		{
-			/* contact the real destination */
-			entity =  b2bl_new_client(&tuple->bridge_entities[2]->to_uri, &bentity0->from_uri,
-					tuple, &tuple->bridge_entities[2]->scenario_id, msg);
-			if(entity == NULL)
-			{
-				LM_ERR("Failed to generate new client\n");
-				return -1;
-			}
-			entity->no = 1;
-			b2bl_delete_entity(tuple->bridge_entities[2], tuple);
-			if (0 != b2bl_add_client(tuple, entity))
-				return -1;
-			/* original destination connected in the second step */
-			tuple->bridge_entities[2]= entity;
-		}
-	}
-	else /* if a 200 OK from the final destination */
-	{
-		b2b_end_dialog(bentity1, tuple);
-
-		/* send reinvite to the initial server*/
-		bentity0->stats.setup_time = get_ticks() - bentity0->stats.start_time;
-		bentity0->stats.start_time = get_ticks();
-		memset(&req_data, 0, sizeof(b2b_req_data_t));
-		req_data.et =bentity0->type;
-		req_data.b2b_key =&bentity0->key;
-		req_data.method =&method_invite;
-		req_data.extra_headers =extra_headers;
-		req_data.body =body;
-		req_data.dlginfo =bentity0->dlginfo;
-		if(b2b_api.send_request(&req_data) < 0)
-		{
-			LM_ERR("Failed to send second Invite in bridging scenario\n");
-			return -1;
-		}
-		bentity0->state = 0;
-
-		tuple->bridge_entities[1] = tuple->bridge_entities[0];
-		tuple->bridge_entities[0] = tuple->bridge_entities[2];
-		tuple->bridge_entities[2] = NULL;
-
-		tuple->bridge_entities[1]->peer = tuple->bridge_entities[0];
-		tuple->bridge_entities[0]->peer = tuple->bridge_entities[1];
-	}
-	return 0;
-}
-
-b2bl_entity_id_t* b2bl_search_entity(b2bl_tuple_t* tuple, str* key, int src, b2bl_entity_id_t*** head)
-{
-	int index;
-	b2bl_entity_id_t* e;
-
-	/* search the entity */
-	if(src == B2B_SERVER)
-		for (index = 0; index < MAX_B2BL_ENT; index++)
-		{
-			*head = &tuple->servers[index];
-			e= tuple->servers[index];
-			while (e)
-			{
-				LM_DBG("Key [%.*s]\n",e->key.len,e->key.s);
-				if (e->key.len == key->len &&
-					strncmp(e->key.s, key->s, key->len) == 0)
-					return e;
-				e = e->next;
-			}
-		}
-	else
-		for (index = 0; index < MAX_B2BL_ENT; index++)
-		{
-			*head = &tuple->clients[index];
-			e = tuple->clients[index];
-			while (e)
-			{
-				LM_DBG("Key [%.*s]\n",e->key.len,e->key.s);
-				if (e->key.len == key->len &&
-					strncmp(e->key.s, key->s, key->len) == 0)
-					return e;
-				e = e->next;
-			}
-		}
-
-	return e;
-}
-
-
-int post_cb_sanity_check(b2bl_tuple_t **tuple, unsigned int hash_index, unsigned int local_index,
-			b2bl_entity_id_t **entity, int etype, str *ekey)
-{
-	int index;
-	int not_found = 1;
-	b2bl_entity_id_t *e;
-
-	*tuple = b2bl_search_tuple_safe(hash_index, local_index);
-	if(*tuple == NULL)
-	{
-		LM_DBG("B2B logic record doesn't exist after B2B_BYE_CB\n");
-		return -1;
-	}
-	if(etype == B2B_SERVER)
-	{
-		for (index = 0; index < MAX_B2BL_ENT && not_found; index++)
-		{
-			e = (*tuple)->servers[index];
-			while (e)
-			{
-				if(e == *entity && e->key.len == ekey->len &&
-					strncmp(e->key.s, ekey->s, ekey->len)==0)
-				{
-					not_found = 0;
-					break;
-				}
-				e = e->next;
-			}
-		}
-		if(not_found)
-		{
-			LM_DBG("Server Entity does not exist anymore\n");
-			return -2;
-		}
-		else
-		{
-			return 0;
-		}
-	}
-	else
-	if(etype == B2B_CLIENT)
-	{
-		for (index = 0; index < MAX_B2BL_ENT && not_found; index++)
-		{
-			e = (*tuple)->clients[index];
-			while (e)
-			{
-				LM_DBG("[%p] vs [%p]\n", e, *entity);
-				if (e && ekey)
-					LM_DBG("[%.*s] vs [%.*s]\n", e->key.len, e->key.s, ekey->len, ekey->s);
-				if(e == *entity && e->key.len == ekey->len &&
-					strncmp(e->key.s, ekey->s, ekey->len)==0)
-				{
-					not_found = 0;
-					break;
-				}
-				e = e->next;
-			}
-		}
-		if(not_found)
-		{
-			LM_DBG("Client Entity does not exist anymore\n");
-			return -3;
-		}
-		else
-		{
-			return 0;
-		}
-	}
-	else
-	{
-		LM_ERR("Unexpected entity type [%d]\n", etype);
-		return -4;
-	}
-	return -5;
-}
-
-
-#define SEND_REPLY_TO_PEER_OR_GOTO_DONE				\
-do{								\
-	memset(&rpl_data, 0, sizeof(b2b_rpl_data_t));		\
-	rpl_data.et =peer->type;				\
-	rpl_data.b2b_key =&peer->key;				\
-	rpl_data.method =method_value;				\
-	rpl_data.code =statuscode;				\
-	rpl_data.text =&msg->first_line.u.reply.reason;		\
-	rpl_data.body = body->s?body:NULL;			\
-	rpl_data.extra_headers = extra_headers->s?extra_headers:NULL;\
-	rpl_data.dlginfo =peer->dlginfo;			\
-	if(b2b_api.send_reply(&rpl_data) < 0)			\
-	{							\
-		LM_ERR("Sending reply failed - %d, [%.*s]\n",	\
-			statuscode, peer->key.len, peer->key.s);\
-		goto done;					\
-	}							\
-}while(0)
-
-int b2b_logic_notify_reply(int src, struct sip_msg* msg, str* key, str* body, str* extra_headers,
-		str* b2bl_key, unsigned int hash_index, unsigned int local_index)
-{
-	b2bl_tuple_t* tuple;
-	str method;
-	b2b_scenario_t* scenario;
-	b2bl_entity_id_t *entity, *peer, *e, *ent;
-	b2bl_entity_id_t** entity_head = NULL;
-	int statuscode;
-	int ret;
-	unsigned int method_value;
-	int_str avp_val;
-	b2bl_cback_f cbf = NULL;
-	str ekey= {NULL, 0};
-	b2bl_cb_params_t cb_params;
-	b2b_req_data_t req_data;
-	b2b_rpl_data_t rpl_data;
-	b2b_dlginfo_t dlginfo;
-
-	if (parse_headers(msg, HDR_EOH_F, 0) < 0)
-	{
-		LM_ERR("failed to parse message\n");
-		return -1;
-	}
-
-	lock_get(&b2bl_htable[hash_index].lock);
-	tuple = b2bl_search_tuple_safe(hash_index, local_index);
-	if(tuple == NULL)
-	{
-		LM_ERR("B2B logic record not found\n");
-		goto error;
-	}
-	scenario = tuple->scenario;
-
-	entity = b2bl_search_entity(tuple, key, src, &entity_head);
-	if(entity == NULL)
-	{
-		LM_ERR("No b2b_key match found [%.*s], src=%d\n", key->len, key->s, src);
-		goto error;
-	}
-	if (entity->no < 0 || entity->no > 1)
-	{
-		LM_ERR("unexpected entity->no [%d] for tuple [%p]\n", entity->no, tuple);
-		goto error;
-	}
-	peer = entity->peer;
-
-	LM_DBG("b2b_entity key = %.*s\n", key->len, key->s);
-
-	if (b2bl_key_avp_name >= 0)
-	{
-		destroy_avps( b2bl_key_avp_type, b2bl_key_avp_name, 1);
-		avp_val.s = *b2bl_key;
-		if(add_avp(AVP_VAL_STR|b2bl_key_avp_type, b2bl_key_avp_name, avp_val)!=0)
-		{
-			LM_ERR("failed to build b2bl_key avp\n");
-			return -1;
-		}
-	}
-
-	method = get_cseq(msg)->method;
-	if(parse_method(method.s, method.s+method.len, &method_value)< 0)
-	{
-		LM_ERR("Failed to parse method\n");
-		goto error;
-	}
-
-	statuscode = msg->first_line.u.reply.statuscode;
-
-	/* if a disconnected entity -> do nothing */
-	if(entity->disconnected)
-	{
-		LM_DBG("entity [%.*s] is disconnected\n", key->len, key->s);
-		b2bl_delete_entity(entity, tuple);
-
-		if(tuple->to_del && tuple->clients[0]==NULL && tuple->clients[1]==NULL &&
-					tuple->servers[0]==NULL && tuple->servers[1]==NULL)
-		{
-			LM_DBG("Received reply and there are no more entities-> delete\n");
-			b2bl_delete(tuple, hash_index, 0);
-			tuple = 0;
-		}
-		goto done;
-	}
-
-	/* if a reply from the client side was received, 
-	* tell the server side to send a reply also */
-
-	if((scenario && 
-			scenario->reply_rules) || tuple->scenario_state == B2B_BRIDGING_STATE)
-	{
-		if(tuple->scenario_state == B2B_BRIDGING_STATE) /* if in a predefined state */
-		{
-			LM_DBG("Received a reply [%d] while in BRIDGING scenario\n",
-				statuscode);
-			/* if the scenario state is B2B_BRIDGING_STATE -> we should have a reply for INVITE */
-			/* extract the method from Cseq header */
-
-			if(method_value != METHOD_INVITE)
-			{
-				LM_ERR("Wrong scenario state [B2B_BRIDGING_STATE] for this"
-					" reply(for method %d)\n", method_value);
-				goto error;
-			}
-			/* if a negative reply */
-			if(statuscode >= 300)
-			{
-				ret = process_bridge_negreply(tuple, hash_index, entity, msg);
-
-				if(ret < 0)
-				{
-					LM_ERR("Failed to process negative reply while in bridging state\n");
-					goto error;
-				}
-				else
-				if(ret == 1)
-					goto done1;
-
-				if(!entity->peer || !entity->peer->key.s)
-				{
-					LM_DBG("Delete this b2bl record\n");
-					b2bl_delete(tuple, hash_index, 0);
-					tuple = 0;
-				}
-				goto done;
-			}
-			else
-			if(statuscode < 200)
-			{
-				goto done;
-			}
-
-			/* if a reply with 200 OK -> we have two possibilities- either the first 200OK or the final */
-			if(process_bridge_200OK(msg, tuple->extra_headers,
-						(body->s?body:0), tuple, entity)< 0)
-			{
-				LM_ERR("Failed to process bridging 200OK for Invite\n");
-				goto error;
-			}
-		}
-		if(scenario && scenario->reply_rules)
-		{
-			/* TODO -> process and apply reply rules */
-		}
-		if(statuscode >= 300)
-		{
-			tuple->to_del = 1;
-			tuple->lifetime = 30 + get_ticks();
-		}
-	}
-	else
-	{
-		if(!peer)
-		{
-			LM_DBG("No peer found\n");
-			goto done;
-		}
-
-		switch (method_value)
-		{
-		case METHOD_BYE:
-			/* if no other scenario rules defined and this is the reply for BYE */
-			SEND_REPLY_TO_PEER_OR_GOTO_DONE;
-			LM_DBG("Received reply for BYE - delete\n");
-			b2bl_delete(tuple, hash_index, 0);
-			tuple = 0;
-			goto done;
-			break;
-
-		case METHOD_INVITE:
-			if(entity->state!=B2BL_ENT_CONFIRMED)
-			{
-				if(statuscode >= 300)
-				{
-					b2bl_print_tuple(tuple, L_DBG);
-					if (entity->prev || entity->next)
-					{
-						LM_DBG("detaching entity[%p] from tuple[%p]\n",
-								entity, tuple);
-						b2bl_remove_single_entity(entity, entity_head);
-						peer->peer = *entity_head;
-						tuple->bridge_entities[0] = tuple->servers[0];
-						tuple->bridge_entities[1] = tuple->clients[0];
-					}
-					else
-					{
-						SEND_REPLY_TO_PEER_OR_GOTO_DONE;
-						LM_DBG("Negative reply [%d] - delete[%p]\n",
-							statuscode, tuple);
-						b2b_mark_todel(tuple);
-					}
-					b2bl_print_tuple(tuple, L_DBG);
-				}
-				else
-				if(statuscode >= 200 && statuscode < 300)
-				{
-					b2bl_print_tuple(tuple, L_DBG);
-					if (entity->prev || entity->next)
-					{
-						unchain_ent(entity, entity_head);
-						/* send CANCEL to all other entities in the list */
-						e = *entity_head;
-						while (e)
-						{
-							LM_DBG("Send request [%.*s]"
-								" to entity [%.*s]\n",
-								method_cancel.len, method_cancel.s,
-								e->key.len, e->key.s);
-							memset(&req_data, 0, sizeof(b2b_req_data_t));
-							PREP_REQ_DATA(e);
-							req_data.method =&method_cancel;
-							if(b2b_api.send_request(&req_data) < 0)
-							{
-								LM_ERR("Sending request"
-									" failed [%.*s]\n",
-									e->key.len, e->key.s);
-							}
-							b2b_api.entity_delete(e->type, &e->key,
-										e->dlginfo, 0);
-							LM_DBG("destroying dlginfo=[%p]\n",
-									e->dlginfo);
-							if(e->dlginfo)
-								shm_free(e->dlginfo);
-							ent = e->next;
-							shm_free(e);
-							e = ent;
-						}
-						*entity_head = entity;
-						peer->peer = entity;
-						tuple->bridge_entities[0] = tuple->servers[0];
-						tuple->bridge_entities[1] = tuple->clients[0];
-					}
-					SEND_REPLY_TO_PEER_OR_GOTO_DONE;
-					entity->state = B2BL_ENT_CONFIRMED;
-					peer->state = B2BL_ENT_CONFIRMED;
-					b2bl_print_tuple(tuple, L_DBG);
-					entity->stats.setup_time = get_ticks() - entity->stats.start_time;
-					entity->stats.start_time = get_ticks();
-					cbf = tuple->cbf;
-					if(cbf && (tuple->cb_mask&B2B_CONFIRMED_CB))
-					{
-						/* saving the entity key for later sanity check */
-						ekey.s = (char*)pkg_malloc(entity->key.len);
-						if(ekey.s == NULL)
-						{
-							LM_ERR("No more memory\n");
-							goto error;
-						}
-						ekey.len = entity->key.len;
-						memcpy(ekey.s, entity->key.s, entity->key.len);
-						/* preparing the cb params */
-						memset(&cb_params, 0, sizeof(b2bl_cb_params_t));
-						cb_params.param = tuple->cb_param;
-						cb_params.stat = NULL;
-						cb_params.msg = msg;
-						cb_params.entity = entity->no;
-
-						lock_release(&b2bl_htable[hash_index].lock);
-						ret = cbf(&cb_params, B2B_CONFIRMED_CB);
-						lock_get(&b2bl_htable[hash_index].lock);
-
-						/* must search the tuple again
-						 * you can't know what might have happened with it */
-						if (0!=post_cb_sanity_check(&tuple, hash_index, local_index,
-							&entity, entity->type, &ekey))
-						{
-							pkg_free(ekey.s);
-							goto error;
-						}
-						pkg_free(ekey.s);
-
-						peer = entity->peer;
-					}
-				}
-				else
-				{	/* Provisional replies end up here */
-					if((entity->dlginfo) && !entity->dlginfo->fromtag.s)
-					{
-						if( msg->callid==NULL || msg->callid->body.s==NULL)
-						{
-							LM_ERR("failed to parse callid header\n");
-							goto error;
-						}
-						dlginfo.callid = msg->callid->body;
-
-						if (msg->from->parsed == NULL)
-						{
-							if ( parse_from_header( msg )<0 ) 
-							{
-								LM_ERR("cannot parse From header\n");
-								return -1;
-							}
-						}
-						dlginfo.totag =
-						((struct to_body*)msg->from->parsed)->tag_value;
-
-						dlginfo.fromtag = get_to(msg)->tag_value;
-	
-						shm_free(entity->dlginfo);
-						entity->dlginfo = NULL;
-						if(entity_add_dlginfo(entity, &dlginfo) < 0)
-						{
-							LM_ERR("Failed to add dialoginfo\n");
-							goto error;
-						}
-					}
-					SEND_REPLY_TO_PEER_OR_GOTO_DONE;
-				}
-			}
-			else
-			{	/* if reINVITE and 481 or 408 reply */
-				SEND_REPLY_TO_PEER_OR_GOTO_DONE;
-				if(statuscode==481 || statuscode==408)
-				{
-					LM_DBG("Received terminate dialog reply for reINVITE\n");
-					tuple->lifetime = 30 + get_ticks();
-				}
-			}
-			break;
-
-		default:
-			SEND_REPLY_TO_PEER_OR_GOTO_DONE;
-		}
-	}
-
-done:
-	if(tuple)
-	{
-		if(b2bl_db_mode == WRITE_THROUGH)
-			b2bl_db_update(tuple);
-		else
-			UPDATE_DBFLAG(tuple, tuple->db_flag);
-	}
-done1:
-	lock_release(&b2bl_htable[hash_index].lock);
-	return 0;
-error:
-	lock_release(&b2bl_htable[hash_index].lock);
-	return -1;
-}
-
-
-int b2b_logic_notify_request(int src, struct sip_msg* msg, str* key, str* body, str* extra_headers,
-		str* b2bl_key, unsigned int hash_index, unsigned int local_index)
-{
-	b2bl_tuple_t* tuple;
-	str method;
-	b2b_scenario_t* scenario;
-	b2b_rule_t* rule;
-	b2bl_entity_id_t* entity, *peer;
-	b2bl_entity_id_t** entity_head = NULL;
-	xmlNodePtr bridge_node, node;
-	int state = -1;
-	str attr;
-	int ret;
-	unsigned int method_value;
-	int_str avp_val;
-	b2bl_cback_f cbf = NULL;
-	str ekey= {NULL, 0};
-	int request_id;
-	b2bl_cb_params_t cb_params;
-	b2bl_dlg_stat_t stats;
-	b2b_req_data_t req_data;
-	b2b_rpl_data_t rpl_data;
-
-	lock_get(&b2bl_htable[hash_index].lock);
-	tuple = b2bl_search_tuple_safe(hash_index, local_index);
-	if(tuple == NULL)
-	{
-		LM_ERR("B2B logic record not found\n");
-		goto error;
-	}
-	scenario = tuple->scenario;
-
-	entity = b2bl_search_entity(tuple, key, src, &entity_head);
-	if(entity == NULL)
-	{
-		LM_ERR("No b2b_key match found [%.*s], src=%d\n", key->len, key->s, src);
-		goto error;
-	}
-	if (entity->no < 0 || entity->no > 1)
-	{
-		LM_ERR("unexpected entity->no [%d] for tuple [%p]\n", entity->no, tuple);
-		goto error;
-	}
-	peer = entity->peer;
-
-	LM_DBG("b2b_entity key = %.*s\n", key->len, key->s);
-
-	if (b2bl_key_avp_name >= 0)
-	{
-		destroy_avps( b2bl_key_avp_type, b2bl_key_avp_name, 1);
-		avp_val.s = *b2bl_key;
-		if(add_avp(AVP_VAL_STR|b2bl_key_avp_type, b2bl_key_avp_name, avp_val)!=0)
-		{
-			LM_ERR("failed to build b2bl_key avp\n");
-			return -1;
-		}
-	}
-
-	method = msg->first_line.u.request.method;
-	method_value = msg->first_line.u.request.method_value;
-	/* extract body if it has a body */
-
-	LM_DBG("request received for tuple[%p]->[%.*s]\n", tuple, tuple->key->len, tuple->key->s);
-	request_id = b2b_get_request_id(&method);
-	if(request_id < 0)
-	{
-		LM_DBG("Not a recognized request [%d]\n", request_id);
-		goto send_usual_request;
-	}
-	/* if the request is an ACK and the tuple is marked to_del -> then delete the record and return */
-	if(tuple->to_del)
-	{
-		switch (request_id)
-		{
-			case B2B_ACK:
-				LM_DBG("ACK for a negative reply\n");
-				break;
-			case B2B_BYE:
-				/* BYE already sent to this entity but we got no reply */
-				memset(&rpl_data, 0, sizeof(b2b_rpl_data_t));
-				PREP_RPL_DATA(entity);
-				rpl_data.method =METHOD_BYE;
-				rpl_data.code =200;
-				rpl_data.text =&ok;
-				b2b_api.send_reply(&rpl_data);
-				if(entity->peer)
-				{
-					memset(&rpl_data, 0, sizeof(b2b_rpl_data_t));
-					PREP_RPL_DATA(entity->peer);
-					rpl_data.method =METHOD_BYE;
-					rpl_data.code =200;
-					rpl_data.text =&ok;
-					b2b_api.send_reply(&rpl_data);
-				}
-				break;
-			default:
-				memset(&rpl_data, 0, sizeof(b2b_rpl_data_t));
-				PREP_RPL_DATA(entity);
-				rpl_data.method =method_value;
-				rpl_data.code =400;
-				rpl_data.text =&notAcceptable;
-				b2b_api.send_reply(&rpl_data);
-		}
-		b2bl_delete(tuple, hash_index, 0);
-		tuple = 0;
-		goto done;
-	}
-
-	cbf = tuple->cbf;
-
-	switch (request_id) {
-	case B2B_BYE:
-		entity->disconnected = 1;
-		if(cbf && (tuple->cb_mask&B2B_BYE_CB))
-		{
-			memset(&cb_params, 0, sizeof(b2bl_cb_params_t));
-			cb_params.param = tuple->cb_param;
-			if(tuple->scenario_state != B2B_BRIDGING_STATE)
-				entity->stats.call_time = get_ticks() - entity->stats.start_time;
-			else
-				entity->stats.call_time = 0;
-			memcpy(&stats, &entity->stats, sizeof(b2bl_dlg_stat_t));
-			stats.key.s = (char*)pkg_malloc(tuple->key->len);
-			if(stats.key.s == NULL)
-			{
-				LM_ERR("No more memory\n");
-				goto error;
-			}
-			memcpy(stats.key.s, tuple->key->s, tuple->key->len);
-			stats.key.len = tuple->key->len;
-			ekey.s = (char*)pkg_malloc(entity->key.len);
-			if(ekey.s == NULL)
-			{
-				LM_ERR("No more memory\n");
-				pkg_free(stats.key.s);
-				goto error;
-			}
-			memcpy(ekey.s, entity->key.s, entity->key.len);
-			ekey.len = entity->key.len;
-			cb_params.stat = &stats;
-			cb_params.msg = msg;
-			cb_params.entity = entity->no;
-
-			lock_release(&b2bl_htable[hash_index].lock);
-			LM_DBG("entity->no = %d\n", entity->no);
-			ret = cbf(&cb_params, B2B_BYE_CB);
-			LM_DBG("ret = %d, peer= %p\n", ret, peer);
-
-			pkg_free(stats.key.s);
-			lock_get(&b2bl_htable[hash_index].lock);
-			/* must search the tuple again
-			 * you can't know what might have happened with it */
-			if (0!=post_cb_sanity_check(&tuple, hash_index, local_index,
-						&entity, entity->type, &ekey))
-			{
-				pkg_free(ekey.s);
-				goto error;
-			}
-			pkg_free(ekey.s);
-
-			peer = entity->peer;
-			if(ret< B2B_DROP_MSG_CB_RET )
-			{
-				LM_ERR("The callback function was unsuccessful\n");
-				goto send_usual_request;
-			}
-			else
-			if(ret == B2B_DROP_MSG_CB_RET)
-			{
-				entity->peer = 0;
-				/* send 200 OK for BYE */
-				memset(&rpl_data, 0, sizeof(b2b_rpl_data_t));
-				PREP_RPL_DATA(entity);
-				rpl_data.method =METHOD_BYE;
-				rpl_data.code =200;
-				rpl_data.text =&ok;
-				b2b_api.send_reply(&rpl_data);
-				b2bl_delete_entity(entity, tuple);
-				entity = NULL;
-				goto done;
-			}
-			else
-			if(ret == B2B_SEND_MSG_CB_RET)
-				goto send_usual_request;
-		}
-
-		if(tuple->scenario_state == B2B_BRIDGING_STATE)
-		{
-			LM_DBG("Scenario is in bridging state\n");
-			if(process_bridge_bye(msg, tuple, entity) < 0)
-			{
-				LM_ERR("Failed to process BYE received in bridging state\n");
-				goto error;
-			}
-			
-			if(tuple->to_del && entity->peer==NULL)
-			{
-				LM_DBG("Delete this b2bl record after process_bridge_bye\n");
-				b2bl_delete(tuple, hash_index, 0);
-				tuple = 0;
-			}
-
-			goto done;
-		}
-		break;
-
-	case B2B_INVITE:
-		if(cbf)
-		{
-			/* saving the entity key for later sanity check */
-			ekey.s = (char*)pkg_malloc(entity->key.len);
-			if(ekey.s == NULL)
-			{
-				LM_ERR("No more memory\n");
-				goto error;
-			}
-			ekey.len = entity->key.len;
-			memcpy(ekey.s, entity->key.s, entity->key.len);
-			LM_DBG("ekey [%p]->[%.*s]\n", &ekey, ekey.len, ekey.s);
-			/* preparing the cb params */
-			memset(&cb_params, 0, sizeof(b2bl_cb_params_t));
-			cb_params.param = tuple->cb_param;
-			cb_params.stat = NULL;
-			cb_params.msg = msg;
-			cb_params.entity = entity->no;
-			lock_release(&b2bl_htable[hash_index].lock);
-
-			LM_DBG("entity->no = %d\n", entity->no);
-			ret = cbf(&cb_params, B2B_RE_INVITE_CB);
-			LM_DBG("ret = %d, peer= %p\n", ret, peer);
-
-			lock_get(&b2bl_htable[hash_index].lock);
-			/* must search the tuple again
-			 * you can't know what might have happened with it */
-			if (0!=post_cb_sanity_check(&tuple, hash_index, local_index,
-						&entity, entity->type, &ekey))
-			{
-				pkg_free(ekey.s);
-				goto error;
-			}
-			pkg_free(ekey.s);
-
-			peer = entity->peer;
-			switch (ret) {
-			case B2B_DROP_MSG_CB_RET:
-				/* send 400 Not Acceptable for INVITE */
-				memset(&rpl_data, 0, sizeof(b2b_rpl_data_t));
-				PREP_RPL_DATA(entity);
-				rpl_data.method =METHOD_INVITE;
-				rpl_data.code =400;
-				rpl_data.text =&notAcceptable;
-				b2b_api.send_reply(&rpl_data);
-				goto done;
-				break;
-			case B2B_SEND_MSG_CB_RET:
-				goto send_usual_request;
-				break;
-			case B2B_FOLLOW_SCENARIO_CB_RET:
-				/* just continue with normal processing */
-				break;
-			case B2B_ERROR_CB_RET:
-				LM_ERR("The callback function was unsuccessful\n");
-				goto send_usual_request;
-				break;
-			default:
-				LM_ERR("Unexpected return code [%d]\n", ret);
-				goto send_usual_request;
-			}
-			
-		}
-		break;
-	}
-
-	if(!scenario || !scenario->request_rules[request_id])
-	{
-		if(request_id == B2B_BYE)
-		{
-			/* even though I don;t receive a reply, 
-			I should delete this record*/
-			tuple->lifetime = 30 + get_ticks();
-		}
-		goto send_usual_request;
-	}
-	else
-	{
-		rule = scenario->request_rules[request_id];
-		if(tuple->scenario_state != B2B_NOTDEF_STATE)
-		{
-			while(rule)
-			{
-				if(tuple->scenario_state == rule->cond_state)
-				{
-					break;
-				}
-				else
-				{
-					LM_DBG("State does not match found [%d], required [%d]\n",
-							tuple->scenario_state, rule->cond_state);
-				}
-				rule = rule->next;
-			}
-		}
-		if(!rule)
-		{
-			LM_DBG("Did not find a rule to apply for this request -> do normal pass through\n");
-			goto send_usual_request;
-		}
-		else
-		{
-			LM_DBG("Found rule with id [%d]\n", rule->id);
-		}
-		/* if a match was found -> check the condition part */
-		if(rule->cond_node)
-		{
-			node = xmlNodeGetChildByName(rule->cond_node, "sender");
-			if(node)
-			{
-				LM_DBG("Found a sender condition\n");
-				/* get the sender type */
-
-				attr.s = (char*)xmlNodeGetNodeContentByName(node, "type", NULL);
-				if(attr.s == NULL)
-				{
-					LM_ERR("Bad scenario document - sender condition node"
-							" without a type child\n");
-					goto error;
-				}
-
-				if(xmlStrcasecmp((unsigned char*)attr.s,(unsigned char*) "server") == 0)
-				{
-					/* check if it is a server request */
-					if(src != B2B_SERVER)
-					{
-						xmlFree(attr.s);
-						goto send_usual_request;
-					}
-				}
-				else
-				if(xmlStrcasecmp((unsigned char*) attr.s, (unsigned char*)"client") == 0)
-				{
-					if(src != B2B_CLIENT)
-					{
-						xmlFree(attr.s);
-						goto send_usual_request;
-					}
-				}
-				else
-				{
-					LM_ERR("Bad scenario document - sender condition type not"
-							" known\n");
-					xmlFree(attr.s);
-					goto error;
-				}
-				xmlFree(attr.s);
-
-				/* check the id */
-				attr.s = xmlNodeGetNodeContentByName(node, "id", NULL);
-				if(attr.s)
-				{
-					attr.len = strlen(attr.s);
-					if((attr.len != entity->scenario_id.len ||
-							strncmp(attr.s, entity->scenario_id.s, attr.len) != 0))
-					{
-						LM_DBG("Scenary id did not match - do not apply the rule"
-								" found [%.*s] , required [%s]\n", 
-								entity->scenario_id.len, entity->scenario_id.s, attr.s);
-						xmlFree(attr.s);
-						goto send_usual_request;
-					}
-					xmlFree(attr.s);
-				}
-				LM_DBG("Sender condition match\n");
-			}
-			/* TODO - process other conditions */
-		}
-
-		/* apply actions */
-
-		/* get next state */
-		node = xmlNodeGetChildByName(rule->action_node, "state");
-		if(node)
-		{
-			attr.s = (char*)xmlNodeGetContent(node);
-			if(attr.s == NULL)
-			{
-				LM_ERR("No state node content found\n");
-				goto error;
-			}
-			attr.len = strlen(attr.s);
-
-			if(str2int(&attr, (unsigned int*)&state)< 0)
-			{
-				LM_ERR("Bad scenario. Scenary state not an integer\n");
-				xmlFree(attr.s);
-				goto error;
-			}
-			LM_DBG("Next scenario state is [%d]\n", state);
-			xmlFree(attr.s);
-		}
-
-		/* handle bridge action */
-
-		bridge_node = xmlNodeGetChildByName(rule->action_node, "bridge");
-		if(bridge_node)
-		{
-			LM_DBG("Found a bridge node\n");
-
-			if(process_bridge_action(msg, entity, tuple, bridge_node) < 0)
-			{
-				LM_ERR("Failed to process bridge action\n");
-				goto send_usual_request;
-			}
-			/* save next state */
-			tuple->next_scenario_state = state;
-		}
-		else
-		{
-			/* set the next state now because the action has only one step */
-			if(state >= 0)
-				tuple->scenario_state = state;
-		}
-
-		node = xmlNodeGetChildByName(rule->action_node, "send_reply");
-		if(node)
-		{
-			unsigned int code;
-
-			LM_DBG("Found a send reply node\n");
-			/* get code and text */
-			attr.s = xmlNodeGetNodeContentByName(node, "code", NULL);
-			if(attr.s == NULL)
-			{
-				LM_ERR("Bad scenario document - No code defined for send_reply node\n");
-				goto error;
-			}
-			attr.len = strlen(attr.s);
-			if(str2int(&attr, &code) < 0)
-			{
-				LM_ERR("Bad scenario - wrong reply code, not an integer\n");
-				xmlFree(attr.s);
-				goto error;
-			}
-			xmlFree(attr.s);
-
-			attr.s = xmlNodeGetNodeContentByName(node, "reason", NULL);
-			if(attr.s == NULL)
-			{
-				LM_ERR("Bad scenario document - No code defined for send_reply node\n");
-				goto error;
-			}
-			attr.len = strlen(attr.s);
-
-			memset(&rpl_data, 0, sizeof(b2b_rpl_data_t));
-			PREP_RPL_DATA(entity);
-			rpl_data.method =method_value;
-			rpl_data.code =code;
-			rpl_data.text =&attr;
-			b2b_api.send_reply(&rpl_data);
-			LM_DBG("Send reply with code [%d] and text [%s]\n", code, attr.s);
-
-			xmlFree(attr.s);
-		}
-		/* end_dialog_leg option */
-		node = xmlNodeGetChildByName(rule->action_node, "end_dialog_leg");
-		if(node)
-		{
-			LM_DBG("End dialog\n");
-			entity->disconnected = 1;
-			memset(&req_data, 0, sizeof(b2b_req_data_t));
-			PREP_REQ_DATA(entity);
-			req_data.method =&method_bye;
-			b2b_api.send_request(&req_data);
-			if(entity->peer)
-				entity->peer->peer = NULL;
-			peer = entity->peer = NULL;
-		}
-
-		node = xmlNodeGetChildByName(rule->action_node, "delete_entity");
-		if(node)
-		{
-			if(entity->peer)
-				entity->peer->peer = 0;
-			b2bl_delete_entity(entity, tuple);
-			entity = NULL;
-			LM_DBG("Deleted current entity\n");
-		}
-	}
-
-	goto done;
-
-send_usual_request:
-		switch (request_id)
-		{
-		case B2B_CANCEL:
-			tuple->scenario_state = B2B_CANCEL_STATE;
-			break;
-
-		case B2B_BYE:
-			if(!peer || !peer->key.s)
-			{
-				memset(&rpl_data, 0, sizeof(b2b_rpl_data_t));
-				PREP_RPL_DATA(entity);
-				rpl_data.method =METHOD_BYE;
-				rpl_data.code =200;
-				rpl_data.text =&ok;
-				b2b_api.send_reply(&rpl_data);
-				b2bl_delete(tuple, hash_index, 0);
-				tuple = 0;
-				goto done;
-			}
-			else
-				b2b_mark_todel(tuple);
-			break;
-		}
-
-		while (peer && peer->key.s)
-		{
-			LM_DBG("Send request [%.*s] to peer [%.*s]\n",
-				method.len, method.s, peer->key.len, peer->key.s);
-			memset(&req_data, 0, sizeof(b2b_req_data_t));
-			PREP_REQ_DATA(peer);
-			req_data.method =&method;
-			req_data.extra_headers =extra_headers->len?extra_headers:NULL;
-			req_data.body =body->len?body:NULL;
-			if(b2b_api.send_request(&req_data) < 0)
-			{
-				LM_ERR("Sending request failed [%.*s]\n", peer->key.len, peer->key.s);
-			}
-			peer = peer->next;
-		}
-
-done:
-	if(tuple)
-	{
-		if(b2bl_db_mode == WRITE_THROUGH)
-			b2bl_db_update(tuple);
-		else
-			UPDATE_DBFLAG(tuple, tuple->db_flag);
-	}
-
-	lock_release(&b2bl_htable[hash_index].lock);
-	return 0;
-
-error:
-	lock_release(&b2bl_htable[hash_index].lock);
-	return -1;
-}
-
-
-int b2b_logic_notify(int src, struct sip_msg* msg, str* key, int type, void* param)
-{
-	unsigned int hash_index, local_index;
-	unsigned int hash_idx, local_idx;
-	str entity_key = {NULL, 0};
-	b2bl_tuple_t* tuple;
-	str* b2bl_key = (str*)param;
-	str body= {NULL, 0};
-	str extra_headers = {NULL, 0};
-	str new_body={NULL, 0};
-	int ret = -1;
-#define H_SIZE 2
-	str h_name[H_SIZE];
-	str h_val[H_SIZE];
-	str rt_header;
-	str* replaces = NULL;
-	char tuple_buf[B2BL_MAX_KEY_LEN];
-	str tuple_key;
-#define U_REPLACES_BUF_LEN 512
-	char u_replaces_buf[U_REPLACES_BUF_LEN];
-	str u_replaces;
-	//str u_replaces = {NULL, 0};
-#define RT_BUF_LEN 1024
-	char rt_buf[RT_BUF_LEN];
-	str rt;
-	struct replaces_body replaces_b;
-	struct b2bl_entity_id* r_peer = NULL;
-	int i;
-
-	if(b2bl_key == NULL)
-	{
-		LM_ERR("'param' argument NULL\n");
-		return -1;
-	}
-	if(key == NULL)
-	{
-		LM_ERR("'key' argument NULL\n");
-		return -1;
-	}
-
-	if(b2bl_parse_key(b2bl_key, &hash_index, &local_index)< 0)
-	{
-		LM_ERR("Failed to parse b2b logic key [%.*s]\n", b2bl_key->len, b2bl_key->s);
-		return -1;
-	}
-
-	if (parse_headers(msg, HDR_EOH_F, 0) < 0)
-	{
-		LM_ERR("failed to parse message\n");
-		return -1;
-	}
-
-	/* extract body if it has one */
-	/* process the body */
-	if(msg->content_length)
-	{
-		/* apply body lumps if there are any */
-		if(msg->body_lumps)
-		{
-			if(b2b_apply_body_lumps(msg, &new_body) < 0)
-			{
-				LM_ERR("failed to apply lumps\n");
-			}
-			body = new_body;
-		}
-		else
-		{
-			body.len = get_content_length(msg);
-			if(body.len != 0 )
-			{
-				body.s=get_body(msg);
-				if (body.s== NULL) 
-				{
-					LM_ERR("cannot extract body\n");
-					return -1;
-				}
-			}
-		}
-	}
-
-	LM_DBG("b2b_entities notification cb for [%.*s] with entity [%.*s]\n",
-			b2bl_key->len, b2bl_key->s, key->len, key->s);
-
-	if(type == B2B_REPLY)
-	{
-		/* build extra headers */
-		if(b2b_extra_headers(msg, NULL, NULL, &extra_headers)< 0)
-		{
-			LM_ERR("Failed to construct extra headers\n");
-			goto done;
-		}
-		ret = b2b_logic_notify_reply(src, msg, key, &body, &extra_headers,
-						b2bl_key, hash_index, local_index);
-	}
-	else
-	if(type == B2B_REQUEST)
-	{
-		if(msg->first_line.u.request.method_value==METHOD_REFER &&
-			parse_refer_to_header(msg)==0 && msg->refer_to!=NULL &&
-			get_refer_to(msg)!=NULL && parse_uri(get_refer_to(msg)->uri.s,
-							get_refer_to(msg)->uri.len,
-							&(get_refer_to(msg)->parsed_uri))==0)
-		{
-			/* We have a Refer-To header */
-			if(get_refer_to(msg)->parsed_uri.headers.s &&
-				parse_uri_headers(get_refer_to(msg)->parsed_uri.headers,
-								h_name,h_val,H_SIZE)==0)
-			{
-				for(i=0; i<H_SIZE && h_name[i].s && h_name[i].len; i++)
-					if(strncmp("Replaces",h_name[i].s,h_name[i].len)==0)
-					{
-						replaces = &h_val[i];
-						break;
-					}
-			}
-			if(replaces)
-			{
-				//LM_DBG("Replaces=[%.*s]\n",replaces->len,replaces->s);
-				u_replaces.s = &u_replaces_buf[0];
-				u_replaces.len = U_REPLACES_BUF_LEN;
-				if(unescape_param(replaces,&u_replaces)!=0)
-				{
-					LM_ERR("unable to escape [%.*s]\n",
-						replaces->len, replaces->s);
-					goto done;
-				}
-				//LM_DBG("[%.*s]\n", u_replaces.len, u_replaces.s);
-				if(parse_replaces_body(u_replaces.s, u_replaces.len,
-						&replaces_b)<0 ||
-						!replaces_b.callid_val.s ||
-						!replaces_b.to_tag_val.s ||
-						!replaces_b.from_tag_val.s)
-				{
-					LM_ERR("unable to parse replaces header [%.*s]\n",
-						u_replaces.len, u_replaces.s);
-					goto done;
-				}
-				tuple_key.s = tuple_buf;
-				tuple_key.len = B2BL_MAX_KEY_LEN;
-				if(b2b_api.get_b2bl_key(&replaces_b.callid_val,
-						&replaces_b.from_tag_val,
-						&replaces_b.to_tag_val,
-						&entity_key,
-						&tuple_key)!=0)
-				{
-					LM_ERR("no b2bl key for [%.*s][%.*s][%.*s]\n",
-							replaces_b.callid_val.len,
-							replaces_b.callid_val.s,
-							replaces_b.to_tag_val.len,
-							replaces_b.to_tag_val.s,
-							replaces_b.from_tag_val.len,
-							replaces_b.from_tag_val.s);
-					goto done;
-				}
-				if(b2bl_parse_key(&tuple_key, &hash_idx,&local_idx)< 0)
-				{
-					LM_ERR("Failed to parse b2b logic key [%.*s]\n",
-						tuple_key.len, tuple_key.s);
-					goto done;
-				}
-				LM_DBG("Need to replace callid=[%.*s] to-tag=[%.*s] and "
-					"from-tag=[%.*s] from b2b_logic [%.*s]\n",
-					replaces_b.callid_val.len, replaces_b.callid_val.s,
-					replaces_b.to_tag_val.len, replaces_b.to_tag_val.s,
-					replaces_b.from_tag_val.len, replaces_b.from_tag_val.s,
-					tuple_key.len, tuple_key.s);
-				/* reset the replaces parsed structure */
-				memset(&replaces_b, 0, sizeof(struct replaces_body));
-
-				lock_get(&b2bl_htable[hash_idx].lock);
-				tuple=b2bl_search_tuple_safe(hash_idx, local_idx);
-				if(tuple == NULL)
-				{
-					LM_ERR("B2B logic record not found\n");
-					lock_release(&b2bl_htable[hash_idx].lock);
-					goto done;
-				}
-				b2bl_print_tuple(tuple, L_ERR);
-				for(i=0;i<MAX_B2BL_ENT;i++)
-				{
-					if(tuple->servers[i] &&
-						tuple->servers[i]->key.len==entity_key.len &&
-						strncmp(tuple->servers[i]->key.s,
-							entity_key.s, entity_key.len)==0)
-					{
-						r_peer = tuple->servers[i]->peer;
-						break;
-					}
-				}
-				lock_release(&b2bl_htable[hash_idx].lock);
-
-				if(!r_peer)
-				{
-					LM_ERR("no replaces peer\n");
-					goto done;
-				}
-				LM_DBG("got replacement callid=[%.*s] "
-					"to-tag=[%.*s] and from-tag=[%.*s]\n",
-					r_peer->dlginfo->callid.len, r_peer->dlginfo->callid.s,
-					r_peer->dlginfo->totag.len, r_peer->dlginfo->totag.s,
-					r_peer->dlginfo->fromtag.len, r_peer->dlginfo->fromtag.s);
-
-				/* build the escaped Replaces URI header
-				 * Note: dlginfo->totag becomes from-tag in Replaces URI header
-				 *       dlginfo->fromtag becomes to-tag in Replaces URI header
-				 */
-				u_replaces.s = &u_replaces_buf[0];
-				i = r_peer->dlginfo->callid.len + r_peer->dlginfo->fromtag.len +
-					r_peer->dlginfo->totag.len + 18 /* 2x'=' + 2x'=' + ft */;
-				if (U_REPLACES_BUF_LEN < i)
-				{
-					LM_ERR("not enough space in the buffer: "
-						"U_REPLACES_BUF_LEN < %d\n", i);
-				}
-				memcpy(u_replaces.s,
-					r_peer->dlginfo->callid.s, r_peer->dlginfo->callid.len);
-				i = r_peer->dlginfo->callid.len;
-				u_replaces_buf[i] = ';';
-				i++;
-				memcpy(u_replaces.s + i, "from-tag", strlen("from-tag"));
-				i += strlen("from-tag");
-				u_replaces_buf[i] = '=';
-				i++;
-				memcpy(u_replaces.s + i,
-					r_peer->dlginfo->totag.s, r_peer->dlginfo->totag.len);
-				i += r_peer->dlginfo->totag.len;
-				u_replaces_buf[i] = ';';
-				i++;
-				memcpy(u_replaces.s + i, "to-tag", strlen("to-tag"));
-				i += strlen("to-tag");
-				u_replaces_buf[i] = '=';
-				i++;
-				memcpy(u_replaces.s + i,
-					r_peer->dlginfo->fromtag.s, r_peer->dlginfo->fromtag.len);
-				i += r_peer->dlginfo->fromtag.len;
-				u_replaces.len = i;
-
-				/* build the new Refer-To header
-				 * Note: for now, we ignore the "early-only" parameter
-				 */
-				i = (int)(replaces->s - msg->refer_to->name.s);
-				if(i>=RT_BUF_LEN)
-				{
-					LM_ERR("Not enough space to build Refer-To: "
-								"%d>=RT_BUF_LEN\n", i);
-					goto done;
-				}
-				memcpy(&rt_buf[0], msg->refer_to->name.s, i);
-				rt.s = &rt_buf[i];
-				rt.len = RT_BUF_LEN - i;
-				if(escape_param(&u_replaces, &rt)!=0)
-				{
-					LM_ERR("Unable to escape [%.*s] with len [%d] in char[%d]\n",
-						u_replaces.len,u_replaces.s, u_replaces.len, rt.len);
-					goto done;
-				}
-				//LM_DBG("escaped replaces [%.*s]\n", rt.len, rt.s);
-				i = (int)(msg->refer_to->name.s + msg->refer_to->len -
-						replaces->s - replaces->len);
-				if(RT_BUF_LEN<=(int)(rt.s - &rt_buf[0] + rt.len + i))
-				{
-					LM_ERR("Not enough space to build Refer-To: "
-						"RT_BUF_LEN<=[%d]\n",
-						(int)(rt.s - &rt_buf[0] + rt.len + i));
-					goto done;
-				}
-				memcpy(rt.s + rt.len, replaces->s + replaces->len, i);
-				rt.len = (int)(rt.s + rt.len + i - &rt_buf[0]);
-				rt.s = &rt_buf[0];
-				LM_DBG("New Refer-To: [%.*s]\n", rt.len, rt.s);
-
-				/* build extra headers */
-				if(b2b_extra_headers(msg, NULL, &rt, &extra_headers)< 0)
-				{
-					LM_ERR("Failed to construct extra headers\n");
-					goto done;
-				}
-			}
-			else
-			{	/* build extra headers */
-				rt_header.s = msg->refer_to->name.s;
-				rt_header.len = msg->refer_to->len;
-				if(b2b_extra_headers(msg, NULL, &rt_header, &extra_headers)< 0)
-				{
-					LM_ERR("Failed to construct extra headers\n");
-					goto done;
-				}
-			}
-		}
-		else
-		{	/* build extra headers */
-			if(b2b_extra_headers(msg, NULL, NULL, &extra_headers)< 0)
-			{
-				LM_ERR("Failed to construct extra headers\n");
-				goto done;
-			}
-		}
-		ret = b2b_logic_notify_request(src, msg, key, &body, &extra_headers,
-		 				b2bl_key, hash_index, local_index);
-	}
-	else
-	{
-		LM_ERR("got notification for [%.*s] from [%.*s] with unknown event type [%d]\n",
-			b2bl_key->len, b2bl_key->s, key->len, key->s, type);
-	}
-done:
-	if(new_body.s)
-		pkg_free(new_body.s);
-	if(extra_headers.s)
-		pkg_free(extra_headers.s);
-	return ret;
-}
-
-
-/* This function does the following actions:
- *	- extract the entities description from the scenario document 
- *	- send invite or reInvite to one of the parties
- *	 - mark in the scenario instantiation which are the bridged entities and
- *	 that this scenario is currently taking place
- *	*/
-
-int process_bridge_action(struct sip_msg* msg, b2bl_entity_id_t* curr_entity,
-		b2bl_tuple_t* tuple, xmlNodePtr bridge_node)
-{
-
-	b2bl_entity_id_t* bridge_entities[3];
-	b2bl_entity_id_t* entity = NULL;
-	b2bl_entity_id_t* old_entity= NULL;
-	b2bl_entity_id_t* e;
-	int count = 0;
-	int index = 0;
-	str attr= {NULL, 0};
-	str entity_dest;
-	xmlNodePtr clientid_node;
-	xmlNodePtr dest_node;
-	xmlNodePtr client_node;
-	xmlNodePtr lft_node;
-	xmlNodePtr node;
-	str provmedia_uri={NULL,0};
-	client_info_t ci;
-	str* client_id;
-	char* fdname_content= 0;
-	str from_dname= {NULL, 0};
-	xmlNodePtr value_node;
-	char* value_content= 0;
-	b2b_req_data_t req_data;
-
-	/* extract provisional media uri if exists */
-	node = xmlNodeGetChildByName(bridge_node, "provisional_media");
-	if(node)
-	{
-		provmedia_uri.s = (char*)xmlNodeGetContent(node);
-		if(provmedia_uri.s)
-			provmedia_uri.len = strlen(provmedia_uri.s);
-	}
-	memset(bridge_entities, 0, 3*sizeof(b2bl_entity_id_t*));
-
-	for(client_node= bridge_node->children; client_node;
-			client_node=client_node->next)
-	{
-		if(xmlStrcasecmp(client_node->name, (unsigned char*)"client")!=0 &&
-			xmlStrcasecmp(client_node->name, (unsigned char*)"server")!=0)
-			continue;
-
-		if(count == 2)
-		{
-			LM_ERR("Bad scenario document. Too many entities defined for"
-				" bridge node. Only two entities should be defined\n");
-			break;
-		}
-		entity = NULL;
-		/* there are 3 ways to identify a client: "this", "peer" or "id" */
-		clientid_node = xmlNodeGetChildByName(client_node, "this");
-		if(clientid_node)
-		{
-			LM_DBG("Selected current entity\n");
-			if(curr_entity == NULL)
-			{
-				LM_DBG("You are not allowed to use a 'this' client "
-						"specification for this type of route\n");
-				goto error;
-			}
-			entity = curr_entity;
-			goto entity_search_done;
-		}
-
-		clientid_node = xmlNodeGetChildByName(client_node, "peer");
-		if(clientid_node)
-		{
-			LM_DBG("Selected peer entity\n");
-			if(curr_entity == NULL)
-			{
-				LM_DBG("You are not allowed to use a 'this' client "
-						"specification for this type of route\n");
-				goto error;
-			}
-
-			if(curr_entity->peer == NULL)
-			{
-				LM_ERR("Requested for the peer entity of the current entity, but it is NULL.\n");
-				goto error;
-			}
-			entity = curr_entity->peer;
-			goto entity_search_done;
-		}
-
-		/* extract entity id */
-		attr.s = (char*)xmlNodeGetNodeContentByName(client_node, "id", NULL);
-		if(attr.s == NULL)
-		{
-			LM_ERR("Entity specification not valid. Accepted values:"
-					" this, peer or id\n");
-			goto error;
-		}
-		attr.len = strlen(attr.s);
-
-		/* search through the entities */
-		for (index = 0; index < MAX_B2BL_ENT; index++)
-		{
-			e = tuple->servers[index];
-			if(e)
-			{
-				if(e->next || e->prev)
-				{
-					LM_ERR("Inconsistent entity [%p]\n", old_entity);
-					b2bl_print_tuple(tuple, L_ERR);
-					goto error;
-				}
-				if (e->scenario_id.len == attr.len &&
-					strncmp(e->scenario_id.s, attr.s, attr.len)== 0)
-				{
-					entity = e;
-					LM_DBG("Found entity server [%d]\n", count);
-					break;
-				}
-			}
-			e = tuple->clients[index];
-			if(e)
-			{
-				if(e->next || e->prev)
-				{
-					LM_ERR("Inconsistent entity [%p]\n", old_entity);
-					b2bl_print_tuple(tuple, L_ERR);
-					goto error;
-				}
-				if (e && e->scenario_id.len == attr.len &&
-					strncmp(e->scenario_id.s, attr.s, attr.len)== 0)
-				{
-					entity = e;
-					LM_DBG("Found entity client [%d]\n", count);
-					break;
-				}
-			}
-		}
-		/* if I have the 'new' child -> alter the scenario id for the old entity */
-		if ((xmlNodeGetChildByName(client_node, "destination")
-			|| xmlNodeGetChildByName(client_node, "new")) && entity)
-		{
-			/* write '<' everywhere - it's safe since it's not accepted in xml */
-			memset(entity->scenario_id.s, '<', entity->scenario_id.len);
-			entity = NULL;
-		}
-
-entity_search_done:
-
-		/* must create a new client entity */
-		if(entity == NULL)
-		{
-			/* get the destination */
-			LM_DBG("Entity %d for bridge - new client entity\n", count);
-			dest_node = xmlNodeGetChildByName(client_node, "destination");
-			if(dest_node == NULL)
-			{
-				LM_ERR("Bad format for b2b scenario. New entity without a destination\n");
-				goto error;
-			}
-			value_node = xmlNodeGetChildByName(dest_node, "value");
-			if(value_node == NULL)
-			{
-				LM_ERR("Bad format for b2b scenario. New entity without a destination\n");
-				goto error;
-			}
-			value_content = (char*)xmlNodeGetContent(value_node);
-			if(value_content == NULL)
-			{
-				LM_ERR("Bad formated scenario document. URI value empty\n");
-				goto error;
-			}
-			if(b2b_scenario_parse_uri(value_node, value_content, tuple, msg,
-						&entity_dest) < 0)
-			{
-				LM_ERR("Failed to parse entity destination specification\n");
-				xmlFree(value_content);
-				goto error;
-			}
-			node = xmlNodeGetChildByName(client_node, "from_dname");
-			if(node)
-			{
-				value_node = xmlNodeGetChildByName(node, "value");
-				if(value_node == NULL)
-				{
-					LM_ERR("Bad format for b2b scenario. New entity without a destination\n");
-					xmlFree(value_content);
-					goto error;
-				}
-				fdname_content = (char*)xmlNodeGetContent(value_node);
-				if(fdname_content == NULL)
-				{
-					LM_ERR("Bad formated scenario document. URI value empty\n");
-					xmlFree(value_content);
-					goto error;
-				}
-				if(b2b_scenario_parse_uri(value_node, fdname_content, tuple, msg,
-						&from_dname) < 0)
-				{
-					LM_DBG("Failed to parse entity destination specification\n");
-					xmlFree(value_content);
-					goto error;
-				}
-				
-			}
-			LM_DBG("New entity, dest = [%.*s]\n", entity_dest.len, entity_dest.s);
-			entity = b2bl_create_new_entity(B2B_CLIENT, 0, &entity_dest, 0,
-					from_dname.s?&from_dname:0, &attr, 0);
-	
-			if(fdname_content)
-				xmlFree(fdname_content);
-			fdname_content = 0;
-			from_dname.s=0;
-			xmlFree(value_content);
-			if(entity == NULL)
-			{
-				LM_ERR("Failed to create new b2b entity\n");
-				goto error;
-			}
-		}
-		else
-			old_entity = entity;
-
-		if(attr.s)
-			xmlFree(attr.s);
-		attr.s = NULL;
-		bridge_entities[count++] = entity;
-	}
-
-	if(bridge_entities[1] == bridge_entities[0])
-	{
-		LM_ERR("The scenario tells to bridge the same entity\n");
-		goto error;
-	}
-
-	/* arrange the entities in vector to have the old first */
-	if(old_entity && bridge_entities[0]!= old_entity)
-	{
-		bridge_entities[1] = bridge_entities[0];
-		bridge_entities[0] = old_entity;
-	}
-
-	/* I have the two entities ->  now do the first step of the bridging scenario 
-	 * -> send reInvite or Invite to one of the parties */
-	if(old_entity)
-	{
-		LM_DBG("Sent reInvite without a body to old entity\n");
-		tuple->bridge_entities[0]= bridge_entities[0];
-		tuple->bridge_entities[1]= bridge_entities[1];
-
-		if(provmedia_uri.s)
-		{
-			tuple->bridge_entities[2]= bridge_entities[1];
-
-			tuple->bridge_entities[1] = b2bl_create_new_entity(B2B_CLIENT, 0, &provmedia_uri, 0, 0,0, 0);
-			if(tuple->bridge_entities[1] == NULL)
-			{
-				LM_ERR("Failed to create new b2b entity\n");
-				goto error;
-			}
-		}
-		old_entity->stats.start_time = get_ticks();
-		old_entity->stats.call_time = 0;
-		/* TODO -> Do I need some other info here? */
-		memset(&req_data, 0, sizeof(b2b_req_data_t));
-		PREP_REQ_DATA(old_entity);
-		req_data.method =&method_invite;
-		req_data.extra_headers = NULL;
-		b2b_api.send_request(&req_data);
-		old_entity->state = 0;
-	}
-	else
-	{
-		str from_uri   = bridge_entities[1]->to_uri;
-		str to_uri     = bridge_entities[0]->to_uri;
-		str from_dname = bridge_entities[0]->from_dname;
-
-		memset(&ci, 0, sizeof(client_info_t));
-		ci.method        = method_invite;
-		ci.to_uri        = to_uri;
-		ci.from_uri      = from_uri;
-		ci.from_dname    = from_dname;
-		ci.extra_headers = tuple->extra_headers;
-		ci.body          = 0;
-		ci.from_tag      = 0;
-		ci.send_sock     = msg?(msg->force_send_socket?msg->force_send_socket:msg->rcv.bind_address):0;
-		get_local_contact( ci.send_sock, &ci.local_contact);
-
-		if(msg)
-		{
-			if (str2int( &(get_cseq(msg)->number), &ci.cseq)!=0 )
-			{
-				LM_ERR("cannot parse cseq number\n");
-				goto error1;
-			}
-		}
-		LM_DBG("Send Invite without a body to a new client entity\n");
-		client_id = b2b_api.client_new(&ci, b2b_client_notify,
-				b2b_add_dlginfo, tuple->key);
-		if(client_id == NULL)
-		{
-			LM_ERR("Failed to create new client entity\n");
-			goto error1;
-		}
-		/* save the client_id in the structure */
-		entity = b2bl_create_new_entity(B2B_CLIENT, client_id, &to_uri,
-				&from_uri,0,&bridge_entities[0]->scenario_id, 0);
-		if(entity == NULL)
-		{
-			LM_ERR("failed to create new client entity\n");
-			pkg_free(client_id);
-			goto error1;
-		}
-		pkg_free(client_id);
-		entity->stats.call_time = get_ticks();
-		entity->type = B2B_CLIENT;
-		entity->peer = bridge_entities[1];
-		shm_free(bridge_entities[0]);
-
-		tuple->bridge_entities[0] = entity;
-		tuple->bridge_entities[1]= bridge_entities[1];
-
-		if (0 != b2bl_add_client(tuple, entity))
-			goto error1;
-	}
-	/* save the pointers to the bridged entities ;
-	 * the first (index 0) is the one we sent the first message ( reInvite or Invite)*/
-	tuple->scenario_state = B2B_BRIDGING_STATE;
-
-	/* extract the lifetime if one is defined */
-	lft_node = xmlNodeGetChildByName(bridge_node, "lifetime");
-	if(lft_node)
-	{
-		attr.s = (char*)xmlNodeGetContent(lft_node);
-		if(attr.s == NULL)
-		{
-			LM_ERR("Failed to extract node content\n");
-			goto error;
-		}
-		attr.len = strlen(attr.s);
-		if(str2int(&attr, &tuple->lifetime)< 0)
-		{
-			LM_ERR("Wrong scenario document. The lifetime value is not an integer");
-			xmlFree(attr.s);
-			goto error;
-		}
-		xmlFree(attr.s);
-		attr.s = NULL;
-		LM_DBG("Lifetime defined = [%d]\n", tuple->lifetime);
-		tuple->lifetime+= get_ticks();
-	}
-	else
-		tuple->lifetime = -1;
-
-	LM_DBG("be[0]= %p, be1=[%p]\n", tuple->bridge_entities[0], tuple->bridge_entities[1]);
-	return 0;
-
-error1:
-	shm_free(bridge_entities[0]);
-	shm_free(bridge_entities[1]);
-
-error:
-	if(attr.s)
-		xmlFree(attr.s);
-	return -1;
-}
-
-int b2b_server_notify(struct sip_msg* msg, str* key, int type, void* param)
-{
-	return b2b_logic_notify(B2B_SERVER, msg, key, type, param);
-}
-
-
-int b2b_client_notify(struct sip_msg* msg, str* key, int type, void* param)
-{
-	return b2b_logic_notify(B2B_CLIENT, msg, key, type, param);
-}
-
-static char fromtag_buf[MD5_LEN];
-static void gen_fromtag(str* callid, str* fromtag, str* uri, struct sip_msg* msg, str* from_tag_uac)
-{
-	int i = 0;
-	str src[4];
-
-	from_tag_uac->len = MD5_LEN;
-	from_tag_uac->s = fromtag_buf;
-
-	src[i++] = *callid;
-	src[i++] = *fromtag;
-	src[i++] = *uri;
-	if(msg)
-		src[i++] = msg->via1->branch->value;
-	MD5StringArray(from_tag_uac->s, src, i);
-	LM_DBG("Gen from_tag= %s\n", fromtag_buf);
-}
-
-
-str* create_top_hiding_entities(struct sip_msg* msg, b2bl_cback_f cbf,
-		void* cb_param, unsigned int cb_mask, str* custom_hdrs)
-{
-	str* server_id = NULL;
-	str* client_id = NULL;
-	str body = {NULL, 0};
-	str extra_headers = {NULL, 0};
-	str* b2bl_key;
-	b2bl_tuple_t* tuple;
-	unsigned int hash_index;
-	b2b_dlginfo_t* dlginfo, dlginfo_s;
-	client_info_t ci;
-	str to_uri={NULL, 0}, from_uri, from_dname;
-	b2bl_entity_id_t* client_entity = NULL;
-	int idx;
-	str uri;
-	qvalue_t q;
-	str from_tag_gen= {0, 0};
-	str new_body={0, 0};
-
-	if(b2b_msg_get_from(msg, &from_uri, &from_dname)< 0 ||  b2b_msg_get_to(msg, &to_uri)< 0)
-	{
-		LM_ERR("Failed to get to or from from the message\n");
-		return NULL;
-	}
-
-	/* process the body */
-	if(msg->content_length)
-	{
-		/* apply body lumps if there are any */
-		if(msg->body_lumps)
-		{
-			if(b2b_apply_body_lumps(msg, &new_body) < 0)
-			{
-				LM_ERR("failed to apply lumps\n");
-			}
-			body = new_body;
-		}
-		else
-		{
-			body.len = get_content_length(msg);
-			if(body.len != 0 )
-			{
-				body.s=get_body(msg);
-				if (body.s== NULL) 
-				{
-					LM_ERR("cannot extract body\n");
-					return NULL;
-				}
-			}
-		}
-	}
-
-	hash_index = core_hash(&to_uri, &from_uri, b2bl_hsize);
-	tuple = b2bl_insert_new(msg, hash_index, NULL, NULL, NULL,
-				custom_hdrs, -1, &b2bl_key, INSERTDB_FLAG);
-	if(tuple== NULL)
-	{
-		LM_ERR("Failed to insert new scenario instance record\n");
-		goto error;
-	}
-	tuple->cbf = cbf;
-	tuple->cb_mask = cb_mask;
-	tuple->cb_param = cb_param;
-
-	/* if it will not be confirmed -> delete */
-	tuple->lifetime = 60 + get_ticks();
-
-	/* create new server */
-	server_id = b2b_api.server_new(msg, &tuple->local_contact,
-			b2b_server_notify, b2bl_key);
-	if(server_id == NULL)
-	{
-		LM_ERR("failed to create new b2b server instance\n");
-		goto error;
-	}
-
-	tuple->servers[0] = b2bl_create_new_entity(B2B_SERVER, server_id, &to_uri, &from_uri,
-			0,0, msg);
-	if(tuple->servers[0] == NULL)
-	{
-		LM_ERR("Failed to create server entity\n");
-		goto error;
-	}
-	tuple->servers[0]->type = B2B_SERVER;
-	tuple->servers[0]->no = 0;
-
-	if(b2b_extra_headers(msg, b2bl_key, custom_hdrs, &extra_headers)< 0)
-	{
-		LM_ERR("Failed to create extra headers\n");
-		goto error;
-	}
-	/* create new client */
-
-	memset(&ci, 0, sizeof(client_info_t));
-	ci.method        = msg->first_line.u.request.method;
-	ci.req_uri       = *(GET_RURI(msg));
-	ci.to_uri        = to_uri;
-	ci.from_uri      = from_uri;
-	ci.from_dname    = from_dname;
-	ci.dst_uri       = msg->dst_uri;
-	ci.extra_headers = &extra_headers;
-	ci.body          = (body.s?&body:NULL);
-	ci.send_sock     = msg->force_send_socket?msg->force_send_socket:msg->rcv.bind_address;
-	get_local_contact( ci.send_sock, &ci.local_contact);
-
-	dlginfo = tuple->servers[0]->dlginfo;
-	gen_fromtag(&dlginfo->callid, &dlginfo->fromtag, &ci.req_uri, msg, &from_tag_gen);
-	ci.from_tag = &from_tag_gen;
-
-	if (str2int( &(get_cseq(msg)->number), &ci.cseq)!=0 )
-	{
-		LM_ERR("cannot parse cseq number\n");
-		goto error;
-	}
-
-	client_id = b2b_api.client_new(&ci, b2b_client_notify,
-			b2b_add_dlginfo, b2bl_key);
-	if(client_id == NULL)
-	{
-		LM_ERR("failed to create new b2b client instance\n");
-		goto error;
-	}
-
-	client_entity = b2bl_create_new_entity(B2B_CLIENT, client_id, &to_uri, &from_uri,
-			0, 0, 0);
-	if(client_entity == NULL)
-	{
-		LM_ERR("Failed to create server entity\n");
-		goto error;
-	}
-
-	memset(&dlginfo_s, 0, sizeof(b2b_dlginfo_t));
-	dlginfo_s.callid = *client_id;
-	dlginfo_s.totag = from_tag_gen;
-	if(entity_add_dlginfo(client_entity, &dlginfo_s)< 0)
-	{
-		LM_ERR("Failed to add dialoginfo\n");
-		goto error;
-	}
-
-	client_entity->no = 1;
-	client_entity->peer = tuple->servers[0];
-	tuple->clients[0] = client_entity;
-
-	for( idx=0 ; (uri.s=get_branch(idx,&uri.len,&q,0,0,0,0))!=0 ; idx++ )
-	{
-		LM_DBG("got branch ruri [%.*s]\n", uri.len, uri.s);
-		gen_fromtag(&dlginfo->callid, &dlginfo->fromtag, &uri, msg, &from_tag_gen);
-		ci.from_tag = &from_tag_gen;
-		ci.req_uri = uri;
-		client_id = b2b_api.client_new(&ci, b2b_client_notify,
-			b2b_add_dlginfo, b2bl_key);
-		if(client_id == NULL)
-		{
-			LM_ERR("failed to create new b2b client instance\n");
-			goto error;
-		}
-		client_entity = b2bl_create_new_entity(B2B_CLIENT, client_id, &to_uri, &from_uri,
-			0, 0, 0);
-		if (client_entity == NULL)
-		{
-			LM_ERR("Failed to create client entity\n");
-			goto error;
-		}
-		client_entity->no = 1;
-		client_entity->peer = tuple->servers[0];
-
-		memset(&dlginfo_s, 0, sizeof(b2b_dlginfo_t));
-		dlginfo_s.callid = *client_id;
-		dlginfo_s.totag = from_tag_gen;
-		if(entity_add_dlginfo(client_entity, &dlginfo_s)< 0)
-		{
-			LM_ERR("Failed to add dialoginfo\n");
-			goto error;
-		}
-
-		/* Add the client entity to the list */
-		tuple->clients[0]->prev = client_entity;
-		client_entity->next = tuple->clients[0];
-		tuple->clients[0] = client_entity;
-	}
-
-	tuple->servers[0]->peer = tuple->clients[0];
-	tuple->bridge_entities[0] = tuple->servers[0];
-	tuple->bridge_entities[1] = tuple->clients[0];
-	b2bl_print_tuple(tuple, L_DBG);
-
-	if(b2bl_db_mode == WRITE_THROUGH)
-	{
-		b2bl_db_insert(tuple);
-	}
-
-	lock_release(&b2bl_htable[hash_index].lock);
-
-	pkg_free(to_uri.s);
-	pkg_free(server_id);
-	pkg_free(client_id);
-	if(extra_headers.s)
-		pkg_free(extra_headers.s);
-	if(new_body.s)
-		pkg_free(new_body.s);
-	return b2bl_key;
-error:
-	lock_release(&b2bl_htable[hash_index].lock);
-	if(server_id)
-		pkg_free(server_id);
-	if(client_id)
-		pkg_free(client_id);
-	if(to_uri.s)
-		pkg_free(to_uri.s);
-	if(extra_headers.s)
-		pkg_free(extra_headers.s);
-	if(new_body.s)
-		pkg_free(new_body.s);
-	return NULL;
-}
-
-/* Function that processes destination node.
- * Accepted value types:
- *	uri: specified inline
- *	param: specified as a parameter
- *	initial: the initial destination(from the initial message)
- *	header: a header field value
- **/
-
-int b2b_scenario_parse_uri(xmlNodePtr value_node, char* value_content,
-		b2bl_tuple_t* tuple, struct sip_msg* msg, str* client_to)
-{
-
-	str value= {value_content, strlen(value_content)};
-	unsigned char* value_type= NULL;
-	unsigned int param_no;
-	str check_uri;
-
-	value_type = xmlNodeGetAttrContentByName(value_node, "type");
-	if(value_type == NULL)
-	{
-		LM_ERR("Scenary document not well formed. To type param not defined\n");
-		return -1;
-	}
-
-	if(xmlStrcasecmp(value_type, (unsigned char*)"uri") == 0)
-	{
-		LM_DBG("URI of type uri\n");
-		*client_to = value;
-	}
-	else
-	if(xmlStrcasecmp(value_type, (unsigned char*)"param") == 0)
-	{
-		LM_DBG("URI of type param\n");
-
-		if(str2int(&value, &param_no)< 0)
-		{
-			LM_ERR("Scenary document not well formed. Client to param not a number\n");
-			goto error;
-		}
-
-		if(param_no > B2B_INIT_MAX_PARAMNO)
-		{
-			LM_ERR("Scenary document not well formed. Client to param not valid [%d]\n", param_no);
-			goto error;
-		}
-		*client_to = tuple->scenario_params[param_no-1];
-		LM_DBG("URI value taken from a parameter [%.*s]\n",
-				client_to->len, client_to->s);
-	}
-	else
-	if(xmlStrcasecmp(value_type, (unsigned char*)"initial") == 0)
-	{
-		LM_DBG("URI of type initial\n");
-		// FIXME: this may not exist after a transfer that will leave us with two clients
-		if (tuple->servers[0])
-			*client_to = tuple->servers[0]->to_uri;
-	}
-	else
-	if(xmlStrcasecmp(value_type, (unsigned char*)"header") == 0)
-	{
-		struct hdr_field* sip_hdr, hdr;
-		char buf[BUF_LEN];
-		struct sip_uri sip_uri;
-
-		LM_DBG("URI of type header value\n");
-		if(msg == NULL)
-		{
-			LM_DBG("You are not allowed to use a header specification for this type of scenario\n");
-			goto error;
-		}
-		if(BUF_LEN < value.len + 1)
-		{
-			LM_ERR("Buffer overflow\n");
-			goto error;
-		}
-		memcpy(buf, value.s, value.len);
-		buf[value.len] = ':';
-
-		if(parse_hname2(buf, buf + value.len+1, &hdr) < 0)
-		{
-			LM_ERR("Failed to parse header name\n");
-			goto error;
-		}
-		if(hdr.type == HDR_OTHER_T)
-		{
-			LM_DBG("Header other\n");
-			sip_hdr = get_header_by_name(msg, value.s, value.len);
-			if(sip_hdr == NULL)
-			{
-				LM_DBG("No header with the name [%.*s] found\n", value.len, value.s);
-				goto error;
-			}
-		}
-		else
-		if(hdr.type == HDR_ERROR_T)
-		{
-			LM_DBG("Failed to parse header name\n");
-			goto error;
-		}
-		else
-		{
-			sip_hdr = msg->headers;
-			while(sip_hdr && sip_hdr->type != hdr.type)
-				sip_hdr = sip_hdr->next;
-			if(sip_hdr == NULL)
-			{
-				LM_DBG("Did not find header\n");
-				goto error;
-			}
-		}
-		*client_to = sip_hdr->body;
-		trim(client_to);
-		
-		check_uri = *client_to;
-		if(check_uri.s[0] == '<')
-		{
-			check_uri.s++;
-			check_uri.len-=2;
-		}
-		if(parse_uri(check_uri.s, check_uri.len, &sip_uri)< 0)
-		{
-			LM_ERR("Not a valid sip uri [%.*s]\n", check_uri.len, check_uri.s);
-			goto error;
-		}
-	}
-	else
-	{
-		LM_ERR("Scenary document not well formed. Client to type not valid\n");
-		goto error;
-	}
-
-	LM_DBG("URI value = [%.*s]\n", client_to->len, client_to->s);
-
-	xmlFree(value_type);
-
-	return 0;
-
-error:
-	if(value_type)
-		xmlFree(value_type);
-	return -1;
-}
-
-int udh_to_uri(str user, str host, str port, str* uri)
-{
-	int size;
-
-	if(uri==0)
-		return -1;
-	size = user.len + host.len + port.len+7;
-	LM_DBG("user:host:port [%.*s][%.*s][%.*s]\n",
-		user.len, user.s, host.len, host.s, port.len, port.s);
-	uri->s = (char*)pkg_malloc(size);
-	if(uri->s == NULL)
-	{
-		LM_ERR("No more memory [%d]\n", size);
-		return -1;
-	}
-
-	uri->len = sprintf(uri->s, "sip:%.*s@%.*s", user.len, user.s,
-			host.len, host.s);
-	if(port.s)
-	{
-		uri->len += sprintf(uri->s+uri->len, ":%.*s", port.len, port.s);
-	}
-	return 0;
-}
-
-str* b2b_process_scenario_init(b2b_scenario_t* scenario_struct,struct sip_msg* msg,
-	str* args[], b2bl_cback_f cbf, void* cb_param, unsigned int cb_mask, str* custom_hdrs)
-{
-	str* server_id= NULL, *client_id= NULL;
-	str body= {NULL, 0};
-	str method = {INVITE, INVITE_LEN};
-	str* b2bl_key = NULL;
-	b2bl_tuple_t* tuple= NULL;
-	xmlNodePtr node, init_node, node_aux;
-	xmlNodePtr server_node = NULL, clients_node= NULL;
-	str entity_sid;
-	char* type= NULL;
-	str client_to;
-	b2bl_entity_id_t* client_entity = NULL;
-	unsigned int scenario_state = B2B_NOTDEF_STATE;
-	client_info_t ci;
-	int clients_no = 0;
-	unsigned int hash_index;
-	unsigned int index;
-	str to_uri={NULL, 0}, from_uri, from_dname;
-	int eno = 0;
-	str new_body={0, 0};
-
-	if(b2b_msg_get_from(msg, &from_uri, &from_dname)< 0 || b2b_msg_get_to(msg, &to_uri)< 0)
-	{
-		LM_ERR("Failed to get to or from from the message\n");
-		return NULL;
-	}
-	hash_index = core_hash(&to_uri, &from_uri, b2bl_hsize);
-
-	if(msg)
-	{
-		method = msg->first_line.u.request.method;
-
-		/* extract info from the message in case there is a client entity with type message */
-		/* process the body */
-		if(msg->content_length)
-		{
-			/* apply body lumps if there are any */
-			if(msg->body_lumps)
-			{
-				if(b2b_apply_body_lumps(msg, &new_body) < 0)
-				{
-					LM_ERR("failed to apply lumps\n");
-				}
-				body = new_body;
-			}
-			else
-			{
-				body.len = get_content_length(msg);
-				if(body.len != 0 )
-				{
-					body.s=get_body(msg);
-					if (body.s== NULL) 
-					{
-						LM_ERR("cannot extract body\n");
-						goto error;
-					}
-				}
-			}
-		}
-	}
-
-	/* examine the init part in the scenario XML document */
-	init_node = xmlNodeGetChildByName(scenario_struct->init_node, "bridge");
-	if(init_node == NULL)
-	{
-		LM_ERR("Wrong format for b2b scenario document. No bridging node"
-				" inside init node\n");
-		goto error;
-	}
-
-	server_node = xmlNodeGetChildByName(init_node, "server");
-
-	clients_node = xmlNodeGetChildByName(init_node, "client");
-	if(server_node == NULL && clients_node == NULL)
-	{
-		LM_ERR("There must be at least one client or one server entity\n");
-		goto error;
-	}
-
-	/* create new scenario instance record */
-	tuple = b2bl_insert_new(msg, hash_index, scenario_struct,
-			args, body.s?&body:NULL, custom_hdrs, -1,
-			&b2bl_key, INSERTDB_FLAG);
-	if(tuple== NULL)
-	{
-		LM_ERR("Failed to insert new scenario instance record\n");
-		goto error;
-	}
-	tuple->lifetime = 60 + get_ticks();
-
-	/* set the state of the scenario after the init section */
-	node = xmlNodeGetChildByName(scenario_struct->init_node, "state");
-	if(node)
-	{
-		str state_attr;
-		state_attr.s = (char*)xmlNodeGetContent(node);
-		state_attr.len = strlen(state_attr.s);
-
-		if(str2int(&state_attr, &scenario_state)< 0)
-		{
-			LM_ERR("Scenary state after init section not an integer\n");
-			xmlFree(state_attr.s);
-			goto error;
-		}
-		xmlFree(state_attr.s);
-
-		tuple->scenario_state = scenario_state;
-		tuple->next_scenario_state = scenario_state;
-	}
-
-	/* go through the document and create the described entities */
-	if(server_node)
-	{
-		if(msg == NULL)
-		{
-			LM_ERR("A request for a server entity and no message\n");
-			goto error;
-		}
-		/* a server entity can only deal with a message and there can only be one server entity */
-		/* extract the id */
-		entity_sid.s = (char*)xmlNodeGetNodeContentByName(server_node, "id", NULL);
-		if(entity_sid.s == NULL)
-		{
-			LM_ERR("Wrong formatted xml document. Server node without id parameter\n");
-			goto error;
-		}
-		entity_sid.len = strlen(entity_sid.s);
-
-		/* create new server entity */
-		server_id = b2b_api.server_new(msg, &tuple->local_contact,
-				b2b_server_notify, b2bl_key);
-		if(server_id == NULL)
-		{
-			LM_ERR("failed to create new b2b server instance\n");
-			xmlFree(entity_sid.s);
-			goto error;
-		}
-		tuple->servers[0] = b2bl_create_new_entity(B2B_SERVER, server_id, &to_uri,
-				&from_uri,0,&entity_sid,msg);
-		tuple->servers[0]->no = eno++;
-		tuple->bridge_entities[0] = tuple->servers[0];
-		if(tuple->servers[0] == NULL)
-		{
-			LM_ERR("failed to create new server entity\n");
-			xmlFree(entity_sid.s);
-			pkg_free(server_id);
-			goto error;
-		}
-		xmlFree(entity_sid.s);
-		pkg_free(server_id);
-		tuple->servers[0]->type = B2B_SERVER;
-	}
-	pkg_free(to_uri.s);
-	to_uri.s = 0;
-
-	/* create client entities */
-	for(node = clients_node; node; node=node->next)
-	{
-		char* value_content;
-
-		if(xmlStrcasecmp(node->name, (unsigned char*)"client") !=0 )
-			continue;
-
-		entity_sid.s = (char*)xmlNodeGetNodeContentByName(node, "id", NULL);
-		if(entity_sid.s == NULL)
-		{
-			LM_ERR("Wrong formated xml document. Client node without id parameter\n");
-			goto error;
-		}
-		entity_sid.len = strlen(entity_sid.s);
-
-		/* get type*/
-		type = xmlNodeGetNodeContentByName(node, "type", NULL);
-		if(type == NULL)
-		{
-			LM_ERR("Scenary document not well formed. Client Type node not found\n");
-			goto error1;
-		}
-		/* extract destination */
-		node_aux = xmlNodeGetChildByName(node, "destination");
-		if(node_aux == NULL)
-		{
-			LM_ERR("Scenary document not well formed. No client 'to' node defined\n");
-			goto error2;
-		}
-
-		node_aux = xmlNodeGetChildByName(node_aux, "value");
-		if(node_aux == NULL)
-		{
-			LM_ERR("Bad format for b2b scenario. New entity without a destination\n");
-			goto error2;
-		}
-		value_content = (char*)xmlNodeGetContent(node_aux);
-		if(value_content == NULL)
-		{
-			LM_ERR("Bad formated scenario document. URI value empty\n");
-			goto error2;
-		}
-
-		if(b2b_scenario_parse_uri(node_aux, value_content, tuple, msg,
-					&client_to) < 0 || !client_to.s)
-		{
-			LM_ERR("Failed to get the value for the b2b client ruri\n");
-			xmlFree(value_content);
-			goto error2;
-		}
-		xmlFree(value_content);
-
-		if(xmlStrcasecmp((unsigned char*)type, (unsigned char*)"message") == 0)
-		{
-			memset(&ci, 0, sizeof(client_info_t));
-			ci.method        = method;
-			ci.to_uri        = client_to;
-			ci.from_uri      = from_uri;
-			ci.extra_headers = tuple->extra_headers;
-			ci.body          = (body.s?&body:NULL);
-			ci.send_sock     = msg->force_send_socket?msg->force_send_socket:msg->rcv.bind_address;;
-			get_local_contact( ci.send_sock, &ci.local_contact);
-
-			if (str2int( &(get_cseq(msg)->number), &ci.cseq)!=0 )
-			{
-				LM_ERR("cannot parse cseq number\n");
-				goto error;
-			}
-
-			client_id = b2b_api.client_new(&ci, b2b_client_notify,
-					b2b_add_dlginfo, b2bl_key);
-			if(client_id == NULL)
-			{
-				LM_ERR("failed to create new b2b client instance\n");
-				goto error2;
-			}
-
-			client_entity = b2bl_create_new_entity(B2B_CLIENT, client_id, &client_to,
-					&from_uri,0,&entity_sid, 0);
-			if(client_entity == NULL)
-			{
-				LM_ERR("failed to create new client entity\n");
-				xmlFree(entity_sid.s);
-				pkg_free(client_id);
-				goto error2;
-			}
-			pkg_free(client_id);
-
-			if (0 != b2bl_add_client(tuple, client_entity))
-				goto error2;
-			client_entity->no = eno++;
-			clients_no++;
-		}
-		xmlFree(type);
-		xmlFree(entity_sid.s);
-	}
-
-	/* If I have a server entity I consider it peer for all client entities,
-	 * and its peer is the first client */
-	if(tuple->servers[0])
-	{
-		if(tuple->clients[0] == NULL)
-		{
-			LM_ERR("You have to create at least 2 entities in init part\n");
-			goto error;
-		}
-		for (index = 0; index < MAX_B2BL_ENT; index++)
-		{
-			if (tuple->clients[index])
-				tuple->clients[index]->peer = tuple->servers[0];
-
-		}
-		tuple->bridge_entities[0] = tuple->servers[0];
-		tuple->bridge_entities[1] = tuple->clients[0];
-	}
-	else
-	{
-		if(clients_no >= 2) /* make the first 2 peers */
-		{
-			tuple->bridge_entities[0]= tuple->clients[0];
-			tuple->bridge_entities[1]= tuple->clients[1];
-		}
-		else
-		{
-			LM_ERR("You have to create at least 2 entities in init part\n");
-			goto error;
-		}
-	}
-	tuple->bridge_entities[0]->peer = tuple->bridge_entities[1];
-	tuple->bridge_entities[1]->peer = tuple->bridge_entities[0];
-
-	tuple->cbf = cbf;
-	tuple->cb_mask = cb_mask;
-	tuple->cb_param = cb_param;
-
-	if(b2bl_db_mode == WRITE_THROUGH)
-		b2bl_db_insert(tuple);
-
-	lock_release(&b2bl_htable[hash_index].lock);
-
-	if(new_body.s)
-		pkg_free(new_body.s);
-
-	return b2bl_key;
-
-error2:
-	xmlFree(type);
-error1:
-	xmlFree(entity_sid.s);
-error:
-	if(tuple)
-	{
-		b2bl_delete(tuple, hash_index, 0);
-		lock_release(&b2bl_htable[hash_index].lock);
-	}
-	if(to_uri.s)
-		pkg_free(to_uri.s);
-	if(new_body.s)
-		pkg_free(new_body.s);
-	return NULL;
-}
-
-str* init_request(struct sip_msg* msg, b2b_scenario_t* scenario_struct,
-	str* args[], b2bl_cback_f cbf, void* cb_param, unsigned int cb_mask, str* custom_hdrs)
-{
-	str* key;
-	int_str avp_val;
-
-	/* parse message to extract needed info */
-	if (parse_headers(msg, HDR_EOH_F, 0) < 0)
-	{
-		LM_ERR("failed to parse message\n");
-		return NULL;
-	}
-
-	if(scenario_struct == NULL)
-		key = create_top_hiding_entities(msg, cbf, cb_param, cb_mask, custom_hdrs);
-	else
-		key = b2b_process_scenario_init(scenario_struct, msg, args,
-					cbf, cb_param, cb_mask, custom_hdrs);
-
-	if(key)
-	{
-		if (b2bl_key_avp_name >= 0)
-		{
-			avp_val.s = *key;
-			if(add_avp(AVP_VAL_STR|b2bl_key_avp_type, b2bl_key_avp_name, avp_val)!=0)
-			{
-				LM_ERR("failed to build b2bl_key avp\n");
-			}
-		}
-	}
-
-	return key;
-}
-
-str* internal_init_scenario(struct sip_msg* msg, str* name, str* args[MAX_SCENARIO_PARAMS],
-		b2bl_cback_f cbf, void* cb_param, unsigned int cb_mask, str* custom_hdrs)
-{
-	b2b_scenario_t* scenario_struct;
-
-	if (b2bl_key_avp_name >= 0)
-		destroy_avps( b2bl_key_avp_type, b2bl_key_avp_name, 1);
-
-	if(name->len == B2B_TOP_HIDING_SCENARY_LEN &&
-		strncmp(name->s,B2B_TOP_HIDING_SCENARY,B2B_TOP_HIDING_SCENARY_LEN)==0)
-	{
-		scenario_struct = NULL;
-	}
-	else
-	{
-		scenario_struct = get_scenario_id_list(name, script_scenarios);
-		if(!scenario_struct)
-		{
-			LM_ERR("No scenario found with id [%s]\n", name->s);
-			return NULL;
-		}
-	}
-	b2bl_caller = CALLER_MODULE;
-	return init_request(msg, scenario_struct, args, cbf, cb_param, cb_mask, custom_hdrs);
-}
-
-int b2b_init_request(struct sip_msg* msg, str* arg1, str* arg2, str* arg3,
-		str* arg4, str* arg5, str* arg6)
-{
-	str* args[MAX_SCENARIO_PARAMS];
-	b2b_scenario_t* scenario_struct;
-	str* key;
-
-	if (b2bl_key_avp_name >= 0)
-		destroy_avps( b2bl_key_avp_type, b2bl_key_avp_name, 1);
-
-	/* find the scenario with the corresponding id */
-	scenario_struct = (b2b_scenario_t*)arg1;
-	b2bl_caller = CALLER_SCRIPT;
-
-	/* process the arguments */
-	args[0] = arg2;
-	args[1] = arg3;
-	args[2] = arg4;
-	args[3] = arg5;
-	args[4] = arg6;
-
-	/* call the scenario init processing function */
-	key = init_request(msg, scenario_struct, args, 0, NULL, 0, NULL);
-	if(key)
-		return 1;
-
-	return -1;
-}
-
-
-int b2bl_bridge(str* key, str* new_dst, str* new_from_dname, int entity_no)
-{
-	b2bl_tuple_t* tuple;
-	b2bl_entity_id_t* entity = NULL, *old_entity;
-	struct sip_uri uri;
-	unsigned int hash_index, local_index;
-	str* client_id;
-	client_info_t ci;
-	b2b_req_data_t req_data;
-	b2b_rpl_data_t rpl_data;
-
-	if(!key || !new_dst)
-	{
-		LM_ERR("Wrong arguments\n");
-		return -1;
-	}
-
-	if(entity_no == 1)
-	{
-		LM_WARN("Not implemented yet.\n");
-		return 0;
-	}
-
-	if(parse_uri(new_dst->s, new_dst->len, &uri)< 0)
-	{
-		LM_ERR("Bad argument. Not a valid uri [%.*s]\n", new_dst->len, new_dst->s);
-		return -1;
-	}
-
-	if(b2bl_parse_key(key, &hash_index, &local_index) < 0)
-	{
-		LM_ERR("Failed to parse key\n");
-		return -1;
-	}
-
-	lock_get(&b2bl_htable[hash_index].lock);
-
-	tuple = b2bl_search_tuple_safe(hash_index, local_index);
-	if(tuple == NULL)
-	{
-		LM_ERR("No entity found\n");
-		goto error;
-	}
-
-	// FIXME: we may have no server at some point in time
-	if(tuple->servers[0] == NULL)
-	{
-		LM_ERR("Wrong usage - no server entity present\n");
-		goto error;
-	}
-	LM_DBG("Bridge server %.*s\n",tuple->servers[0]->dlginfo->callid.len,
-			tuple->servers[0]->dlginfo->callid.s);
-	old_entity = tuple->servers[0]->peer;
-	if(old_entity)
-	{
-		if(old_entity->next || old_entity->prev)
-		{
-			LM_ERR("Inconsistent entity [%p]\n", old_entity);
-			b2bl_print_tuple(tuple, L_ERR);
-			goto error;
-		}
-		LM_DBG("End peer dialog [%p]\n", old_entity);	
-		old_entity->peer = NULL;
-		if(old_entity->disconnected && old_entity->state==B2BL_ENT_CONFIRMED)
-		{
-			memset(&rpl_data, 0, sizeof(b2b_rpl_data_t));
-			PREP_RPL_DATA(old_entity);
-			rpl_data.method =METHOD_BYE;
-			rpl_data.code =200;
-			rpl_data.text =&ok;
-			b2b_api.send_reply(&rpl_data);
-			b2bl_delete_entity(old_entity, tuple);
-		}
-		else
-			b2b_end_dialog(old_entity, tuple);
-	}
-	else
-		LM_DBG("No peer found\n");
-
-	if(tuple->scenario_state == B2B_BRIDGING_STATE &&
-			tuple->bridge_entities[0]== tuple->servers[0] &&
-			tuple->servers[0]->state== B2BL_ENT_CONFIRMED)
-	{
-		LM_DBG("Do the second step of the bridging\n");
-		/* do the second step of bridging */
-		memset(&ci, 0, sizeof(client_info_t));
-		ci.method        = method_invite;
-		ci.to_uri        = *new_dst;
-		ci.from_uri      = tuple->servers[0]->to_uri;
-		ci.from_dname    = *new_from_dname;
-		ci.extra_headers = tuple->extra_headers;
-		ci.body          = tuple->b1_sdp.s?&tuple->b1_sdp:0;
-		ci.cseq          = 1;
-		get_local_contact( ci.send_sock, &ci.local_contact);
-
-		client_id = b2b_api.client_new(&ci, b2b_client_notify,
-				b2b_add_dlginfo, tuple->key);
-		if(client_id == NULL)
-		{
-			LM_ERR("Failed to create new client entity\n");
-			goto error;
-		}
-		/* save the client_id in the structure */
-		entity = b2bl_create_new_entity(B2B_CLIENT, client_id, &ci.to_uri,
-				&ci.from_uri, 0, 0, 0);
-		if(entity == NULL)
-		{
-			LM_ERR("failed to create new client entity\n");
-			pkg_free(client_id);
-			goto error;
-		}
-		pkg_free(client_id);
-		LM_DBG("Created new client entity [%.*s]\n", new_dst->len, new_dst->s);
-
-		if (0 != b2bl_add_client(tuple, entity))
-			goto error;
-	}
-	else
-	{
-		entity = b2bl_create_new_entity(B2B_CLIENT,0,new_dst,0,new_from_dname,0,0);
-		if(entity == NULL)
-		{
-			LM_ERR("Failed to create new b2b entity\n");
-			goto error;
-		}
-		LM_DBG("Created new client entity [%.*s]\n", new_dst->len, new_dst->s);
-
-		tuple->scenario_state = B2B_BRIDGING_STATE;
-		memset(&req_data, 0, sizeof(b2b_req_data_t));
-		PREP_REQ_DATA(tuple->servers[0]);
-		req_data.method =&method_invite;
-		if(b2b_api.send_request(&req_data) < 0)
-		{
-			LM_ERR("Failed to send INVITE request\n");
-			goto error;
-		}
-		tuple->servers[0]->state = 0; /* mark it not as CONFIRMED */
-	}
-
-	tuple->bridge_entities[0]= tuple->servers[0];
-	tuple->bridge_entities[1]= entity;
-	tuple->servers[0]->no = 0;
-	entity->no = 1;
-
-	tuple->servers[0]->peer = entity;
-	entity->peer = tuple->servers[0];
-
-	tuple->servers[0]->stats.start_time = get_ticks();
-	tuple->servers[0]->stats.call_time = 0;
-
-
-	lock_release(&b2bl_htable[hash_index].lock);
-
-	return 0;
-
-error:
-	if(entity)
-		shm_free(entity);
-	lock_release(&b2bl_htable[hash_index].lock);
-	return -1;
-}
-
-int b2bl_terminate_call(str* key)
-{
-	unsigned int hash_index, local_index;
-	b2bl_tuple_t* tuple;
-
-	if(b2bl_parse_key(key, &hash_index, &local_index) < 0)
-	{
-		LM_ERR("Failed to parse key\n");
-		return -1;
-	}
-
-	lock_get(&b2bl_htable[hash_index].lock);
-
-	tuple = b2bl_search_tuple_safe(hash_index, local_index);
-	if(tuple == NULL)
-	{
-		LM_DBG("No entity found [%.*s]\n", key->len, key->s);
-		lock_release(&b2bl_htable[hash_index].lock);
-		return -1;
-	}
-
-	b2b_end_dialog(tuple->bridge_entities[0], tuple);
-	b2b_end_dialog(tuple->bridge_entities[1], tuple);
-
-	b2b_mark_todel(tuple);
-
-	lock_release(&b2bl_htable[hash_index].lock);
-
-	return 0;
-}
-
-int b2bl_get_stats(str* key, b2bl_dlg_stat_t* stat)
-{
-	unsigned int hash_index, local_index;
-	b2bl_tuple_t* tuple;
-
-	if(b2bl_parse_key(key, &hash_index, &local_index) < 0)
-	{
-		LM_ERR("Failed to parse key\n");
-		return -1;
-	}
-
-	lock_get(&b2bl_htable[hash_index].lock);
-
-	tuple = b2bl_search_tuple_safe(hash_index, local_index);
-	if(tuple == NULL)
-	{
-		LM_ERR("No entity found\n");
-		lock_release(&b2bl_htable[hash_index].lock);
-		return -1;
-	}
-	
-	if(stat && tuple->bridge_entities[0])
-	{
-		stat->start_time = tuple->bridge_entities[0]->stats.start_time;
-		stat->setup_time = tuple->bridge_entities[0]->stats.setup_time;
-		stat->call_time  = get_ticks() - stat->start_time;
-		stat->key.s = NULL; stat->key.len = 0;
-	}
-
-	lock_release(&b2bl_htable[hash_index].lock);
-
-	return 0;
-}
-
-int b2bl_set_state(str* key, int state)
-{
-	unsigned int hash_index, local_index;
-	b2bl_tuple_t* tuple;
-
-	if(b2bl_parse_key(key, &hash_index, &local_index) < 0)
-	{
-		LM_ERR("Failed to parse key\n");
-		return -1;
-	}
-
-	lock_get(&b2bl_htable[hash_index].lock);
-
-	tuple = b2bl_search_tuple_safe(hash_index, local_index);
-	if(tuple == NULL)
-	{
-		LM_ERR("No entity found\n");
-		lock_release(&b2bl_htable[hash_index].lock);
-		return -1;
-	}
-
-	if(tuple->scenario_state == B2B_BRIDGING_STATE)
-		tuple->next_scenario_state = state;
-	else
-		tuple->scenario_state = state;
-
-	lock_release(&b2bl_htable[hash_index].lock);
-
-	return 0;
-}
-
-int b2bl_bridge_2calls(str* key1, str* key2)
-{
-	b2bl_tuple_t* tuple;
-	unsigned int hash_index, local_index;
-	b2bl_entity_id_t *e2= 0, *e1= 0;
-	b2bl_entity_id_t *e;
-	b2b_req_data_t req_data;
-	b2b_rpl_data_t rpl_data;
-
-	if(!key1 || !key2)
-	{
-		LM_ERR("Wrong arguments [%p] [%p]\n", key1, key2);
-		return -1;
-	}
-
-	if(b2bl_parse_key(key2, &hash_index, &local_index) < 0)
-	{
-		LM_ERR("Failed to parse key [%.*s]\n", key2->len, key2->s);
-		return -1;
-	}
-
-	/* extract the entity and delete the tuple */
-	lock_get(&b2bl_htable[hash_index].lock);
-
-	tuple = b2bl_search_tuple_safe(hash_index, local_index);
-	if(tuple == NULL)
-	{
-		LM_ERR("No entity found\n");
-		goto error;
-	}
-
-	if(tuple->bridge_entities[0] && !tuple->bridge_entities[0]->disconnected)
-	{
-		e2 = tuple->bridge_entities[0];
-		e = tuple->bridge_entities[1];
-	}
-	else
-	if(tuple->bridge_entities[1] && !tuple->bridge_entities[1]->disconnected)
-	{
-		e2 = tuple->bridge_entities[1];
-		e = tuple->bridge_entities[0];
-	}
-	tuple->cbf = 0;
-	if(e2 == NULL)
-	{
-		LM_ERR("entity not found for key 2 [%.*s]\n", key2->len, key2->s);
-		goto error;
-	}
-	if(e2->state != B2BL_ENT_CONFIRMED)
-	{
-		LM_ERR("Wrong state for entity ek= [%.*s], tk=[%.*s]\n",e2->key.len,
-				e2->key.s, key2->len, key2->s);
-		goto error;
-	}
-
-	if(e)
-	{
-		if(e->disconnected && e->state==B2BL_ENT_CONFIRMED)
-		{
-			memset(&rpl_data, 0, sizeof(b2b_rpl_data_t));
-			PREP_RPL_DATA(e);
-			rpl_data.method =METHOD_BYE;
-			rpl_data.code =200;
-			rpl_data.text =&ok;
-			b2b_api.send_reply(&rpl_data);
-		}
-		else
-		{
-			b2b_end_dialog(e, tuple);
-		}
-		e->peer = NULL;
-	}
-
-	// FIXME: this logic may need to be updated
-	if(e2->type == B2B_SERVER)
-	{
-		if(e2 == tuple->servers[0])
-		{
-			tuple->servers[0] = tuple->servers[1];
-			tuple->servers[1] = NULL;
-		}
-		else if(e2 == tuple->servers[1])
-			tuple->servers[1] = NULL;
-		else
-		{
-			LM_ERR("BUG: server entity [%.*s] not found\n", e2->key.len, e2->key.s);
-			goto error;
-		}
-	}
-	else if (e2->type == B2B_CLIENT)
-	{
-		if(e2 == tuple->clients[0])
-		{
-			tuple->clients[0] = tuple->clients[1];
-			tuple->clients[1] = NULL;
-		}
-		else if(e2 == tuple->clients[1])
-			tuple->clients[1] = NULL;
-		else
-		{
-			LM_ERR("BUG: client entity [%.*s] not found\n", e2->key.len, e2->key.s);
-			goto error;
-		}
-	}
-	else
-	{
-		LM_ERR("BUG: unexpected entity type [%d] for [%.*s]\n",
-				e2->type, e2->key.len, e2->key.s);
-		goto error;
-	}
-	b2bl_delete(tuple, hash_index, 0);
-	lock_release(&b2bl_htable[hash_index].lock);
-	/* must restore the b2bl_key for this entity in b2b_entities */
-
-	if(b2bl_parse_key(key1, &hash_index, &local_index) < 0)
-	{
-		LM_ERR("Failed to parse key [%.*s]\n", key1->len, key1->s);
-		return -1;
-	}
-
-	/* extract the entity and delete the tuple */
-	lock_get(&b2bl_htable[hash_index].lock);
-
-	tuple = b2bl_search_tuple_safe(hash_index, local_index);
-	if(tuple == NULL)
-	{
-		LM_ERR("No entity found\n");
-		goto error;
-	}
-	
-	e1 = tuple->bridge_entities[0];
-	if(e1 == NULL || e1->disconnected)
-	{
-		LM_ERR("entity not found for key 1 [%.*s]\n", key1->len, key1->s);
-		goto error;
-	}
-
-	e = tuple->bridge_entities[1];
-	if(e)
-	{
-		if(e->disconnected && e->state==B2BL_ENT_CONFIRMED)
-		{
-			memset(&rpl_data, 0, sizeof(b2b_rpl_data_t));
-			PREP_RPL_DATA(e);
-			rpl_data.method =METHOD_BYE;
-			rpl_data.code =200;
-			rpl_data.text =&ok;
-			b2b_api.send_reply(&rpl_data);
-		}
-		b2b_end_dialog(e, tuple);
-		e->peer = NULL;
-	}
-
-	/* put it in clients list */
-	e2->type = B2B_CLIENT;
-	if (tuple->clients[0])
-		tuple->clients[1] = e2;
-	else
-		tuple->clients[0] = e2;
-	tuple->bridge_entities[1]= e2;
-
-	e1->peer = e2;
-	e2->peer = e1;
-	e1->no = 0;
-	e2->no = 1;
-	
-	if(b2b_api.update_b2bl_param(e2->type, &e2->key, tuple->key) < 0)
-	{
-		LM_ERR("Failed to update b2bl parameter in b2b_entities\n");
-		goto error;
-	}
-	LM_DBG("Updated b2bl param for entity [%.*s]\n", e2->key.len, e2->key.s);
-	e1->stats.start_time = get_ticks();
-	e1->stats.call_time = 0;
-	memset(&req_data, 0, sizeof(b2b_req_data_t));
-	PREP_REQ_DATA(e1);
-	req_data.method =&method_invite;
-	req_data.extra_headers = NULL;
-	if(b2b_api.send_request(&req_data) < 0)
-	{
-		LM_ERR("Failed to send reInvite\n");
-		goto error;
-	}
-	e1->state = 0;
-	tuple->scenario_state = B2B_BRIDGING_STATE;
-	if(max_duration)
-		tuple->lifetime = get_ticks() + max_duration;
-	else
-		tuple->lifetime = 0;
-	lock_release(&b2bl_htable[hash_index].lock);
-
-	return 0;
-
-error:
-	if(tuple)
-		b2b_mark_todel(tuple);
-	lock_release(&b2bl_htable[hash_index].lock);
-	return -1;
-}
-
-
-/* Bridge an initial Invite with an existing dialog */
-/* key and entity_no identity the existing call and the which entity from the call
- * to bridge (0 or 1) */
-int b2bl_bridge_msg(struct sip_msg* msg, str* key, int entity_no)
-{
-	b2bl_tuple_t* tuple;
-	unsigned int hash_index, local_index;
-	b2bl_entity_id_t *bridging_entity= NULL;
-	b2bl_entity_id_t *old_entity;
-	b2bl_entity_id_t *entity;
-	str* server_id;
-	str body, new_body = {0, 0};
-	str to_uri={NULL,0}, from_uri, from_dname;
-	b2b_req_data_t req_data;
-	b2b_rpl_data_t rpl_data;
-
-	if(!msg || !key)
-	{
-		LM_ERR("Wrong arguments [%p] [%p]\n", msg, key);
-		return -1;
-	}
-
-	if(b2bl_parse_key(key, &hash_index, &local_index) < 0)
-	{
-		LM_ERR("Failed to parse key [%.*s]\n", key->len, key->s);
-		return -1;
-	}
-
-	/* extract the entity and delete the tuple */
-	lock_get(&b2bl_htable[hash_index].lock);
-
-	tuple = b2bl_search_tuple_safe(hash_index, local_index);
-	if(tuple == NULL)
-	{
-		LM_ERR("No entity found\n");
-		goto error;
-	}
-	if(entity_no!=0 && entity_no!=1)
-	{
-		LM_ERR("entity_no param can take only 0 or 1 value, got [%d]\n", entity_no);
-		goto error;
-	}
-
-	if(!tuple->bridge_entities[entity_no] || tuple->bridge_entities[entity_no]->disconnected)
-	{
-		LM_ERR("Can not bridge requested entity [%p]\n", tuple->bridge_entities[entity_no]);
-		goto error;
-	}
-	bridging_entity = tuple->bridge_entities[entity_no];
-	old_entity = tuple->bridge_entities[(entity_no?0:1)];
-
-	if(old_entity->next || old_entity->prev)
-	{
-		LM_ERR("Can not disconnect multiple entities\n");
-		goto error;
-	}
-
-	if(bridging_entity->state != B2BL_ENT_CONFIRMED)
-	{
-		LM_ERR("Wrong state for entity ek= [%.*s], tk=[%.*s]\n",bridging_entity->key.len,
-				bridging_entity->key.s, key->len, key->s);
-		goto error;
-	}
-
-	b2bl_print_tuple(tuple, L_DBG);
-
-	if(old_entity)
-	{
-		LM_DBG("terminating b2bl_entity [%p]->[%.*s] type [%d]\n",
-					old_entity, old_entity->key.len, old_entity->key.s,
-					old_entity->type);
-		if(old_entity->disconnected)
-		{
-			memset(&rpl_data, 0, sizeof(b2b_rpl_data_t));
-			PREP_RPL_DATA(old_entity);
-			rpl_data.method =METHOD_BYE;
-			rpl_data.code =200;
-			rpl_data.text =&ok;
-			b2b_api.send_reply(&rpl_data);
-		}
-		else
-		{
-			memset(&req_data, 0, sizeof(b2b_req_data_t));
-			PREP_REQ_DATA(old_entity);
-			req_data.method =&method_bye;
-			req_data.no_cb = 1;
-			b2b_api.send_request(&req_data);
-			old_entity->disconnected = 1;
-		}
-		if (old_entity->peer->peer == old_entity)
-			old_entity->peer->peer = NULL;
-		else
-		{
-			LM_ERR("Unexpected chain: old_entity=[%p] and "
-				"old_entity->peer->peer=[%p]\n",
-				old_entity, old_entity->peer->peer);
-			goto error;
-		}
-		old_entity->peer = NULL;
-
-		/* remove the disconected entity from the tuple */
-		if(0 == b2bl_drop_entity(old_entity, tuple))
-		{
-			LM_ERR("Inconsistent entity [%p] on tuple [%p]\n", old_entity, tuple);
-			b2bl_print_tuple(tuple, L_ERR);
-			goto error;
-		}
-
-		/* destroy the old_entity */
-		b2b_api.entity_delete(old_entity->type, &old_entity->key, old_entity->dlginfo, 1);
-		if(old_entity->dlginfo)
-			shm_free(old_entity->dlginfo);
-		shm_free(old_entity);
-		old_entity = NULL;
-
-		b2bl_print_tuple(tuple, L_DBG);
-	}
-
-	/* create server entity from Invite */
-	if(b2b_msg_get_from(msg, &from_uri, &from_dname)< 0 || b2b_msg_get_to(msg, &to_uri)< 0)
-	{
-		LM_ERR("Failed to get to or from from the message\n");
-		goto error;
-	}
-	server_id = b2b_api.server_new(msg, &tuple->local_contact,
-			b2b_server_notify, tuple->key);
-	if(server_id == NULL)
-	{
-		LM_ERR("failed to create new b2b server instance\n");
-		pkg_free(to_uri.s);
-		goto error;
-	}
-
-	entity = b2bl_create_new_entity(B2B_SERVER, server_id, &to_uri, &from_uri,
-			0,0, msg);
-	if(entity == NULL)
-	{
-		LM_ERR("Failed to create server entity\n");
-		pkg_free(to_uri.s);
-		goto error;
-	}
-	pkg_free(to_uri.s);
-
-	if (0 != b2bl_add_server(tuple, entity))
-		goto error;
-
-	entity->peer = bridging_entity;
-	bridging_entity->peer = entity;
-
-	entity->stats.start_time = get_ticks();
-	entity->stats.call_time = 0;
-
-	bridging_entity->no = 0;
-	entity->no = 1;
-
-	/* send reInvite to the old entity*/
-	if(msg->content_length)
-	{
-		/* apply body lumps if there are any */
-		if(msg->body_lumps)
-		{
-			if(b2b_apply_body_lumps(msg, &new_body) < 0)
-			{
-				LM_ERR("failed to apply lumps\n");
-			}
-			body = new_body;
-		}
-		else
-		{
-			body.len = get_content_length(msg);
-			if(body.len != 0 )
-			{
-				body.s=get_body(msg);
-				if (body.s== NULL) 
-				{
-					LM_ERR("cannot extract body\n");
-					goto error;
-				}
-			}
-		}
-	}
-
-	memset(&req_data, 0, sizeof(b2b_req_data_t));
-	PREP_REQ_DATA(bridging_entity);
-	req_data.method =&method_invite;
-	req_data.body = &body;
-	if(b2b_api.send_request(&req_data) < 0)
-	{
-		LM_ERR("Failed to send reInvite\n");
-		goto error;
-	}
-	bridging_entity->state = 0;
-	if(max_duration)
-		tuple->lifetime = get_ticks() + max_duration;
-	else
-		tuple->lifetime = 0;
-
-	tuple->bridge_entities[0] = bridging_entity;
-	tuple->bridge_entities[1] = entity;
-
-	b2bl_print_tuple(tuple, L_DBG);
-
-	lock_release(&b2bl_htable[hash_index].lock);
-	if(new_body.s)
-		pkg_free(new_body.s);
-	return 0;
-
-error:
-	if(tuple)
-		b2b_mark_todel(tuple);
-	lock_release(&b2bl_htable[hash_index].lock);
-	if(new_body.s)
-		pkg_free(new_body.s);
-	return -1;
-}
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/text-base/Makefile.svn-base ./b2b_logic/.svn/text-base/Makefile.svn-base
--- ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/text-base/Makefile.svn-base	2012-10-31 10:33:42.881197359 +0000
+++ ./b2b_logic/.svn/text-base/Makefile.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,14 +0,0 @@
-# $Id: Makefile 806 2006-04-14 11:00:10Z bogdan_iancu $
-#
-# WARNING: do not run this directly, it should be run by the master Makefile
-
-include ../../Makefile.defs
-auto_gen=
-NAME=b2b_logic.so
-LIBS= 
-
-DEFS+=-I$(SYSBASE)/include/libxml2 -I$(LOCALBASE)/include/libxml2 \
-      -I$(LOCALBASE)/include
-LIBS=-L$(SYSBASE)/include/lib  -L$(LOCALBASE)/lib -lxml2
-
-include ../../Makefile.modules
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/text-base/pidf.c.svn-base ./b2b_logic/.svn/text-base/pidf.c.svn-base
--- ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/text-base/pidf.c.svn-base	2012-10-31 10:33:42.869204703 +0000
+++ ./b2b_logic/.svn/text-base/pidf.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,98 +0,0 @@
-/*
- * $Id$
- *
- * back-to-back logic module
- *
- * Copyright (C) 2009 Free Software Fundation
- *
- * This file is part of opensips, a free SIP server.
- *
- * opensips is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version
- *
- * opensips is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License 
- * along with this program; if not, write to the Free Software 
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * History:
- * --------
- *  2009-08-03  initial version (Anca Vamanu)
- */
-
-
-#include <libxml/parser.h>
-#include "pidf.h"
-
-xmlAttrPtr xmlNodeGetAttrByName(xmlNodePtr node, const char *name)
-{
-	xmlAttrPtr attr = node->properties;
-	while (attr) {
-		if (xmlStrcasecmp(attr->name, (unsigned char*)name) == 0)
-			return attr;
-		attr = attr->next;
-	}
-	return NULL;
-}
-
-unsigned char *xmlNodeGetAttrContentByName(xmlNodePtr node, const char *name)
-{
-	xmlAttrPtr attr = xmlNodeGetAttrByName(node, name);
-	if (attr)
-		return xmlNodeGetContent(attr->children);
-	else
-		return NULL;
-}
-
-xmlNodePtr xmlNodeGetChildByName(xmlNodePtr node, const char *name)
-{
-	xmlNodePtr cur = node->children;
-	while (cur) {
-		if (xmlStrcasecmp(cur->name, (unsigned char*)name) == 0)
-			return cur;
-		cur = cur->next;
-	}
-	return NULL;
-}
-
-xmlNodePtr xmlNodeGetNodeByName(xmlNodePtr node, const char *name,
-															const char *ns)
-{
-	xmlNodePtr cur = node;
-	while (cur) {
-		xmlNodePtr match = NULL;
-		if (xmlStrcasecmp(cur->name, (unsigned char*)name) == 0) {
-			if (!ns || (cur->ns && xmlStrcasecmp(cur->ns->prefix,
-							(unsigned char*)ns) == 0))
-				return cur;
-		}
-		match = xmlNodeGetNodeByName(cur->children, name, ns);
-		if (match)
-			return match;
-		cur = cur->next;
-	}
-	return NULL;
-}
-
-xmlNodePtr xmlDocGetNodeByName(xmlDocPtr doc, const char *name, const char *ns)
-{
-	xmlNodePtr cur = doc->children;
-	return xmlNodeGetNodeByName(cur, name, ns);
-}
-
-char *xmlNodeGetNodeContentByName(xmlNodePtr root, const char *name,
-		const char *ns)
-{
-	xmlNodePtr node = xmlNodeGetNodeByName(root, name, ns);
-	if (node)
-		return (char*)xmlNodeGetContent(node->children);
-	else
-		return NULL;
-}
-
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/text-base/pidf.h.svn-base ./b2b_logic/.svn/text-base/pidf.h.svn-base
--- ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/text-base/pidf.h.svn-base	2012-10-31 10:33:42.877197307 +0000
+++ ./b2b_logic/.svn/text-base/pidf.h.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,41 +0,0 @@
-/*
- * $Id$
- *
- * back-to-back logic module
- *
- * Copyright (C) 2009 Free Software Fundation
- *
- * This file is part of opensips, a free SIP server.
- *
- * opensips is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version
- *
- * opensips is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License 
- * along with this program; if not, write to the Free Software 
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * History:
- * --------
- *  2009-08-03  initial version (Anca Vamanu)
- */
-
-#ifndef _B2BL_PIDF_H_
-#define _B2BL_PIDF_H_
-
-unsigned char *xmlNodeGetAttrContentByName(xmlNodePtr node, const char *name);
-
-xmlNodePtr xmlNodeGetChildByName(xmlNodePtr node, const char *name);
-
-xmlNodePtr xmlDocGetNodeByName(xmlDocPtr doc, const char *name, const char *ns);
-
-char *xmlNodeGetNodeContentByName(xmlNodePtr root, const char *name,
-		const char *ns);
-
-#endif
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/text-base/README.svn-base ./b2b_logic/.svn/text-base/README.svn-base
--- ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/text-base/README.svn-base	2012-10-31 10:33:42.885197307 +0000
+++ ./b2b_logic/.svn/text-base/README.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,628 +0,0 @@
-B2B_LOGIC
-
-Anca-Maria Vamanu
-
-   OpenSIPS
-
-Edited by
-
-Anca-Maria Vamanu
-
-Edited by
-
-Ovidiu Sas
-
-   Copyright  2009 Anca-Maria
-   Vamanu
-
-   Copyright  2010 VoIP Embedded, Inc.
-   Revision History
-   Revision $Revision: 8137 $ $Date: 2011-07-07 15:02:20 +0300
-                              (Thu, 07 Jul 2011) $
-     __________________________________________________________
-
-   Table of Contents
-
-   1. Admin Guide
-
-        1.1. Overview
-        1.2. Dependencies
-
-              1.2.1. OpenSIPS Modules
-              1.2.2. External Libraries or Applications
-
-        1.3. Exported Parameters
-
-              1.3.1. hash_size (int)
-              1.3.2. script_scenario (str)
-              1.3.3. extern_scenario (str)
-              1.3.4. cleanup_period (int)
-              1.3.5. custom_headers (str)
-              1.3.6. use_init_sdp (int)
-              1.3.7. db_url (str)
-              1.3.8. update_period (int)
-              1.3.9. max_duration (int)
-              1.3.10. b2bl_key_avp (string)
-              1.3.11. b2bl_from_spec_param (string)
-              1.3.12. server_address (str)
-              1.3.13. init_callid_hdr (str)
-              1.3.14. db_mode (int)
-
-        1.4. Exported Functions
-
-              1.4.1. b2b_init_request
-              1.4.2. b2b_bridge_request(b2bl_key,entity_no)
-
-        1.5. Exported MI Functions
-
-              1.5.1. b2b_trigger_scenario
-              1.5.2. b2b_bridge
-              1.5.3. b2b_list
-
-   2. Developer Guide
-
-        2.1. b2b_logic_bind(b2bl_api_t* api)
-        2.2. init
-        2.3. bridge
-        2.4. bridge_extern
-        2.5. bridge_2calls
-        2.6. terminate_call
-        2.7. set_state
-        2.8. bridge_msg
-
-   List of Examples
-
-   1.1. Set server_hsize parameter
-   1.2. Set script_scenario parameter
-   1.3. Set script_scenario parameter
-   1.4. Set cleanup_period parameter
-   1.5. Set parameter
-   1.6. Set parameter
-   1.7. Set db_url parameter
-   1.8. Set update_period parameter
-   1.9. Set max_duration parameter
-   1.10. Set b2bl_key_avp parameter
-   1.11. Set b2bl_from_spec_param parameter
-   1.12. Set server_address parameter
-   1.13. Set init_callid_hdr parameter
-   1.14. Set db_mode parameter
-   1.15. b2b_init_request usage
-   1.16. b2b_bridge_request usage
-   2.1. b2bl_api_t structure
-
-Chapter 1. Admin Guide
-
-1.1. Overview
-
-   The B2BUA implementation in OpenSIPS is separated in two
-   layers:
-     * a lower one(coded in b2b_entities module)- which implements
-       the basic functions of a UAS and UAC
-     * an upper one - which represents the logic engine of B2BUA,
-       responsible of actually implementing the B2BUA services
-       using the functions offered by the low level.
-
-   This module is a B2BUA upper level implementation that can be
-   used with b2b_entities module to have B2BUA that can be
-   configured to provide some PBX services. The B2B services are
-   coded in an XML scenario document. The b2b_logic module
-   examines this document and uses the functions provided by the
-   b2b_entities module to achieve the actions specified in the
-   document and enable the service.
-
-   A scenario can be instantiated in two ways:
-     * from the script - at the receipt of a initial message
-     * with a extern command (MI) command - the server will
-       connect two end points in a session(Third Party Call
-       Control).
-
-1.2. Dependencies
-
-1.2.1. OpenSIPS Modules
-
-     * b2b_entities, a db module
-
-1.2.2. External Libraries or Applications
-
-   The following libraries or applications must be installed
-   before running OpenSIPS with this module loaded:
-     * libxml2-dev
-
-1.3. Exported Parameters
-
-1.3.1. hash_size (int)
-
-   The size of the hash table that stores the scenario
-   instatiation entities.
-
-   Default value is 9 (512 records).
-
-   Example 1.1. Set server_hsize parameter
-...
-modparam("b2b_logic", "hash_size", 10)
-...
-
-1.3.2. script_scenario (str)
-
-   This parameter should be set with the path of a document that
-   contains a scenario that can be instantiated from the script at
-   the receipt of an initial message.
-
-   This parameter can be set more than once.
-
-   Example 1.2. Set script_scenario parameter
-...
-modparam("b2b_logic", "script_scenario", "/usr/local/opensips/scripts/b2
-b_prepaid.xml")
-...
-
-1.3.3. extern_scenario (str)
-
-   This parameter should be set with the path of a document that
-   contains a scenario that can be instantiated with an MI
-   command.
-
-   This parameter can be set more than once.
-
-   Example 1.3. Set script_scenario parameter
-...
-modparam("b2b_logic", "extern_scenario", "/usr/local/opensips/scripts/b2
-b_marketing.xml")
-...
-
-1.3.4. cleanup_period (int)
-
-   The time interval at which to search for an hanged b2b context.
-   A scenario is considered expired if the duration of a session
-   exceeds the lifetime specified in the scenario. At that moment,
-   BYE is sent in all the dialogs from that context and the
-   context is deleted.
-
-   Default value is 100.
-
-   Example 1.4. Set cleanup_period parameter
-...
-modparam("b2b_logic", "cleanup_period", 60)
-...
-
-1.3.5. custom_headers (str)
-
-   A list of SIP header names delimited by ';' that should be
-   passed from the dialog of one side to the other side. There are
-   a number of headers that are passed by default. They are:
-     * Max-Forwards (it is decreased by 1)
-     * Content-Type
-     * Supported
-     * Allow
-     * Proxy-Require
-     * Session-Expires
-     * Min-SE
-     * Require
-     * RSeq
-
-   If you wish some other headers to be passed also you should
-   define them by setting this parameter.
-
-   Default value is NULL.
-
-   Example 1.5. Set parameter
-...
-modparam("b2b_logic", "custom_headers", "User-Agent;Date")
-...
-
-1.3.6. use_init_sdp (int)
-
-   This parameter modifies the behaviour of the B2BUA when
-   bridging and a provisional media uri is set. For playing media
-   while the callee answers (that is connecting the caller to a
-   media server), the bridging with the callee must start by
-   sending an Invite to it. The correct way is to send an Invite
-   without a body in this case, but it has been observed that not
-   many gateways support this. So, the solution is to use the sdp
-   received in the first Invite from the caller and put it as the
-   body for this invite. By setting this parameter, this behavior
-   is enabled. You can also set use_init_sdp per scenario and
-   overwrite this global value.
-
-   Default value is 0.
-
-   Example 1.6. Set parameter
-...
-modparam("b2b_logic", "use_init_sdp", 1)
-...
-
-1.3.7. db_url (str)
-
-   Database URL.
-
-   Example 1.7. Set db_url parameter
-...
-modparam("b2b_logic", "db_url", "mysql://opensips:opensipsrw@127.0.0.1/o
-pensips")
-...
-
-1.3.8. update_period (int)
-
-   The time interval at which to update the info in database.
-
-   Default value is 100.
-
-   Example 1.8. Set update_period parameter
-...
-modparam("b2b_logic", "update_period", 60)
-...
-
-1.3.9. max_duration (int)
-
-   The maximum duration of a call.
-
-   Default value is 12 * 3600 (12 hours).
-
-   If you set it to 0, there will be no limitation.
-
-   Example 1.9. Set max_duration parameter
-...
-modparam("b2b_logic", "max_duration", 7200)
-...
-
-1.3.10. b2bl_key_avp (string)
-
-   The name of the Attribute-Value-Pair (AVP) used to store the
-   b2b_logic entity key. The avp will be set after calling
-   b2b_init_request. The avp will be visible in b2b_entities
-   request/reply routes
-
-Note
-
-   The avp is not visible in local_route.
-
-   Default value is NULL (disabled).
-
-   Example 1.10. Set b2bl_key_avp parameter
-...
-modparam("b2b_logic", "b2bl_key_avp", "$avp(99)")
-...
-
-1.3.11. b2bl_from_spec_param (string)
-
-   The name of the pseudo variable for storing the new From
-   header. The PV must be set before calling b2b_init_request.
-
-   Default value is NULL (disabled).
-
-   Example 1.11. Set b2bl_from_spec_param parameter
-...
-modparam("b2b_logic", "b2bl_from_spec_param", "$var(b2bl_from)")
-...
-route{
-        ...
-        # setting the From header
-        $var(b2bl_from) = "\"Call ID\" <sip:user@opensips.org>";
-        ...
-        b2b_init_request("top hiding");
-        ...
-}
-
-1.3.12. server_address (str)
-
-   The IP address of the machine that will be used as Contact in
-   the generated messages. This is compulsory only when using
-   external scenarios. For the script scenarios, if it is not set,
-   it is constructed dynamically from the socket where the
-   initiating request was received. This socket will be used to
-   send all the requests, replies for that scenario instantiation.
-
-   Example 1.12. Set server_address parameter
-...
-modparam("b2b_logic", "server_address", "sip:sa@10.10.10.10:5060")
-...
-
-1.3.13. init_callid_hdr (str)
-
-   The module offers the possibility to insert the original callid
-   in a header in the generated Invites. If you want this, set
-   this parameter to the name of the header in which to insert the
-   original callid.
-
-   Example 1.13. Set init_callid_hdr parameter
-...
-modparam("b2b_logic", "init_callid_hdr", "Init-CallID")
-...
-
-1.3.14. db_mode (int)
-
-   The B2B modules have support for the 3 type of database storage
-
-     * NO DB STORAGE - set this parameter to 0
-     * WRITE THROUGH (synchronous write in database) - set this
-       parameter to 1
-     * WRITE BACK (update in db from time to time) - set this
-       parameter to 2
-
-   Default value is 2 (WRITE BACK).
-
-   Example 1.14. Set db_mode parameter
-...
-modparam("b2b_logic", "db_mode", 1)
-...
-
-1.4. Exported Functions
-
-1.4.1.  b2b_init_request
-
-   This is the function that must be called by the script writer
-   on an initial INVITE for which a B2B scenario must be
-   instantiated. It is up to the script writer to decide which are
-   the criteria to decide for which messages certain scenarios
-   must be instantiated.
-
-   The first parameter is the identifier for the scenario. This is
-   defined in the XML document as an attribute of the root node.
-
-   Then it can take at most 4 other parameters that represent the
-   parameters for the xml scenario. The expected number of
-   parameters is also specified as an attribute in the root node
-   of the XML scenario.
-
-Note
-
-   Do not call t_newtran() from the script on this request. It
-   will be called internally by the function. Calling t_newtran()
-   from the script will result in the transaction remaining in
-   memory for ever.
-
-   Example 1.15. b2b_init_request usage
-...
-if(is_method("INVITE") && !has_totag() && prepaid_user())
-   b2b_init_request("prepaid", "sip:320@opensips.org:5070",
-      "sip:321@opensips.org:5070"));
-...
-
-1.4.2.  b2b_bridge_request(b2bl_key,entity_no)
-
-   This function will bridge an initial INVITE with one of the
-   particapnts from an existing b2b dialog.
-
-   Parameters:
-     * b2bl_key - a pseudo-variable that contains the b2b_logic
-       key
-     * entity_no - a pseudo-variable that holds the entity of the
-       particapnt to bridge.
-
-   Example 1.16. b2b_bridge_request usage
-...
-modparam("b2b_logic", "b2bl_key_avp", "$avp(99)")
-...
-route(X)
-{
-   # handling b2b calls here
-   ...
-   b2b_init_request("top hiding");
-   xlog("L_INFO","[$mi] got b2bl_key='$avp(99)'\n");
-   # saving the b2b key into the local cache
-   cache_store("local","some_b2bl_key_identifier","$avp(99)");
-   ...
-}
-
-route(Y)
-{
-   # handling calls to bridge to existing b2b calls
-   ...
-   # retrieving the key of a b2b call
-   cache_fetch("local","some_b2bl_key_identifier", $avp(98) );
-   $var(entity) = 1;
-   b2b_bridge_request("$avp(98)","$var(entity)");
-   ...
-}
-...
-
-1.5. Exported MI Functions
-
-1.5.1.  b2b_trigger_scenario
-
-   This command instantiated a B2B scenario.
-
-   Name: b2b_trigger_scenario
-
-   Parameters:
-     * senario_id : the id of the scenario to be instantiated.
-     * scenario parameters - it can take 4 more parameters that
-       are scenario parameters
-
-   MI FIFO Command Format:
-        :b2b_trigger_scenario:fifo_reply
-        marketing
-        sip:bob@opensips.org
-        sip:322@opensips.org:5070
-        sip:alice@opensips.org
-        _empty_line_
-
-1.5.2.  b2b_bridge
-
-   This command can be used by an external application to tell
-   B2BUA to bridge a call party from an on going dialog to another
-   destination. By default the caller is bridged to the new uri
-   and BYE is set to the callee. You can instead bridge the callee
-   if you send 1 as the third parameter.
-
-   Name: b2b_bridge
-
-   Parameters:
-     * dialog-id : the id of the dialog. If you set the module
-       parameter dialog-id the server will include the dialogid in
-       the generated Invites as the content of a header with name
-       'Dialog-ID'.
-     * new uri - the uri of the new destination
-     * flag to specify that the callee must be bridged to the new
-       destination. It is optional. If not present the caller will
-       be bridged.
-
-   MI FIFO Command Format:
-        :b2b_bridge:fifo_reply
-        1020.30
-        sip:alice@opensips.org
-        _empty_line_
-
-   opensipsctl Command Format:
-        opensipsctl b2b_bridge 1020.30 sip:alice@opensips.org
-
-1.5.3.  b2b_list
-
-   This command can be used to list the internals of b2b_logic
-   entities.
-
-   Name: b2b_list
-
-   Parameters: none
-
-   MI FIFO Command Format:
-        :b2b_list:_reply_fifo_file_
-        _empty_line_
-
-   opensipsctl Command Format:
-        opensipsctl fifo b2b_list
-
-Chapter 2. Developer Guide
-
-   The module provides an API that can be used from other OpenSIPS
-   modules. The API offers the functions for instantiating b2b
-   scenarios from other modules (this comes as an addition to the
-   other two means of instantiating b2b scenarios - from script
-   and with an MI command). Also the instantiations can be
-   dynamically controlled, by commanding the bridging of an entity
-   involved in a call to another entity or the termination of the
-   call or even bridging two existing calls.
-
-2.1.  b2b_logic_bind(b2bl_api_t* api)
-
-   This function binds the b2b_entities modules and fills the
-   structure the exported functions that will be described in
-   detail.
-
-   Example 2.1. b2bl_api_t structure
-...
-typedef struct b2bl_api
-{
-        b2bl_init_f init;
-        b2bl_bridge_f bridge;
-        b2bl_bridge_extern_f bridge_extern;
-        b2bl_bridge_2calls_t bridge_2calls;
-        b2bl_terminate_call_t terminate_call;
-        b2bl_set_state_f set_state;
-        b2bl_bridge_msg_t bridge_msg;
-}b2bl_api_t;
-...
-
-2.2.  init
-
-   Field type:
-...
-typedef str* (*b2bl_init_f)(struct sip_msg* msg, str* name, str* args[5]
-,
-                b2bl_cback_f, void* param);
-...
-
-   Initializing a b2b scenario. The last two parameters are the
-   callback function and the parameter to be called in 3
-   situations that will be listed below. The callback function has
-   the following definition:
-...
-typedef int (*b2b_notify_t)(struct sip_msg* msg, str* id, int type, void
-* param);
-...
-
-   The first argument is the callback given in the init function.
-
-   The second argument is a structure with some statistics about
-   the call -start time, setup time, call time.
-
-   The third argument is the current state of the scenario
-   instantiation.
-
-   The last argument is the event that triggered the callback.
-   There are 3 events when the callback is called:
-     * when a BYE is received from either side- event parameter
-       will also show from which side the BYE is received, so it
-       can be B2B_BYE_E1 or B2B_BYE_E2
-     * If while bridging, a negative reply is received from the
-       second entity - the event is B2B_REJECT_E2.
-     * When the b2b logic entity is deleted- the evnet is
-       B2B_DESTROY
-
-   The return code controls what will happen with the
-   request/reply that caused the event (except for the last event,
-   when the return code does not matter)
-     * -1 - error
-     * 0 - drop the BYE or reply
-     * 1 - send the BYE or reply on the other side
-     * 2 - do what the scenario tells, if no rule defined send the
-       BYE or reply on the other side
-
-2.3.  bridge
-
-   Field type:
-...
-typedef int (*b2bl_bridge_f)(str* key, str* new_uri, str* new_from_dname
-,int entity_type);
-...
-
-   This function allows bridging an entity that is in a call
-   handled by b2b_logic to another entity.
-
-2.4.  bridge_extern
-
-   Field type:
-...
-typedef str* (*b2bl_bridge_extern_f)(str* scenario_name, str* args[5],
-                b2bl_cback_f cbf, void* cb_param);
-...
-
-   This function allows initiating an extern scenario, when the
-   B2BUA starts a call from the middle.
-
-2.5.  bridge_2calls
-
-   Field type:
-...
-typedef int (*b2bl_bridge_2calls_t)(str* key1, str* key2);
-...
-
-   With this function it is possible to bridge two existing calls.
-   The first entity from the two calls will be connected and BYE
-   will be sent to their peers.
-
-2.6.  terminate_call
-
-   Field type:
-...
-typedef int (*b2bl_terminate_call_t)(str* key);
-...
-
-   Terminate a call.
-
-2.7.  set_state
-
-   Field type:
-...
-typedef int (*b2bl_set_state_f)(str* key, int state);
-...
-
-   Set the scenario state.
-
-2.8.  bridge_msg
-
-   Field type:
-...
-typedef int (*b2bl_bridge_msg_t)(struct sip_msg* msg, str* key, int enti
-ty_no);
-...
-
-   This function allows bridging an incoming call to an entity
-   from an existing call.
-
-   The first argument is the INVITE message of the current
-   incoming call.
-
-   The second argument is the b2bl_key of an existing call.
-
-   The third argument is the entity identifier.
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/text-base/records.c.svn-base ./b2b_logic/.svn/text-base/records.c.svn-base
--- ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/text-base/records.c.svn-base	2012-10-31 10:33:42.861197222 +0000
+++ ./b2b_logic/.svn/text-base/records.c.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,813 +0,0 @@
-/*
- * $Id$
- *
- * back-to-back logic module
- *
- * Copyright (C) 2009 Free Software Fundation
- *
- * This file is part of opensips, a free SIP server.
- *
- * opensips is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version
- *
- * opensips is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License 
- * along with this program; if not, write to the Free Software 
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * History:
- * --------
- *  2009-08-03  initial version (Anca Vamanu)
- */
-
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
-
-#include "../../mem/shm_mem.h"
-#include "../../ut.h"
-#include "../presence/hash.h"
-#include "../presence/utils_func.h"
-#include "records.h"
-
-static void _print_entity(int index, b2bl_entity_id_t* e, int log_level)
-{
-	b2bl_entity_id_t* c = e;
-
-	while (c)
-	{
-		LM_GEN1(log_level, ".type=[%d] index=[%d] [%p]->[%.*s] state=%d no=%d"
-			" dlginfo=[%p] peer=[%p] prev:next=[%p][%p]\n",
-			c->type, index, c, c->key.len, c->key.s, c->state, c->no,
-			c->dlginfo, c->peer, c->prev, c->next);
-		if (c->dlginfo)
-			LM_GEN1(log_level, "..........dlginfo=[%p]->[%.*s][%.*s][%.*s]\n",
-				c->dlginfo, c->dlginfo->callid.len, c->dlginfo->callid.s,
-				c->dlginfo->fromtag.len, c->dlginfo->fromtag.s,
-				c->dlginfo->totag.len, c->dlginfo->totag.s);
-		c = c->next;
-	}
-}
-
-void b2bl_print_tuple(b2bl_tuple_t* tuple, int log_level)
-{
-	int index;
-	b2bl_entity_id_t* e;
-
-	if(tuple)
-	{
-		LM_GEN1(log_level, "[%p]->[%.*s] to_del=[%d] lifetime=[%d]"
-			" bridge_entities[%p][%p][%p]\n",
-			tuple, tuple->key->len, tuple->key->s,
-			tuple->to_del, tuple->lifetime,
-			tuple->bridge_entities[0], tuple->bridge_entities[1],
-			tuple->bridge_entities[2]);
-		for (index = 0; index < MAX_B2BL_ENT; index++)
-		{
-			e = tuple->servers[index];
-			if (e) _print_entity(index, e, log_level);
-		}
-		for (index = 0; index < MAX_B2BL_ENT; index++)
-		{
-			e = tuple->clients[index];
-			if (e) _print_entity(index, e, log_level);
-		}
-		for (index = 0; index < MAX_BRIDGE_ENT; index++)
-		{
-			e = tuple->bridge_entities[index];
-			if (e)
-				LM_GEN1(log_level, ".type=[%d] index=[%d] [%p]"
-					" peer=[%p] prev:next=[%p][%p]\n",
-					e->type, index, e, e->peer, e->prev, e->next);
-		}
-	}
-}
-
-/* Function that inserts a new b2b_logic record - the lock remains taken */
-b2bl_tuple_t* b2bl_insert_new(struct sip_msg* msg,
-		unsigned int hash_index, b2b_scenario_t* scenario,
-		str* args[], str* body, str* custom_hdrs, int local_index,
-		str** b2bl_key_s, int db_flag)
-{
-	b2bl_tuple_t *it, *prev_it;
-	b2bl_tuple_t* tuple;
-	str* b2bl_key;
-	int i;
-	static char buf[256];
-	int buf_len= 255;
-	int size;
-	str extra_headers={0, 0};
-	str local_contact= server_address;
-
-	if(msg)
-	{
-		if(get_local_contact(msg->rcv.bind_address, &local_contact)< 0)
-		{
-			LM_ERR("Failed to get received address\n");
-			local_contact= server_address;
-		}
-	}
-
-	size = sizeof(b2bl_tuple_t) + local_contact.len;
-	if(body && (use_init_sdp || (scenario && scenario->use_init_sdp)))
-	{
-		size+= body->len;
-	}
-
-	tuple = (b2bl_tuple_t*)shm_malloc(size);
-	if(tuple == NULL)
-	{
-		LM_ERR("No more shared memory\n");
-		goto error;
-	}
-	memset(tuple, 0, size);
-
-	size = sizeof(b2bl_tuple_t);
-	if(body && (use_init_sdp || (scenario && scenario->use_init_sdp)))
-	{
-		tuple->sdp.s = (char*)tuple + sizeof(b2bl_tuple_t);
-		memcpy(tuple->sdp.s, body->s, body->len);
-		tuple->sdp.len =  body->len;
-		size += body->len;
-	}
-
-	tuple->local_contact.s = (char*)tuple + size;
-	memcpy(tuple->local_contact.s, local_contact.s, local_contact.len);
-	tuple->local_contact.len = local_contact.len;
-
-	tuple->scenario = scenario;
-
-	if(msg)
-	{
-		if(b2b_extra_headers(msg, NULL, custom_hdrs, &extra_headers)< 0)
-		{
-			LM_ERR("Failed to create extra headers\n");
-			goto error;
-		}
-		if(extra_headers.s)
-		{
-			tuple->extra_headers = (str*)shm_malloc(sizeof(str) + extra_headers.len);
-			if(tuple->extra_headers == NULL)
-			{
-				LM_ERR("No more shared memory\n");
-				goto error;
-			}
-			tuple->extra_headers->s = (char*)tuple->extra_headers + sizeof(str);
-			memcpy(tuple->extra_headers->s, extra_headers.s, extra_headers.len);
-			tuple->extra_headers->len = extra_headers.len;
-			pkg_free(extra_headers.s);
-		}
-	}
-
-	/* copy the function parameters that customize the scenario */
-	memset(tuple->scenario_params, 0, MAX_SCENARIO_PARAMS* sizeof(str));
-	if(scenario && args)
-	{
-		for(i = 0; i< scenario->param_no; i++)
-		{
-			if(args[i]==NULL)
-			{
-				LM_DBG("Fewer parameters, expected [%d] received [%d]\n",
-						scenario->param_no, i);
-				break;
-			}
-			/* must print the value of the argument */
-			if(msg && b2bl_caller != CALLER_MODULE)
-			{
-				buf_len= 255;
-				if(pv_printf(msg, (pv_elem_t*)args[i], buf, &buf_len)<0)
-				{
-					LM_ERR("cannot print the format\n");
-					goto error;
-				}
-
-				tuple->scenario_params[i].s = (char*)shm_malloc(buf_len);
-				if(tuple->scenario_params[i].s == NULL)
-				{
-					LM_ERR("No more shared memory\n");
-					goto error;
-				}
-				memcpy(tuple->scenario_params[i].s, buf, buf_len);
-				tuple->scenario_params[i].len = buf_len;
-				LM_DBG("Printed parameter [%.*s]\n", buf_len, buf);
-			}
-			else
-			{
-				if(args[i]->s==NULL || args[i]->len==0)
-				{
-					LM_DBG("Fewer parameters, expected [%d] received [%d]\n",
-							scenario->param_no, i);
-					break;
-				}
-
-				tuple->scenario_params[i].s = (char*)shm_malloc(args[i]->len);
-				if(tuple->scenario_params[i].s == NULL)
-				{
-					LM_ERR("No more shared memory\n");
-					goto error;
-				}
-				memcpy(tuple->scenario_params[i].s, args[i]->s, args[i]->len);
-				tuple->scenario_params[i].len = args[i]->len;
-			}
-		}
-	}
-	tuple->scenario_state = B2B_NOTDEF_STATE;
-
-	lock_get(&b2bl_htable[hash_index].lock);
-
-	if(local_index>= 0) /* a local index specified */ 
-	{
-		tuple->id = local_index;
-		if(b2bl_htable[hash_index].first == NULL)
-		{
-			b2bl_htable[hash_index].first = tuple;
-			tuple->prev = tuple->next = NULL;
-		}
-		else
-		{
-			prev_it = 0;
-			/*insert it in the proper place  */
-			for(it = b2bl_htable[hash_index].first; it && it->id<local_index; it=it->next)
-			{
-				prev_it = it;	
-			}
-			if(!prev_it)
-			{
-				b2bl_htable[hash_index].first = tuple;
-				tuple->prev = 0;
-				tuple->next = it;
-				it->prev = tuple;
-			}
-			else
-			{
-				tuple->prev = prev_it; 
-				prev_it->next = tuple;
-				tuple->next = it;
-				if(it)
-					it->prev = tuple;
-			}
-		}		
-	}
-	else
-	{
-
-		it = b2bl_htable[hash_index].first;
-		if(it == NULL)
-		{
-			b2bl_htable[hash_index].first = tuple;
-			tuple->prev = tuple->next = NULL;
-			tuple->id = 0;
-		}
-		else
-		{
-			while(it)
-			{
-				prev_it = it;
-				it = it->next;
-			}
-			prev_it->next = tuple;
-			tuple->prev = prev_it;
-			tuple->id = prev_it->id +1;
-		}
-	}
-	LM_DBG("hash index [%d]:\n", hash_index);
-	for(it = b2bl_htable[hash_index].first; it; it=it->next)
-	{
-		LM_DBG("id [%d]", it->id);	
-	}
-
-	b2bl_key = b2bl_generate_key(hash_index, tuple->id);
-	if(b2bl_key == NULL)
-	{
-		LM_ERR("failed to generate b2b logic key\n");
-		lock_release(&b2bl_htable[hash_index].lock);
-		return NULL;
-	}
-	tuple->key = b2bl_key;
-
-	*b2bl_key_s = b2bl_key;
-	tuple->db_flag = db_flag;
-
-	LM_DBG("new tuple [%p]->[%.*s]\n", tuple, b2bl_key->len, b2bl_key->s);
-
-	return tuple;
-error:
-	lock_release(&b2bl_htable[hash_index].lock);
-	return 0;
-}
-
-
-void unchain_ent(b2bl_entity_id_t *ent, b2bl_entity_id_t **first_ent)
-{
-	if(*first_ent == ent)
-	{
-		*first_ent = ent->next;
-		if(ent->next)
-			ent->next->prev = NULL;
-	}
-	else
-	{
-		if(ent->prev)
-			ent->prev->next = ent->next;
-		if(ent->next)
-			ent->next->prev = ent->prev;
-	}
-	ent->prev = NULL;
-	ent->next = NULL;
-}
-
-
-int b2bl_drop_entity(b2bl_entity_id_t* entity, b2bl_tuple_t* tuple)
-{
-	b2bl_entity_id_t* e;
-	unsigned int index;
-	int found = 0;
-
-	for (index = 0; index < MAX_B2BL_ENT; index++)
-	{
-		e = tuple->servers[index];
-		if (e == entity)
-		{
-			found = 1;
-			switch(index)
-			{
-				case 0:
-					tuple->servers[0] = tuple->servers[1];
-					tuple->servers[1] = NULL;
-					break;
-				case 1:
-					tuple->servers[1] = NULL;
-					if (tuple->servers[0] == NULL)
-						LM_ERR("inconsistent tuple [%p]->[%.*s]\n",
-							tuple, tuple->key->len, tuple->key->s);
-					break;
-				default:
-					LM_CRIT("we should never end up here\n");
-			}
-			break;
-		}
-		e = tuple->clients[index];
-		if (e == entity)
-		{
-			found = 1;
-			switch(index)
-			{
-				case 0:
-					tuple->clients[0] = tuple->clients[1];
-					tuple->clients[1] = NULL;
-					break;
-				case 1:
-					tuple->clients[1] = NULL;
-					if (tuple->clients[0] == NULL)
-						LM_ERR("inconsistent tuple [%p]->[%.*s]\n",
-							tuple, tuple->key->len, tuple->key->s);
-					break;
-				default:
-					LM_CRIT("we should never end up here\n");
-			}
-			break;
-		}
-	}
-	return found;
-}
-
-void b2bl_remove_single_entity(b2bl_entity_id_t *entity, b2bl_entity_id_t **head)
-{
-	unchain_ent(entity, head);
-	b2b_api.entity_delete(entity->type, &entity->key, entity->dlginfo, 0);
-	LM_DBG("destroying dlginfo=[%p]\n", entity->dlginfo);
-	if(entity->dlginfo)
-		shm_free(entity->dlginfo);
-	shm_free(entity);
-
-	return;
-}
-
-void b2bl_delete_entity(b2bl_entity_id_t* entity, b2bl_tuple_t* tuple)
-{
-	unsigned int i;
-	int found = 0;
-
-	if (entity->next || entity->prev)
-	{
-		LM_ERR("Inconsistent entity [%p]\n", entity);
-		b2bl_print_tuple(tuple, L_CRIT);
-		return;
-	}
-
-	found = b2bl_drop_entity(entity, tuple);
-
-	if(found)
-	{
-		LM_DBG("delete entity [%p]->[%.*s] from tuple [%.*s]\n",
-			entity, entity->key.len, entity->key.s, tuple->key->len, tuple->key->s);
-		b2b_api.entity_delete(entity->type, &entity->key, entity->dlginfo, 1);
-	}
-	else
-	{
-		LM_WARN("entity [%p]->[%.*s] not found for tuple [%.*s]\n",
-			entity, entity->key.len, entity->key.s, tuple->key->len, tuple->key->s);
-	}
-
-	if(entity->dlginfo)
-		shm_free(entity->dlginfo);
-
-	for(i = 0; i< MAX_BRIDGE_ENT; i++)
-		if(tuple->bridge_entities[i] == entity)
-			tuple->bridge_entities[i] = NULL;
-
-/*	if(entity->peer && entity->peer->peer==entity)
-		entity->peer->peer = NULL;
-*/
-
-	for(i = 0; i< MAX_B2BL_ENT; i++)
-	{
-		if(tuple->servers[i] && tuple->servers[i]->peer==entity)
-			tuple->servers[i]->peer= NULL;
-		if(tuple->clients[i] && tuple->clients[i]->peer==entity)
-			tuple->clients[i]->peer= NULL;
-	}
-
-	LM_INFO("delete tuple [%.*s], entity [%.*s]\n",
-			tuple->key->len, tuple->key->s, entity->key.len, entity->key.s);
-	shm_free(entity);
-
-	/* for debuging */
-	b2bl_print_tuple(tuple, L_DBG);
-}
-
-
-int b2bl_add_client(b2bl_tuple_t* tuple, b2bl_entity_id_t* entity)
-{
-	LM_INFO("adding entity [%p]->[%.*s] to tuple [%p]->[%.*s]\n",
-		entity, entity->key.len, entity->key.s,
-		tuple, tuple->key->len, tuple->key->s);
-
-	if (tuple->clients[0] == NULL)
-	{
-		if (tuple->clients[1])
-		{
-			LM_ERR("inconsistent clients state for tuple [%p]->[%.*s]\n",
-				tuple, tuple->key->len, tuple->key->s);
-			return -1;
-		}
-		tuple->clients[0] = entity;
-	}
-	else if (tuple->clients[1] == NULL)
-		tuple->clients[1] = entity;
-	else
-	{
-		LM_ERR("unable to add entity [%p]->[%.*s] to tuple [%p]->[%.*s], all spots taken\n",
-			entity, entity->key.len, entity->key.s,
-			tuple, tuple->key->len, tuple->key->s);
-		return -1;
-	}
-		
-	b2bl_print_tuple(tuple, L_DBG);
-	return 0;
-}
-
-
-int b2bl_add_server(b2bl_tuple_t* tuple, b2bl_entity_id_t* entity)
-{
-	LM_INFO("adding entity [%p]->[%.*s] to tuple [%p]->[%.*s]\n",
-		entity, entity->key.len, entity->key.s,
-		tuple, tuple->key->len, tuple->key->s);
-
-	if (tuple->servers[0] == NULL)
-	{
-		if (tuple->servers[1])
-		{
-			LM_ERR("inconsistent servers state for tuple [%p]->[%.*s]\n",
-				tuple, tuple->key->len, tuple->key->s);
-			return -1;
-		}
-		tuple->servers[0] = entity;
-	}
-	else if (tuple->servers[1] == NULL)
-		tuple->servers[1] = entity;
-	else
-	{
-		LM_ERR("unable to add entity [%p]->[%.*s] to tuple [%p]->[%.*s], all spots taken\n",
-			entity, entity->key.len, entity->key.s,
-			tuple, tuple->key->len, tuple->key->s);
-		return -1;
-	}
-		
-	b2bl_print_tuple(tuple, L_DBG);
-	return 0;
-}
-
-
-void b2bl_delete(b2bl_tuple_t* tuple, unsigned int hash_index,
-		int not_del_b2be)
-{
-	b2bl_entity_id_t *e;
-	int i;
-	int index;
-	b2bl_cb_params_t cb_params;
-
-	LM_DBG("Delete record [%p]->[%.*s], hash_index=[%d], local_index=[%d]\n",
-			tuple, tuple->key->len, tuple->key->s, hash_index, tuple->id);
-
-	if(tuple->cbf && tuple->cb_mask&B2B_DESTROY_CB)
-	{
-		memset(&cb_params, 0, sizeof(b2bl_cb_params_t));
-		cb_params.param = tuple->cb_param;
-		cb_params.stat = NULL;
-		cb_params.msg = NULL;
-		/* setting it to 0 but it has no meaning in this callback type */
-		cb_params.entity = 0;
-		tuple->cbf(&cb_params, B2B_DESTROY_CB);
-	}
-	if(!not_del_b2be)
-		b2bl_db_delete(tuple);
-	if(b2bl_htable[hash_index].first == tuple)
-	{
-		b2bl_htable[hash_index].first = tuple->next;
-		if(tuple->next)
-			tuple->next->prev = NULL;
-	}
-	else
-	{
-		if(tuple->prev)
-			tuple->prev->next = tuple->next;
-		if(tuple->next)
-			tuple->next->prev = tuple->prev;
-	}
-
-	for (index = 0; index < MAX_B2BL_ENT; index++)
-	{
-		e = tuple->servers[index];
-		if (e)
-		{
-			if (e->key.s && e->key.len && !not_del_b2be)
-				b2b_api.entity_delete(e->type, &e->key, e->dlginfo, 0);
-			if(e->dlginfo)
-				shm_free(e->dlginfo);
-			shm_free(e);
-		}
-		e = tuple->clients[index];
-		if (e)
-		{
-			if (e->key.s && e->key.len && !not_del_b2be)
-				b2b_api.entity_delete(e->type, &e->key, e->dlginfo, 0);
-			if(e->dlginfo)
-				shm_free(e->dlginfo);
-			shm_free(e);
-		}
-	}
-	/* clean up all entities in b2b_entities from db */
-	if(!not_del_b2be)
-		b2b_api.entities_db_delete(*tuple->key);
-
-//	if(tuple->bridge_entities[1] && tuple->bridge_entities[1]->key.s != NULL)
-//		shm_free(tuple->bridge_entities[1]->key.s);
-
-	for(i = 0; i< MAX_SCENARIO_PARAMS; i++)
-	{
-		if(tuple->scenario_params[i].s)
-			shm_free(tuple->scenario_params[i].s);
-	}
-
-	if(tuple->key)
-		shm_free(tuple->key);
-
-	if(tuple->extra_headers)
-		shm_free(tuple->extra_headers);
-
-	if(tuple->b1_sdp.s)
-		shm_free(tuple->b1_sdp.s);
-
-	shm_free(tuple);
-}
-
-/* key format : hash_index.local *
- */
-
-int b2bl_parse_key(str* key, unsigned int* hash_index,
-		unsigned int* local_index)
-{
-	char* p;
-	int hi_len;
-	str s;
-
-	if(!key || !key->s || !key->len)
-		return -1;
-
-	p= strchr(key->s, '.');
-	if(p == NULL)
-	{
-		LM_ERR("Wrong b2b logic key\n");
-		return -1;
-	}
-
-	hi_len = p - key->s;
-	s.s = key->s;
-	s.len = hi_len;
-	if(str2int(&s, hash_index)< 0)
-		return -1;
-	
-	s.s = p+1;
-	s.len = key->s + key->len - s.s;
-	if(str2int(&s, local_index)< 0)
-		return -1;
-
-	LM_DBG("hash_index = [%d]  - local_index= [%d]\n", *hash_index, *local_index);
-	return 0;
-}
-
-
-str* b2bl_generate_key(unsigned int hash_index, unsigned int local_index)
-{
-	char buf[15];
-	str* b2b_key;
-	int len;
-
-	len = sprintf(buf, "%d.%d", hash_index, local_index);
-
-	b2b_key = (str*)shm_malloc(sizeof(str)+ len);
-	if(b2b_key== NULL)
-	{
-		LM_ERR("no more shared memory\n");
-		return NULL;
-	}
-	b2b_key->s = (char*)b2b_key + sizeof(str);
-	memcpy(b2b_key->s, buf, len);
-	b2b_key->len = len;
-
-	return b2b_key;
-}
-
-b2bl_tuple_t* b2bl_search_tuple_safe(unsigned int hash_index, unsigned int local_index)
-{
-	b2bl_tuple_t* tuple;
-
-
-	tuple = b2bl_htable[hash_index].first;
-	while(tuple && tuple->id != local_index)
-	{
-		tuple = tuple->next;
-	}
-
-	return tuple;
-}
-
-int init_b2bl_htable(void)
-{
-	int i;
-	b2bl_htable = (b2bl_table_t)shm_malloc(b2bl_hsize* sizeof(b2bl_entry_t));
-	if(!b2bl_htable)
-		ERR_MEM(SHARE_MEM);
-	
-	memset(b2bl_htable, 0, b2bl_hsize* sizeof(b2bl_entry_t));
-	for(i= 0; i< b2bl_hsize; i++)
-	{
-		lock_init(&b2bl_htable[i].lock);
-		b2bl_htable[i].first = NULL;
-	}
-
-	return 0;
-error:
-	return -1;
-}
-
-void destroy_b2bl_htable(void)
-{
-	int i;
-	b2bl_tuple_t* tuple;
-
-	if(!b2bl_htable)
-		return;
-
-	for(i= 0; i< b2bl_hsize; i++)
-	{
-		lock_destroy(&b2bl_htable[i].lock);
-		tuple = b2bl_htable[i].first;
-
-		while(tuple)
-		{
-			b2bl_delete(tuple, i, 1);
-			tuple = b2bl_htable[i].first;
-		}
-	}
-	shm_free(b2bl_htable);
-}
-
-/* Take headers to pass on the other side:
- *	Content-Type: 
- *	Allow: 
- *	Supported:
- *	Require
- *	RSeq
- *	Session-Expires
- *	Min-SE
-*/
-int b2b_extra_headers(struct sip_msg* msg, str* b2bl_key, str* custom_hdrs, str* extra_headers)
-{
-	char* p;
-	struct hdr_field* require_hdr;
-	struct hdr_field* rseq_hdr;
-	struct hdr_field* subscription_state_hdr;
-	struct hdr_field* hdr;
-	struct hdr_field* hdrs[HDR_LST_LEN + HDR_DEFAULT_LEN];
-	int hdrs_no = 0;
-	int len = 0;
-	int i;
-	int custom_hdrs_len = 0;
-
-	if(msg->content_type)
-		hdrs[hdrs_no++] = msg->content_type;
-	if(msg->supported)
-		hdrs[hdrs_no++] = msg->supported;
-	if(msg->allow)
-		hdrs[hdrs_no++] = msg->allow;
-	if(msg->proxy_require)
-		hdrs[hdrs_no++] = msg->proxy_require;
-	if(msg->session_expires)
-		hdrs[hdrs_no++] = msg->session_expires;
-	if(msg->min_se)
-		hdrs[hdrs_no++] = msg->min_se;
-	if(msg->event)
-		hdrs[hdrs_no++] = msg->event;
-	
-
-	require_hdr = get_header_by_static_name( msg, "Require");
-	if(require_hdr)
-		hdrs[hdrs_no++] = require_hdr;
-
-	rseq_hdr = get_header_by_static_name( msg, "RSeq");
-	if(rseq_hdr)
-		hdrs[hdrs_no++] = rseq_hdr;
-
-	subscription_state_hdr = get_header_by_static_name( msg, "Subscription-state");
-	if(subscription_state_hdr)
-		hdrs[hdrs_no++] = subscription_state_hdr;
-
-	/* add also the custom headers */
-	for(i = 0; i< custom_headers_lst_len; i++)
-	{
-		hdr = get_header_by_name( msg, custom_headers_lst[i].s,
-				custom_headers_lst[i].len);
-		if(hdr)
-		{
-			hdrs[hdrs_no++] = hdr;
-		}
-	}
-
-	/* calculate the length*/
-	for(i = 0; i< hdrs_no; i++)
-		len += hdrs[i]->len;
-
-	if(init_callid_hdr.len && msg && msg->callid)
-		len+= init_callid_hdr.len + msg->callid->len;
-
-	if(custom_hdrs && custom_hdrs->s && custom_hdrs->len)
-	{
-		custom_hdrs_len = custom_hdrs->len;
-		len += custom_hdrs_len;
-	}
-
-	if(len == 0) return 0;
-
-	extra_headers->s = (char*)pkg_malloc(len);
-	if(extra_headers->s == NULL)
-	{
-		LM_ERR("No more memory\n");
-		return -1;
-	}
-
-	p = extra_headers->s;
-
-	/* construct the headers string */
-	for(i = 0; i< hdrs_no; i++)
-	{
-		memcpy(p, hdrs[i]->name.s, hdrs[i]->len);
-		p += hdrs[i]->len;
-	}
-	if(custom_hdrs_len)
-	{
-		memcpy(p, custom_hdrs->s, custom_hdrs_len);
-		p += custom_hdrs_len;
-	}
-
-	if(init_callid_hdr.s && msg && msg->callid)
-	{
-		memcpy(p, init_callid_hdr.s, init_callid_hdr.len);
-		p += init_callid_hdr.len;
-		len = sprintf(p, ": %.*s",
-			(int)(msg->callid->name.s +msg->callid->len -msg->callid->body.s),
-			msg->callid->body.s);
-		p += len;
-	}
-
-	extra_headers->len = p - extra_headers->s;
-
-	return 0;
-}
diff -Naur ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/text-base/records.h.svn-base ./b2b_logic/.svn/text-base/records.h.svn-base
--- ./trunk/src/opensips_1_7/modules/b2b_logic/.svn/text-base/records.h.svn-base	2012-10-31 10:33:42.873197479 +0000
+++ ./b2b_logic/.svn/text-base/records.h.svn-base	1970-01-01 01:00:00.000000000 +0100
@@ -1,155 +0,0 @@
-/*
- * $Id$
- *
- * back-to-back logic module
- *
- * Copyright (C) 2009 Free Software Fundation
- *
- * This file is part of opensips, a free SIP server.
- *
- * opensips is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version
- *
- * opensips is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License 
- * along with this program; if not, write to the Free Software 
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * History:
- * --------
- *  2009-08-03  initial version (Anca Vamanu)
- */
-
-#ifndef _B2BL_RECORDS_H
-#define _B2BL_RECORDS_H
-
-#include <libxml/parser.h>
-#include <stdlib.h>
-#include "../../str.h"
-#include "../../lock_ops.h"
-#include "b2b_logic.h"
-#include "b2b_load.h"
-
-typedef struct b2bl_entity_id
-{
-	str scenario_id;
-	str key;
-	str to_uri;
-	str from_uri;
-	str from_dname;
-	b2b_dlginfo_t* dlginfo;
-	int disconnected;
-	int state;
-	int no;
-	enum b2b_entity_type type;
-	b2bl_dlg_stat_t stats;
-	struct b2bl_entity_id* peer;
-	struct b2bl_entity_id* prev;
-	struct b2bl_entity_id* next;
-}b2bl_entity_id_t;
-
-#define NO_UPDATEDB_FLAG    0
-#define UPDATEDB_FLAG       1
-#define INSERTDB_FLAG       2
-
-#define MAX_B2BL_ENT		2
-#define MAX_BRIDGE_ENT		3
-#define MAX_SCENARIO_PARAMS	5
-
-typedef struct b2bl_tuple
-{
-	unsigned int id;
-	str* key;
-	b2b_scenario_t* scenario;  /* if scenario is NULL it means that the simple Topology Hiding Scenary must be applied*/
-	str scenario_params[MAX_SCENARIO_PARAMS];
-	int scenario_state;
-	int next_scenario_state;
-	b2bl_entity_id_t* servers[MAX_B2BL_ENT];
-	b2bl_entity_id_t* clients[MAX_B2BL_ENT];
-	b2bl_entity_id_t* bridge_entities[MAX_BRIDGE_ENT];
-	int to_del;
-	str* extra_headers;
-	struct b2bl_tuple* next;
-	struct b2bl_tuple* prev;
-	unsigned int lifetime;
-	str local_contact;
-	str sdp;
-	str b1_sdp; /* used for multiple attempts to bridge the first entity */
-	int db_flag;
-	b2bl_cback_f cbf;
-	unsigned int cb_mask;
-	void* cb_param;
-}b2bl_tuple_t;
-
-typedef struct b2bl_entry
-{
-	b2bl_tuple_t* first;
-	gen_lock_t lock;
-}b2bl_entry_t;
-
-typedef b2bl_entry_t* b2bl_table_t;
-
-
-#define PREP_REQ_DATA(entity) do{		\
-	req_data.et =(entity)->type;		\
-	req_data.b2b_key =&(entity)->key;	\
-	req_data.dlginfo =(entity)->dlginfo;	\
-}while(0)
-
-#define PREP_RPL_DATA(entity) do{		\
-	rpl_data.et =(entity)->type;		\
-	rpl_data.b2b_key =&(entity)->key;	\
-	rpl_data.dlginfo =(entity)->dlginfo;	\
-}while(0)
-
-
-void b2bl_print_tuple(b2bl_tuple_t* tuple, int log_level);
-
-b2bl_tuple_t* b2bl_insert_new(struct sip_msg* msg,
-		unsigned int hash_index, b2b_scenario_t* scenario,
-		str* args[], str* body, str* custom_hdrs, int local_index,
-		str** b2bl_key_s, int db_flag);
-
-str* b2bl_generate_key(unsigned int hash_index, unsigned int local_index);
-
-int b2bl_parse_key(str* key, unsigned int* hash_index,
-		unsigned int* local_index);
-
-b2bl_tuple_t* b2bl_search_tuple_safe(unsigned int hash_index,
-		unsigned int local_index);
-
-void b2bl_delete(b2bl_tuple_t* tuple, unsigned int hash_index,
-		int not_del_b2be);
-
-int init_b2bl_htable(void);
-
-extern b2bl_table_t b2bl_htable;
-extern unsigned int b2bl_hsize;
-
-int process_bridge_action(struct sip_msg* msg, b2bl_entity_id_t* curr_entity,
-		b2bl_tuple_t* tuple, xmlNodePtr bridge_node);
-
-void destroy_b2bl_htable(void);
-
-b2bl_entity_id_t* b2bl_create_new_entity(enum b2b_entity_type type, str* entity_id,
-		str* to_uri,str* from_uri,str* from_dname,str* ssid,struct sip_msg* msg);
-
-void unchain_ent(b2bl_entity_id_t *ent, b2bl_entity_id_t **head);
-void b2bl_remove_single_entity(b2bl_entity_id_t *entity, b2bl_entity_id_t **head);
-int b2bl_drop_entity(b2bl_entity_id_t* entity, b2bl_tuple_t* tuple);
-void b2bl_delete_entity(b2bl_entity_id_t* entity, b2bl_tuple_t* tuple);
-
-int b2b_extra_headers(struct sip_msg* msg, str* b2bl_key, str* custom_hdrs, str* extra_headers);
-
-int b2bl_add_client(b2bl_tuple_t* tuple, b2bl_entity_id_t* entity);
-int b2bl_add_server(b2bl_tuple_t* tuple, b2bl_entity_id_t* entity);
-
-void b2bl_db_delete(b2bl_tuple_t* tuple);
-
-#endif
